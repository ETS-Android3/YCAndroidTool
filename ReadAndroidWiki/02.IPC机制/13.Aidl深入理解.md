#### 目录介绍
- 01.Aidl中binder操作




### 01.Aidl中binder操作
- 通过AIDL实现方式解释Binder数据传输的具体过程
    - 服务端中的Service给与其绑定的客户端提供Binder对象，客户端通过AIDL接口中的asInterface()将这个Binder对象转换为代理Proxy，并通过它发起RPC请求。客户端发起请求时会挂起当前线程，并将参数写入data然后调用transact()，RPC请求会通过系统底层封装后由服务端的onTransact()处理，并将结果写入reply，最后返回调用结果并唤醒客户端线程。
- AIDL原理是什么？如何优化多模块都使用AIDL的情况？
    - AIDL(Android Interface Definition Language，Android接口定义语言)：如果在一个进程中要调用另一个进程中对象的方法，可使用AIDL生成可序列化的参数，AIDL会生成一个服务端对象的代理类，通过它客户端实现间接调用服务端对象的方法。
    - AIDL的本质是系统提供了一套可快速实现Binder的工具。关键类和方法：
    ```
    AIDL接口：继承IInterface。
    Stub类：Binder的实现类，服务端通过这个类来提供服务。
    Proxy类：服务器的本地代理，客户端通过这个类调用服务器的方法。
    asInterface()：客户端调用，将服务端的返回的Binder对象，转换成客户端所需要的AIDL接口类型对象。返回对象：
        若客户端和服务端位于同一进程，则直接返回Stub对象本身；
        否则，返回的是系统封装后的Stub.proxy对象。
    asBinder()：根据当前调用情况返回代理Proxy的Binder对象。
    onTransact()：运行服务端的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。
    transact()：运行在客户端，当客户端发起远程请求的同时将当前线程挂起。之后调用服务端的onTransact()直到远程请求返回，当前线程才继续执行。
    ```
    - 当有多个业务模块都需要AIDL来进行IPC，此时需要为每个模块创建特定的aidl文件，那么相应的Service就会很多。必然会现系统资源耗费严重、应用过度重量级的问题。解决办法是建立Binder连接池，即将每个业务模块的Binder请求统一转发到一个远Service中去执行，从而避免重复创建Service。
    - 工作原理：每个业务模块创建自己的AIDL接口并实现此接口，然后向服务端提供自己的唯一标识和其对应的Binder对象。服务端只需要一个Service，服务器提供一个queryBinder接口，它会根据业务模块的特征来返回相应的Binder对像，不同的业务模块拿到所需的Binder对象后就可进行远程方法的调用了。





### 5.部分源码解析
#### 5.1 服务端aidl编译生成的java文件
- 5.1.1 首先找到aidl编译生成的Java文件
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-f5482679617c5117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 5.1.2 分析生成的java文件
    - 这个ICheckAppInfoManager.java就是系统为我们生成的相应java文件，简单说下这个类。它声明了三个方法getAppInfo，setToken和setChannel，分明就是我们AIDL接口中的三个方法。同时他声明了3个id用来标识这几个方法，id用于标识在transact过程中客户端请求的到底是哪个方法。接着就是我们的Stub，可以看到它是一个内部类，他本质上是一个Binder类。当服务端和客户端位于同一个进程时，方法调用不会走跨进程的transact过程，当两者处于不同晋城市，方法调用走transact过程，这个逻辑由Stub的内部代理类Proxy完成。
    - 这个Stub对象之所以里面有我们AIDL的接口，正是因为官方替我们做好了，我们只要在这里具体实现就好了。



#### 5.2 客户端绑定服务端service原理
- 客户端也非常简单，首先我们连接到服务端Service，在连接成功时，也就是onServiceConnected方法里，通过asInterface(service)方法可以将服务端的Binder对象转换成客户端所需的AIDL的接口的对象。这种转换是区分进程的，如果是同一进程，那么此方法返回的就是Stub本身，否则返回的就是系统Stub.proxy对象。拿到接口对象之后，我们就能够调用相应方法进行自己的处理





















