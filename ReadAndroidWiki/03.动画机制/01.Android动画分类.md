#### 目录介绍
- 01.Android动画类型分类
- 02.Android动画实现方式分类
- 03.属性动画和补间动画区别



###  01.Android动画类型分类
- 逐帧动画【Frame Animation】，即顺序播放事先做好的图像，跟电影类似
- 补间动画【Tween Animation】，即通过对场景里的对象不断做图像变换 ( 平移、缩放、旋转 ) 产生动画效果
- 属性动画【Property Animation】，补间动画增强版，支持对对象执行动画
- 过渡动画【Transition Animation】,实现Activity或View过渡动画效果




###  02.Android动画实现方式分类
- XML资源文件
- 代码方式
#####  1.3 按照时间分类
- Android 3.0之前版本，逐帧动画，补间动画
- Android 3.0之后版本，属性动画
- Android 4.4中，过渡动画



### 03.属性动画和补间动画区别
#### 3.1 通俗的区别
- 属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际对象还是处于原来的地方。当动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity 无法释放而导致内存泄漏，而补间动画却没问题。xml文件实现的补间动画，复用率极高。在 Activity切换，窗口弹出时等情景中有着很好的效果。
- 补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。



#### 3.2 Animation和Animator实现机制区别
- 对于 Animation 动画:
    - 实现机制是,在每次进行绘图的时候,通过对整块画布的矩阵进行变换,从而实现一种视图坐标的移动,但实际上其在 View内部真实的坐标位置及其他相关属性始终恒定.
- 对于 Animator 动画:
    - Animator动画的实现机制说起来其实更加简单一点,因为他其实只是计算动画开启之后,结束之前,到某个时间点得时候,某个属性应该有的值,然后通过回调接口去设置具体值,其实 Animator 内部并没有针对某个 view 进行刷新,来实现动画的行为,动画的实现是在设置具体值的时候,方法内部自行调取的类似 invalidate 之类的方法实现的.也就是说,使用 Animator ,内部的属性发生了变化
- 或者更简单一点说
    - 前者属性动画，改变控件属性，（比如平移以后点击有事件触发）
    - 后者补间动画，只产生动画效果（平移之后点无事件触发，前提是你fillafter=true） 






##  2.Android逐帧动画
#####  2.1 逐帧动画简单介绍
- 也叫Drawable Animation动画，是最简单最直观动画类型
#####  2.2 逐帧动画XML资源文件方式
- 这个是最常用的方式，在res/drawable目录下新建动画XML文件，如下所示
- android:oneshot用来控制动画是否循环播放，true表示不会循环播放，false表示会循环播放
- android:duration="200"表示每一帧持续播放的时间
```
<?xml version="1.0" encoding="utf-8"?>
<animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="false">
    <item android:drawable="@mipmap/audio_anim_01" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_02" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_03" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_04" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_05" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_06" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_07" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_08" android:duration="200" />
    <item android:drawable="@mipmap/audio_anim_09" android:duration="200" />
</animation-list>
```
#####  2.3 逐帧动画代码方式
- 代码方式用的少，如下所示
```
AnimationDrawable drawable = new AnimationDrawable();
for(int a=0 ; a<9 ; a++){
    int id = getResources().getIdentifier("audio_anim_0" + a, "mipmap", getPackageName());
    Drawable da = getResources().getDrawable(id);
    drawable.addFrame(da,200);
}
ivVisualEffect.setBackground(drawable);
drawable.setOneShot(false);
//获取对象实例，用来控制播放与停止
AnimationDrawable rocketAnimation = (AnimationDrawable) ivVisualEffect.getBackground();
rocketAnimation.start();    // 开启帧动画
rocketAnimation.stop();     // 停止动画
```






### 01.补间动画简单介绍
- 无需关注每一帧，只需要定义动画开始与结束两个关键帧，并指定动画变化的时间与方式等
- **主要有四种基本的效果**
    - 透明度变化
    - 大小缩放变化
    - 位移变化
    - 旋转变化
- **表现形式**
    - XML中
        ```
        alph                   渐变透明度动画效果
        scale                  渐变尺寸伸缩动画效果
        translate              画面转换位置移动动画效果
        rotate                 画面转移旋转动画效果
        ```
    - JavaCode中
        ```
        AlphaAnimation         渐变透明度动画效果
        ScaleAnimation         渐变尺寸伸缩动画效果
        TranslateAnimation     画面转换位置移动动画效果
        RotateAnimation        画面转移旋转动画效果
        ```
- 差值器
    - Android系统会在补间动画开始和结束关键帧之间插入渐变值，它依据差值器。
    - Interpolator 时间插值类，定义动画变换的速度。能够实现alpha/scale/translate/rotate动画的加速、减速和重复等。Interpolator类其实是一个空接口，继承自TimeInterpolator，TimeInterpolator时间插值器允许动画进行非线性运动变换，如加速和限速等，该接口中只有接口中有一个方法 float getInterpolation(float input)这个方法。传入的值是一个0.0~1.0的值，返回值可以小于0.0也可以大于1.0。
    - **提供几个Interpolator的实现类**
        ```
        AccelerateInterpolator 加速，开始时慢中间加速
        DecelerateInterpolator 减速，开始时快然后减速
        AccelerateDecelerateInterolator 先加速后减速，开始结束时慢，中间加速
        AnticipateInterpolator 反向，先向相反方向改变一段再加速播放
        AnticipateOvershootInterpolator 反向加超越，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值
        BounceInterpolator 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100
        CycleIinterpolator 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2* mCycles* Math.PI* input)
        LinearInterpolator 线性，线性均匀改变
        OvershootInterpolator超越，最后超出目的值然后缓慢改变到目的值
        PathInterpolator新增的，就是可以定义路径坐标，然后可以按照路径坐标来跑动；注意其坐标并不是 XY，而是单方向，也就是我可以从0~1，然后弹回0.5 然后又弹到0.7 有到0.3，直到最后时间结束。
        ```


###  02.AplhaAnimation
- **第一种方式：XML方式，如下所示**
```
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <alpha
        android:duration="1000"
        android:fromAlpha="0.0"
        android:toAlpha="1.0" />
    <!--
    透明度控制动画效果 alpha
    浮点型值：
    fromAlpha 属性为动画起始时透明度
    toAlpha   属性为动画结束时透明度
    说明:
    0.0表示完全透明
    1.0表示完全不透明
    以上值取0.0-1.0之间的float数据类型的数字
    长整型值：
    duration  属性为动画持续时间
    说明:时间以毫秒为单位
    -->
</set>
```
- **第二种方式：代码方式**
```
AlphaAnimation alpha = new AlphaAnimation(0, 1);
alpha.setDuration(500);          //设置持续时间
alpha.setFillAfter(true);                   //动画结束后保留结束状态
alpha.setInterpolator(new AccelerateInterpolator());        //添加差值器
ivImage.setAnimation(alpha);
```


### 03.ScaleAnimation
- **第一种方式：XML资源文件方式**
```
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <scale
        android:duration="1000"
        android:fillAfter="false"
        android:fromXScale="0.0"
        android:fromYScale="0.0" android:interpolator="@android:anim/accelerate_decelerate_interpolator"
        android:pivotX="50%"
        android:pivotY="50%"
        android:toXScale="1.4"
        android:toYScale="1.4" />
    <!--
    尺寸伸缩动画效果 scale
    属性：interpolator 指定一个动画的插入器
    在我试验过程中，使用android.res.anim中的资源时候发现
    有三种动画插入器:
    accelerate_decelerate_interpolator  加速-减速 动画插入器
    accelerate_interpolator             加速-动画插入器
    decelerate_interpolator             减速- 动画插入器
    其他的属于特定的动画效果
    浮点型值：
    fromXScale 属性为动画起始时 X坐标上的伸缩尺寸
    toXScale   属性为动画结束时 X坐标上的伸缩尺寸
    fromYScale 属性为动画起始时Y坐标上的伸缩尺寸
    toYScale   属性为动画结束时Y坐标上的伸缩尺寸
    说明:
    以上四种属性值
    0.0表示收缩到没有
    1.0表示正常无伸缩
    值小于1.0表示收缩
    值大于1.0表示放大
    pivotX     属性为动画相对于物件的X坐标的开始位置
    pivotY     属性为动画相对于物件的Y坐标的开始位置
    说明:
    以上两个属性值 从0%-100%中取值
    50%为物件的X或Y方向坐标上的中点位置
    长整型值：
    duration  属性为动画持续时间
    说明:   时间以毫秒为单位
    布尔型值:
    fillAfter 属性 当设置为true ，该动画转化在动画结束后被应用
    -->
</set>
```
- **第二种方式：代码方式**
```
ScaleAnimation scale = new ScaleAnimation(1.0f, scaleXY, 1.0f, scaleXY, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
scale.setDuration(durationMillis);
scale.setFillAfter(true);
ivImage.setAnimation(scale);
``` 



### 04.TranslateAnimation
- **第一种方式：XML资源文件方式**
``` 
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" >
    <translate
        android:duration="2000"
        android:fromXDelta="30"
        android:fromYDelta="30"
        android:toXDelta="-80"
        android:toYDelta="300" />
    <!--
    translate 位置转移动画效果
    整型值:
    fromXDelta 属性为动画起始时 X坐标上的位置
    toXDelta   属性为动画结束时 X坐标上的位置
    fromYDelta 属性为动画起始时 Y坐标上的位置
    toYDelta   属性为动画结束时 Y坐标上的位置
    注意:
     没有指定fromXType toXType fromYType toYType 时候，
     默认是以自己为相对参照物
    长整型值：
    duration  属性为动画持续时间
    说明:   时间以毫秒为单位
    -->
</set>
```
- **第二种方式：代码方式**
```
TranslateAnimation translate = new TranslateAnimation(fromXDelta, toXDelta, fromYDelta, toYDelta);
translate.setDuration(durationMillis);
translate.setFillAfter(true);
ivImage.setAnimation(translate);
```



### 05.RotateAnimation
- **第一种方式：XML方式**
    - 含义表示从0到359度开始循环旋转，0-359(若设置成360在停止时会出现停顿现象)度旋转所用时间为500ms，旋转中心距离view的左顶点为50%距离，距离view的上边缘为50%距离，即正中心。
    ```
    <?xml version="1.0" encoding="utf-8"?>
    <set xmlns:android="http://schemas.android.com/apk/res/android" >
        <rotate
            android:duration="3000"
            android:fromDegrees="0" android:interpolator="@android:anim/accelerate_decelerate_interpolator"
            android:pivotX="50%"
            android:pivotY="50%"
            android:toDegrees="+359" />
        <!--
        rotate 旋转动画效果
        属性：interpolator 指定一个动画的插入器
        在我试验过程中，使用android.res.anim中的资源时候发现
        有三种动画插入器:
        accelerate_decelerate_interpolator    加速-减速 动画插入器
        accelerate_interpolator              加速-动画插入器
        decelerate_interpolator              减速- 动画插入器
        其他的属于特定的动画效果
        浮点数型值:
        fromDegrees 属性为动画起始时物件的角度
        toDegrees  属性为动画结束时物件旋转的角度 可以大于360度
        说明:
        当角度为负数-表示逆时针旋转
        当角度为正数-表示顺时针旋转
        (负数from-to正数:顺时针旋转)
        (负数from-to负数:逆时针旋转)
        (正数from-to正数:顺时针旋转)
        (正数from-to负数:逆时针旋转)
        pivotX    属性为动画相对于物件的X坐标的开始位置
        pivotY    属性为动画相对于物件的Y坐标的开始位置
        说明:        以上两个属性值 从0%-100%中取值    50%为物件的X或Y方向坐标上的中点位置
        长整型值：
        duration  属性为动画持续时间
        说明:      时间以毫秒为单位
        -->
    </set>
    ```
- **第二种方式：代码方式**
    ```
    RotateAnimation rotate = new RotateAnimation(fromDegrees, toDegrees, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
    rotate.setDuration(durationMillis);
    rotate.setFillAfter(true);
    ivImage.setAnimation(rotate);
    ```
    - fromDegrees 起始的角度度数。
    - toDegrees 结束的角度度数，负数表示逆时针，正数表示顺时针。如10圈则比android:fromDegrees大3600即可。
    - duration 表示从android:fromDegrees转动到android:toDegrees所花费的时间，单位为毫秒。可以用来计算速度。
    - 运行速度为运行时间(android:duration)除以运行角度差(android:toDegrees-android:fromDegrees)，比如android:duration为1000，android:toDegrees为360，android:fromDegrees为0就表示1秒转1圈。






##  4.Android属性动画
#####  4.1 属性动画基本介绍
- **补间动画增强版本，补间动画存在一些缺点**
- a.作用对象局限：View 。即补间动画 只能够作用在视图View上，即只可以对一个Button、TextView、甚至是LinearLayout、或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作
- b.没有改变View的属性，只是改变视觉效果
- c.动画效果单一

- **属性动画特点**
- 作用对象：任意 Java 对象，不再局限于 视图View对象
- 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放 & 透明度
- **基本工作原理**
- 在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果
- **属性动画基类：Animator，抽象类。子类有**
- 两个重要的类：ValueAnimator 类 & ObjectAnimator 类
- 其他类：Evaluator类，AnimatorSet类
- **关于常用属性动画类总结如下图所示**
![Image.png](/uploads/userup/10585/1G201191Z8-1C0-0.png)
#####  4.2 Evaluator
- **估值器（TypeEvaluator）作用**
- 设置动画 如何从初始值过渡到结束值的逻辑
- 插值器（Interpolator）决定值的变化模式（匀速、加速blabla）
- 估值器（TypeEvaluator）决定值的具体变化数值
- **看看接口TypeEvaluator 源代码**
```
public interface TypeEvaluator<T> {
    public T evaluate(float fraction, T startValue, T endValue);
}
```
**看看如何实现估值器**
```
public static ValueAnimator ofArgb(int... values) {
    ValueAnimator anim = new ValueAnimator();
    anim.setIntValues(values);
    anim.setEvaluator(ArgbEvaluator.getInstance());
    return anim;
}
//--------------------
public class ArgbEvaluator implements TypeEvaluator {
    private static final ArgbEvaluator sInstance = new ArgbEvaluator();
    public static ArgbEvaluator getInstance() {
        return sInstance;
    }
    // FloatEvaluator实现了TypeEvaluator接口
    public Object evaluate(float fraction, Object startValue, Object endValue) {
        // 参数说明
        // fraction：表示动画完成度（根据它来计算当前动画的值）
        // startValue、endValue：动画的初始值和结束值
        int startInt = (Integer) startValue;
        int startA = (startInt >> 24) & 0xff;
        int startR = (startInt >> 16) & 0xff;
        int startG = (startInt >> 8) & 0xff;
        int startB = startInt & 0xff;
        int endInt = (Integer) endValue;
        int endA = (endInt >> 24) & 0xff;
        int endR = (endInt >> 16) & 0xff;
        int endG = (endInt >> 8) & 0xff;
        int endB = endInt & 0xff;
        // 初始值 过渡 到结束值 的算法是：
        // 1. 用结束值减去初始值，算出它们之间的差值
        // 2. 用上述差值乘以fraction系数
        // 3. 再加上初始值，就得到当前动画的值
        return (int)((startA + (int)(fraction * (endA - startA))) << 24) |
                (int)((startR + (int)(fraction * (endR - startR))) << 16) |
                (int)((startG + (int)(fraction * (endG - startG))) << 8) |
                (int)((startB + (int)(fraction * (endB - startB))));
    }
}
```
#####  4.3 AnimatorSet
- **特点**
- 单一动画实现的效果相当有限，更多的使用场景是同时使用多种动画效果，即组合动画
- 使用方法
- **第一种方式：xml方式**
```
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:ordering="sequentially" >
    <!--表示Set集合内的动画按顺序进行-->
    <!--ordering的属性值:sequentially & together-->
    <!--sequentially:表示set中的动画，按照先后顺序逐步进行（a 完成之后进行 b ）-->
    <!--together:表示set中的动画，在同一时间同时进行,为默认值-->
    <set android:ordering="together" >
        <!--下面的动画同时进行-->
        <objectAnimator
            android:duration="2000"
            android:propertyName="translationX"
            android:valueFrom="0"
            android:valueTo="300"
            android:valueType="floatType" >
        </objectAnimator>
        <objectAnimator
            android:duration="3000"
            android:propertyName="rotation"
            android:valueFrom="0"
            android:valueTo="360"
            android:valueType="floatType" >
        </objectAnimator>
    </set>
    <set android:ordering="sequentially" >
        <!--下面的动画按序进行-->
        <objectAnimator
            android:duration="1500"
            android:propertyName="alpha"
            android:valueFrom="1"
            android:valueTo="0"
            android:valueType="floatType" >
        </objectAnimator>
        <objectAnimator
            android:duration="1500"
            android:propertyName="alpha"
            android:valueFrom="0"
            android:valueTo="1"
            android:valueType="floatType" >
        </objectAnimator>
    </set>
</set>
//关于代码中引用
AnimatorSet animator = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.animator.set_animation);
// 创建组合动画对象  &  加载XML动画
animator.setTarget(mButton);
// 设置动画作用对象
animator.start();
// 启动动画
```
- **第二种方式：Java方式**
```
// 步骤1：设置需要组合的动画效果
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX); 
// 平移动画
ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f); 
// 旋转动画
ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f); 
// 透明度动画
// 步骤2：创建组合动画的对象
AnimatorSet animSet = new AnimatorSet(); 
// 步骤3：根据需求组合动画
animSet.play(translation).with(rotate).before(alpha); 
animSet.setDuration(5000); 
// 步骤4：启动动画
animSet.start();
``` 
- **常用方法**
``` 
AnimatorSet.play(Animator anim)   ：播放当前动画
AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行
AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行
AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行
AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行
``` 
#####  4.4 ValueAnimator
- **基本作用**
- 将初始值 以整型数值的形式 过渡到结束值 。即估值器是整型估值器 - IntEvaluator
ValueAnimator.oFloat（）采用默认的浮点型估值器 (FloatEvaluator)
ValueAnimator.ofInt（）采用默认的整型估值器（IntEvaluator）
- **第一种实现方式：Java设置**
``` 
public static ValueAnimator setValueAnimator(View view , int start , int end , int time , int delay , int count){
    // 步骤1：设置动画属性的初始值 & 结束值
    ValueAnimator mAnimator = ValueAnimator.ofInt(start, end);
    // ofInt（）作用有两个
    // 1. 创建动画实例
    // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和1,表示将值从0平滑过渡到1
    // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推
    // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值
    // 关于自定义插值器我将在下节进行讲解
    // 下面看看ofInt()的源码分析 ->>关注1
    mAnimator.setTarget(view);
    // 步骤2：设置动画的播放各种属性
    mAnimator.setDuration(time);
    // 设置动画运行的时长
    mAnimator.setStartDelay(delay);
    // 设置动画延迟播放时间
    mAnimator.setRepeatCount(count);
    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    mAnimator.setRepeatMode(ValueAnimator.RESTART);
    // 设置重复播放动画模式
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放
    // 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器
    // 设置 值的更新监听器
    // 即：值每次改变、变化一次,该方法就会被调用一次
    return mAnimator;
}
//-------
Button b1 = (Button) findViewById(R.id.b1);
ValueAnimator valueAnimator = AnimatorUtils.setValueAnimator(b1,0, 2, 2000, 500, 2);
valueAnimator.start();
``` 
- **第二种实现方式：XML设置**
``` 
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <animator
        android:valueFrom="0"
        android:valueTo="100"
        android:valueType="intType"
        android:duration="3000"
        android:startOffset ="1000"
        android:fillBefore = "true"
        android:fillAfter = "false"
        android:fillEnabled= "true"
        android:repeatMode= "restart"
        android:repeatCount = "0" android:interpolator="@android:anim/accelerate_interpolator"/>
        <!--初始值-->
        <!--结束值-->
        <!--变化值类型 ：floatType & intType-->
        <!--动画持续时间（ms），必须设置，动画才有效果-->
        <!--动画延迟开始时间（ms）-->
        <!--动画播放完后，视图是否会停留在动画开始的状态，默认为true-->
        <!--动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false-->
        <!--是否应用fillBefore值，对fillAfter值无影响，默认为true-->
        <!--选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|-->
        <!--重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复-->
        <!--插值器，即影响动画的播放速度,下面会详细讲-->
</set>
//代码引用
Button b3 = (Button) findViewById(R.id.b3);
Animator mAnim = AnimatorInflater.loadAnimator(this, R.animator.animator_1_0);
mAnim.setTarget(b3);
mAnim.start();
``` 
#####  4.5 ObjectAnimator
- **基本的原理**
- 直接对对象的属性值进行改变操作，从而实现动画效果
继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类
- **第一种实现方式：Java设置**
``` 
public static ObjectAnimator setObjectAnimator(View view , String type , int start , int end , long time){
    ObjectAnimator mAnimator = ObjectAnimator.ofFloat(view, type, start, end);
    // ofFloat()作用有两个
    // 1. 创建动画实例
    // 2. 参数设置：参数说明如下
    // Object object：需要操作的对象
    // String property：需要操作的对象的属性
    // float ....values：动画初始值 & 结束值（不固定长度）
    // 若是两个参数a,b，则动画效果则是从属性的a值到b值
    // 若是三个参数a,b,c，则则动画效果则是从属性的a值到b值再到c值
    // 以此类推
    // 至于如何从初始值 过渡到 结束值，同样是由估值器决定，此处ObjectAnimator.ofFloat（）是有系统内置的浮点型估值器FloatEvaluator，同ValueAnimator讲解

    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    mAnimator.setRepeatCount(ValueAnimator.INFINITE);
    // 设置动画运行的时长
    mAnimator.setDuration(time);
    // 设置动画延迟播放时间
    mAnimator.setStartDelay(0);
    // 设置重复播放动画模式
    mAnimator.setRepeatMode(ValueAnimator.RESTART);
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放
    //设置差值器
    mAnimator.setInterpolator(new LinearInterpolator());
    return mAnimator;
}
``` 
- **关于preperty的属性值有，如下表所示**
![Image.png](/uploads/userup/10585/1G201191Z8-4594-1.png)
- **第二种方式：XML方式**
``` 
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <ObjectAnimator
        android:valueFrom="1"
        android:valueTo="0"
        android:valueType="floatType"
        android:duration = "800"
        android:propertyName="alpha"/>
</set>
Animator mAnim = AnimatorInflater.loadAnimator(this, R.animator.animator_1_0);
mAnim.setTarget(fabHomeRandom);
mAnim.start();
``` 
- **注意，以XML方式，res的文件夹名称必须是animator，否则无法引用，如下所示：**
![Image.png](/uploads/userup/10585/1G201191Z8-4496-2.png)

#####  4.6 ValueAnimator与ObjectAnimator区别
- ValueAnimator 类是先改变值，然后手动赋值 给对象的属性从而实现动画；是间接对对象属性进行操作；
- ObjectAnimator 类是先改变值，然后自动赋值 给对象的属性从而实现动画；是直接对对象属性进行操作；

#####  4.7 监听动画器
- **说明**
- Animation类通过监听动画开始 / 结束 / 重复 / 取消时刻来进行一系列操作，如跳转页面等等
通过在Java代码里addListener（）设置
因Animator类、AnimatorSet类、ValueAnimator、ObjectAnimator类存在继承关系，所以AnimatorSet类、ValueAnimator、ObjectAnimator都可以使用addListener()监听器进行动画监听
- 看看第一种监听方式
``` 
mAnim.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {
        //动画开始时执行
    }
    @Override
    public void onAnimationEnd(Animator animation) {
        //动画结束时执行
    }
    @Override
    public void onAnimationCancel(Animator animation) {
        //动画取消时执行
    }
    @Override
    public void onAnimationRepeat(Animator animation) {
        //动画重复时执行
    }
});
``` 
- **看看这二中监听方式**
``` 
mAnim2.addListener(new AnimatorListenerAdapter() {
    // 向addListener()方法中传入适配器对象AnimatorListenerAdapter()
    // 由于AnimatorListenerAdapter中已经实现好每个接口
    // 所以这里不实现全部方法也不会报错
    @Override
    public void onAnimationCancel(Animator animation) {
        super.onAnimationCancel(animation);
        ToastUtils.showShort("动画结束了");
    }
});
``` 






##  6.Android动画框架原理解析
#####  6.1 关于补间动画原理
- 要了解Android动画是如何加载出来的,我们首先要了解Android View 是如何组织在一起的.每个窗口是一颗View树. RootView是DecorView,在布局文件中声明的布局都是DecorView的子View.是通过setContentView来设置进入窗口内容的. 因为View的布局就是一棵树.所以绘制的时候也是按照树形结构来遍历每个View进行绘制.ViewRoot.java中 draw函数准备好Canvas后 调用 mView.draw(canvas),这里的mView是DecorView.
- **下面看一下递归绘制的几个步骤:**
- 1.绘制背景
- 2.如果需要,保存画布(canvas),为淡入淡出做准备
- 3.通过调用View.onDraw(canvas)绘制View本身的内容
- 4.通过 dispatchDraw(canvas)绘制自己的孩子,dispatchDraw->drawChild->child.draw(canvas) 这样的调用过程被用来保证每个子 View 的 draw 函数都被调用
- 5.如果需要，绘制淡入淡出相关的内容并恢复保存的画布所在的层（layer）
- 6.绘制修饰的内容（例如滚动条）
- 当一个 ChildView 要重画时，它会调用其成员函数 invalidate() 函数将通知其 ParentView 这个 ChildView 要重画，这个过程一直向上遍历到 ViewRoot，当 ViewRoot 收到这个通知后就会调用上面提到的 ViewRoot 中的 draw 函数从而完成绘制。Android 动画就是通过 ParentView 来不断调整 ChildView 的画布坐标系来实现的





### 2.Animation运行原理和源码分析
#### 2.1 基本属性介绍
- 上一篇文章已经对补间动画做了详细的说明，不过这里还是需要重复说一下动画属性的作用
    - mStartTime：动画实际开始时间
    - mStartOffset：动画延迟时间
    - mFillEnabled：mFillBefore及mFillAfter是否使能
    - mFillBefore：动画结束之后是否需要进行应用动画
    - mFillAfter：动画开始之前是否需要进行应用动画
    - mDuration：单次动画运行时长
    - mRepeatMode：动画重复模式（RESTART、REVERSE）
    - mRepeatCount：动画重复次数（INFINITE，直接值）
    - mInterceptor：动画插间器
    - mBackgroundColor：动画背景颜色
    - mListener：动画开始、结束、重复回调监听器



#### 2.2 如何计算动画数据
- 首先进入Animation类，然后找到getTransformation方法，主要是分析这个方法逻辑，如图所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-d999c70a98e8b17f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 那么这个方法中做了什么呢？Animation在其getTransformation函数被调用时会计算一帧动画数据，而上面这些属性基本都是在计算动画数据时有相关的作用。
- 第一步：若startTime为START_ON_FIRST_FRAME(值为-1)时，将startTime设定为curTime
- 第二步：计算当前动画进度：
    - normalizedTime = (curTime - (startTime + startOffset))/duration
    - 若mFillEnabled==false：将normalisedTime夹逼至[0.0f, 1.0f]
- 第三步：判断是否需要计算动画数据：
    - 若normalisedTime在[0.0f, 1.0f]，需计算动画数据
    - 若normalisedTime不在[0.0f, 1.0f]：
        - normalisedTime<0.0f, 仅当mFillBefore==true时才计算动画数据
        - normalisedTime>1.0f, 仅当mFillAfter==true时才计算动画数据
- 第四步：若需需要计算动画数据：
    - 若当前为第一帧动画，触发mListener.onAnimationStart
    - 若mFillEnabled==false：将normalisedTime夹逼至[0.0f, 1.0f]
    - 根据插间器mInterpolator调整动画进度：
    - interpolatedTime = mInterpolator.getInterpolation(normalizedTime)
    - 若动画反转标志位mCycleFlip为true，则
    - interpolatedTime = 1.0 - normalizedTime
    - 调用动画更新函数applyTransformation(interpolatedTime, transformation)计算出动画数据
- 第五步：若夹逼之前normalisedTime大于1.0f, 则判断是否需继续执行动画：
    - 已执行次数mRepeatCount等于需执行次数mRepeated
        - 若未触发mListener.onAnimationEnd，则触发之
    - 已执行次数mRepeatCount不等于需执行次数mRepeated
        - 自增mRepeatCount
        - 重置mStartTime为-1
        - 若mRepeatMode为REVERSE，则取反mCycleFlip
        - 触发mListener.onAnimationRepeat



#### 2.3 什么是动画更新函数
- 下面我们来看一下getTransformation方法中的这一行代码applyTransformation(interpolatedTime, outTransformation)，然后进去看看这个方法。如下所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-220a227e0fd51206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 这个方法的用途是干啥呢？从这个英文解释中可以得知：getTransform的助手。子类应该实现这一点，以应用给定的内插值来应用它们的转换。该方法的实现应该总是替换指定的转换或文档，而不是这样做的。
- 都知道Animation是个抽象类，接着我们这些逗比程序员可以看看它的某一个子类，比如看看ScaleAnimation中的applyTransformation方法吧。
    - 是否设定缩放中心点： 
        - 若mPivotX==0 且 mPivotY==0：transformation.getMatrix().setScale(sx, sy)
        - 否则：transformation.getMatrix().setScale(sx, sy, mPivotX, mPivotY)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-eb1b0b527f74dd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 介绍到这里还是没有讲明白它的具体作用，它是在什么情况下调用的。不要着急，接下来会慢慢分析的……



#### 2.4 动画数据如何存储
- 可以看到applyTransformation(float interpolatedTime, Transformation t)这个方法中带有一个Transformation参数，那么这个参数是干啥呢？
    - 实际上，Animation的动画函数getTransformation目的在于生成当前帧的一个Transformation，这个Transformation采用alpha以及Matrix存储了一帧动画的数据，Transformation包含两种模式：
        - alpha模式：用于支持透明度动画
        - matrix模式：用于支持缩放、平移以及旋转动画
    - 同时，Transformation还提供了许多两个接口用于组合多个Transformation：
        - compose：前结合（alpha相乘、矩阵右乘、边界叠加）
        - postCompose：后结合（alpha相乘、矩阵左乘、边界叠加



#### 2.5 Animation的调用
- getTransformation这个函数究竟是在哪里调用的？计算得到的动画数据又是怎么被应用的？为什么Animation这个包要放在android.view下面以及Animation完成之后为什么View本身的属性不会被改变。慢慢看……
    - 要了解Animation，先从要从Animation的基本使用View.startAnimation开始寻根溯源：如下所示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-a71aeb172fbdb3d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看setStartTime这个方法，主要是设置一些属性。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-545bd4bfbc357959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看setAnimation(animation)方法源码
    - 设置要为此视图播放的下一个动画。如果希望动画立即播放，请使用{@link#startAnimation(android.view.animation.Animation)}代替此方法，该方法允许对启动时间和无效时间进行细粒度控制，但必须确保动画具有启动时间集，并且当动画应该启动时，视图的父视图(控制子视图上的动画)将失效。
    ```
    public void setAnimation(Animation animation) {
        mCurrentAnimation = animation;
        if (animation != null) {
            if (mAttachInfo != null && mAttachInfo.mDisplayState == Display.STATE_OFF
                    && animation.getStartTime() == Animation.START_ON_FIRST_FRAME) {
                animation.setStartTime(AnimationUtils.currentAnimationTimeMillis());
            }
            animation.reset();
        }
    }
    ```
- 接着重点看一下invalidate(true)这个方法
    - 通过invalidate(true)函数会触发View的重新绘制，那么在View.draw是怎么走到对Animation的处理函数呢？
    ```
    View.draw(Canvas)
    —> ViewGroup.dispatchDraw(Canvas)
    —> ViewGroup.drawChild(Canvas, View, long)
    —> View.draw(Canvas, ViewGroup, long)
    —> View.applyLegacyAnimation(ViewGroup, long, Animation, boolean)
    ```
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-29e13cbca350f60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看看View中applyLegacyAnimation这个方法
    ```
    private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
            Animation a, boolean scalingRequired) {
        Transformation invalidationTransform;
        final int flags = parent.mGroupFlags;
        //判断Animation是否初始化
        final boolean initialized = a.isInitialized();
        //如果没有初始化，则进行初始化
        if (!initialized) {
            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());
            a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop);
            if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler);
            //由父视图组调用，通知当前与此视图关联的动画的开始。如果重写此方法，则始终调用Super.on动画Start()；
            onAnimationStart();
        }
    
        //获取Transformation对象
        final Transformation t = parent.getChildTransformation();
        //获取要在指定时间点应用的转换，这个方法最终调用了Animation中的getTransformation方法
        //调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据
        boolean more = a.getTransformation(drawingTime, t, 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (parent.mInvalidationTransformation == null) {
                parent.mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = parent.mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = t;
        }
    
        //下面主要是，根据动画数据设定重绘制区域
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) {
                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    //调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
                    parent.invalidate(mLeft, mTop, mRight, mBottom);
                }
            } else {
                if (parent.mInvalidateRegion == null) {
                    parent.mInvalidateRegion = new RectF();
                }
                final RectF region = parent.mInvalidateRegion;
                a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region,
                        invalidationTransform);
                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
    
                final int left = mLeft + (int) region.left;
                final int top = mTop + (int) region.top;
                
                //调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
                parent.invalidate(left, top, left + (int) (region.width() + .5f),
                        top + (int) (region.height() + .5f));
            }
        }
        return more;
    }
    ```
    - View.applyLegacyAnimation就是Animation大显神通的舞台，其核心代码主要分三个部分
        - 初始化Animation（仅初始化一次）
            - 调用Animation.initialize(width, height, parentWidth, parentHeight)，通过View及ParentView的Size来解析Animation中的相关数据；
            - 调用Animation.initializeInvalidateRegion(left, top, right, bottom)来设定动画的初始区域，并在fillBefore为true时计算Animation动画进度为0.0f的数据
        - 调用getTransformation根据当前绘制事件生成Animation中对应帧的动画数据
        - 根据动画数据设定重绘制区域
            - 若仅为Alpha动画，此时动画区域为View的当前区域，且不会产生变化
            - 若包含非Alpha动画，此时动画区域需要调用Animation.getInvalidateRegion进行计算，该函数会根据上述生成动画数据Thransformation中的Matrix进行计算，并与之前的动画区域执行unio操作，从而获取动画的完整区域
            - 调用ViewGroup.invalidate(int l, int t, int r, int b)设定绘制区域
- 当View.applyLegacyAnimation调用完成之后，View此次绘制的动画数据就构建完成，之后便回到View.draw(Canvas, ViewGroup, long)应用动画数据对视图进行绘制刷新，如下所示：
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-5f622fe2456db362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 重点看到Animation产生的动画数据实际并不是应用在View本身的，而是应用在RenderNode或者Canvas上的，这就是为什么Animation不会改变View的属性的根本所在。另一方面，我们知道Animation仅在View被绘制的时候才能发挥自己的价值，这也是为什么插间动画被放在Android.view包内。





### 3.Animator运行原理和源码分析
#### 3.1 属性动画的基本属性
- 属性动画跟补间动画一样会包含动画相关的属性，如动画时长、动画播放次数、延迟时间、插间器等等，为了后面分析动画运行流程时概念更加明确，这里仅仅写了部分ValueAnimator源码中的字段，并做了相应的注解
    ```
    // 初始化函数是否被调用 
    boolean mInitialized = false; 
    // 动画时长 
    private long mDuration = (long)(300 * sDurationScale); 
    private long mUnscaledDuration = 300; 
    // 动画延时 
    private long mStartDelay = 0; 
    private long mUnscaledStartDelay = 0; 
    // 动画重复模式及次数 
    private int mRepeatCount = 0; 
    private int mRepeatMode = RESTART; 
    // 插间器
    private TimeInterpolator mInterpolator = sDefaultInterpolator; 
    // 动画开始运行的时间点 
    long mStartTime; 
    // 是否需要在掉帧的时候调整动画开始时间点 
    boolean mStartTimeCommitted; 
    // 动画是否反方向运行，当repeatMode=REVERSE是会每个动画周期反转一次 
    private boolean mPlayingBackwards = false;
    // 当前动画在一个动画周期中所处位置 
    private float mCurrentFraction = 0f; 
    // 动画是否延时 
    private boolean mStartedDelay = false; 
    // 动画完成延时的时间点 
    private long mDelayStartTime; 
    // 动画当前所处的状态：STOPPED, RUNNING, SEEKED 
    int mPlayingState = STOPPED; 
    // 动画是否被启动 
    private boolean mStarted = false; 
    // 动画是否被执行（以动画第一帧被计算为界） 
    private boolean mRunning = false; 
    
    // 回调监听器 
    // 确保AnimatorListener.onAnimationStart(Animator)仅被调用一次 
    private boolean mStartListenersCalled = false; 
    // start,end,cancel,repeat回调
    ArrayList<AnimatorListener> mListeners = null; 
    // pause, resume回调
    ArrayList<AnimatorPauseListener> mPauseListeners = null;  
    // value更新回调
    ArrayList<AnimatorUpdateListener> mUpdateListeners = null; 
    ```

#### 3.2 属性动画新的概念
- 属性动画相对于插间动画来件引入了一些新的概念
    - 可以暂停和恢复、可以调整进度，这些概念的引入，让动画的概念更加饱满起来，让动画有了视频播放的概念，主要有：
    ```
    // 动画是否正在running
    private boolean mRunning = false;
    // 动画是否被开始
    private boolean mStarted = false;
    // 动画是否被暂停 
    boolean mPaused = false; 
    // 动画暂停时间点，用于在动画被恢复的时候调整mStartTime以确保动画能优雅地继续运行 
    private long mPauseTime; 
    // 动画是否从暂停中被恢复，用于表明动画可以调整mStartTime
    private boolean mResumed = false; 
    // 动画被设定的进度位置
    float mSeekFraction = -1;
    ```


#### 3.3 PropertyValuesHolder作用
- PropertyValuesHolder是用来保存某个属性property对应的一组值，这些值对应了一个动画周期中的所有关键帧。
    - 动画说到底是由动画帧组成的，将动画帧连续起来就成了动画呢。
    - Animator可以设定并保存整个动画周期中的关键帧，然后根据这些关键帧计算出动画周期中任一时间点对应的动画帧的动画数据
    - 而每一帧的动画数据里都包含了一个时间点属性fraction以及一个动画值mValue，从而实现根据当前的时间点计算当前的动画值，然后用这个动画值去更新property对应的属性
    - **Animator被称为属性动画的原因，因为它的整个动画过程实际上就是不断计算并更新对象的属性**这个后面详细讲解。
- 那么保存property使用什么存储的呢？看代码可知：数组
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-0114b7d8c02df548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- PropertyValuesHolder由Property及Keyframes组成，其中Property用于描述属性的特征：如属性名以及属性类型，并提供set及get方法用于获取及设定给定Target的对应属性值；Keyframes由一组关键帧Keyframe组成，每一个关键帧由fraction及value来定量描述，于是Keyframes可以根据给定的fraction定位到两个关键帧，这两个关键帧的fraction组成的区间包含给定的fraction，然后根据定位到的两个关键帧以及设定插间器及求值器就可以计算出给定fraction对应的value。
    - PropertyValuesHolder的整个工作流程
        - 首先通过setObjectValues等函数来初始化关键帧组mKeyframes，必要的情况下（如ObjectAnimator）可以通过setStartValue及setEndValue来设定第一帧及最末帧的value，以上工作只是完成了PropertyValuesHolder的初始化，
        - 之后就可以由Animator在绘制动画帧的时候通过fraction来调用calculateValue计算该fraction对应的value（实际上是由mKeyframes的getValue方法做出最终计算），获得对应的value之后，一方面可以通过getAnimatedValue提供给Animator使用，
        - 另一方面也可以通过setAnimatedValue方法直接将该值设定到相应Target中去，这样PropertyValuesHolder的职责也就完成呢。


#### 3.4 属性动画start执行流程
- 首先看看start方法，默认是false，这个参数是干嘛的呢？这个参数是动画是否应该开始反向播放。
    - 启动动画播放。这个版本的start()使用一个布尔标志，指示动画是否应该反向播放。该标志通常为false，但如果从反向()方法调用，则可以将其设置为true。通过调用此方法启动的动画将在调用此方法的线程上运行。这个线程应该有一个活套(如果不是这样的话，将抛出一个运行时异常)。另外，如果动画将动画化视图层次结构中对象的属性，那么调用线程应该是该视图层次结构的UI线程。
    ```
    @Override
    public void start() {
        start(false);
    }
    
    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        mReversing = playBackwards;
        mSelfPulse = !mSuppressSelfPulseRequested;
        if (playBackwards && mSeekFraction != -1 && mSeekFraction != 0) {
            if (mRepeatCount == INFINITE) {
                float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction));
                mSeekFraction = 1 - fraction;
            } else {
                mSeekFraction = 1 + mRepeatCount - mSeekFraction;
            }
        }
        mStarted = true;
        mPaused = false;
        mRunning = false;
        mAnimationEndRequested = false;
        mLastFrameTime = -1;
        mFirstFrameTime = -1;
        mStartTime = -1;
        addAnimationCallback(0);

        if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
            startAnimation();
            if (mSeekFraction == -1) {
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }
    ```
- 然后接着看addAnimationCallback(0)这行代码，从字面意思理解是添加动画回调callback
    - 可以看到通过getAnimationHandler()创建了一个AnimationHandler对象。
    - 然后在看看addAnimationFrameCallback()这个方法，看命名应该是专门处理动画相关的。实际上里面的逻辑大概是：通过Choreographer向底层注册下一个屏幕刷新信号监听，然后将需要运行的动画添加到列表中，如果延迟时间大于0，则说明动画是一个延迟开始的动画，那么加入Delay队列里。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-611bcf80a93bfebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-c06fa6fa856fdf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - 然后看看动画是用什么存储的呢？mAnimationCallbacks是一个ArrayList，每一项保存的是 AnimationFrameCallback 接口的对象，看命名这是一个回调接口
- AnimationHandler的作用主要是什么呢？
    - 是一个定时任务处理器，根据Choreographer的脉冲周期性地完成指定的任务，由于它是一个线程安全的静态变量，因此运行在同一线程中的所有Animator共用一个定时任务处理器，这样的好处在于：一方面可以保证Animator中计算某一时刻动画帧是在同一线程中运行的，避免了多线程同步的问题；另一方面，该线程下所有动画共用一个处理器，可以让这些动画有效地进行同步，从而让动画效果更加优雅。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-8481ef49cc8df2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 然后在回到start(boolean playBackwards)方法中，查看startAnimation()源码。
    - 内部调用，通过将动画添加到活动动画列表来启动动画。必须在UI线程上调用。
    - 通过notifyStartListeners()这个方法，刷新动画listener，也就是通知动画开始呢。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-a12162003f6d96c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 接着看initAnimation()初始化动画操作逻辑
    - 在处理动画的第一个动画帧之前立即调用此函数。如果存在非零<code>startDelay</code>，则在延迟结束后调用该函数，它负责动画的最终初始化步骤。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-fe2776e70e6a304b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.5 属性动画cancel和end执行流程
- **先看看cancel中的源码**
    - 可以得知，cancel只会处理那些正在运行或者等待开始运行的动画，大概的处理逻辑是这样的：
        - 调用AnimatorListener.onAnimationCancel
        - 然后调用Animator.endAnimation
            - 通过removeAnimationCallback()把该动画从AnimationHandler的所有列表中清除
            - 调用AnimatorListener.onAnimationEnd
            - 复位动画所有状态：如mPlayingState = STOPPED、mRunning=false、mReversing = false、mStarted = false等等
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-0a3d919f0c017543.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-91e9d43f64aa5d8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **再看看end中的源码**
    - end相对于cancel来说有两个区别：一个是会处理所有动画；另一个是会计算最末一帧动画值。其具体的处理逻辑如下所示：
        - 若动画尚未开始：调用Animatior.startAnimation让动画处于正常运行状态
        - 计算最后一帧动画的动画值：animateValue(mPlayingBackwards ? 0f : 1f)
        - 结束动画就调用endAnimation这个方法，上面已经分析了该方法的作用
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-5cb0bbba1ac1a1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.6 属性动画pase和resume执行流程
- **先看看pause方法中的源码**
    - 先看在Animator中的pause方法，然后看ValueAnimator中的pause方法可知：
    - 仅仅在动画已开始（isStarted()==true）且当前为非暂停状态时才进行以下处理
        - 置位：mPaused = true
        - 循环遍历调用AnimatorPauseListener.onAnimationPause
        - 清空暂停时间：mPauseTime = -1
        - 复位mResumed = false
    ```
    //在ValueAnimator中
    public void pause() {
        boolean previouslyPaused = mPaused;
        super.pause();
        if (!previouslyPaused && mPaused) {
            mPauseTime = -1;
            mResumed = false;
        }
    }
    
    //在Animator中
    public void pause() {
        if (isStarted() && !mPaused) {
            mPaused = true;
            if (mPauseListeners != null) {
                ArrayList<AnimatorPauseListener> tmpListeners =
                        (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onAnimationPause(this);
                }
            }
        }
    }
    ```
    - 做完这些处理之后，等下一帧动画的到来，当doAnimationFrame被调用，此时若仍然处于暂停状态，就会做如下截击
        - 这样就阻止了动画的正常运行，并记录下来动画暂停的时间，确保恢复之后能让动画调整到暂停之前的动画点正常运行，具体怎么起作用就要看resume的作用。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-3bffba42cdadef07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- **先看看resume方法中的源码**
    - 先看在ValueAnimator中的resume方法，然后看Animator中的resume方法可知：
        - 置位：mResumed = true
        - 复位：mPaused = false
        - 调用AnimatorPauseListener.onAnimationResume
    ```
    //在ValueAnimator中
    @Override
    public void resume() {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be resumed from the same " +
                    "thread that the animator was started on");
        }
        if (mPaused && !mResumed) {
            mResumed = true;
            if (mPauseTime > 0) {
                addAnimationCallback(0);
            }
        }
        super.resume();
    }
    
    //在Animator中
    public void resume() {
        if (mPaused) {
            mPaused = false;
            if (mPauseListeners != null) {
                ArrayList<AnimatorPauseListener> tmpListeners =
                        (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onAnimationResume(this);
                }
            }
        }
    }
    ```
    - 当doAnimationFrame被调用，此时若处于恢复状态（mResume==true），就会做如下补偿处理
        - 这样就让暂停的时间从动画的运行过程中消除
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-1b43530b23fa712b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 3.7 属性动画与View结合
- 属性动画如何去实现View的变换？
    - 是根据计算出来的动画值去修改View的属性，如alpha、x、y、scaleX、scaleY、translationX、translationY等等，这样当View重绘时就会产生作用，随着View连续不断地被重绘，就会产生绚烂多彩的动画。
- 接着看setTarget这个方法源码
    - 如果是使用ValueAnimator类，那么直接通过mAnimator.setTarget(view)设置view
    - 如果是使用ObjectAnimator，那么直接通过ObjectAnimator.ofFloat(view, type, start, end)设置view，最终还是会调用setTarget方法。注意ObjectAnimator实现了ValueAnimator类
    - ObjectAnimator是可以在动画帧计算完成之后直接对Target属性进行修改的属性动画类型，相对于ValueAnimator来说更加省心省力
- 相比ValueAnimator类，ObjectAnimator还做了许多操作，ObjectAnimator与 ValueAnimator类的区别： 
    - ValueAnimator 类是先改变值，然后 手动赋值 给对象的属性从而实现动画；是 间接 对对象属性进行操作；
    - ObjectAnimator 类是先改变值，然后 自动赋值 给对象的属性从而实现动画；是 直接 对对象属性进行操作；
- 个人感觉属性动画源码分析十分具有跳跃性。不过还好没有关系，只需要理解其大概运作原理就可以呢。









