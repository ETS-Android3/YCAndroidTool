#### 目录介绍
- 1.0.0.1 说下Activity的生命周期？屏幕旋转时生命周期？异常条件会调用什么方法？什么时候会引起异常生命周期？
- 1.0.0.2 后台的Activity被系统回收怎么办？说一下onSaveInstanceState()和onRestoreInstanceState()方法特点？
- 1.0.0.3 如何避免配置改变时Activity重建？优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？
- 1.0.0.4 app切换到后台，当前activity会走onDestory方法吗？一般在onstop方法里做什么？什么情况会导致app会被杀死，这时候会走onDestory吗？
- 1.0.0.5 Activity的启动过程是有几种方式？从桌面launcher上点击应用图标会干啥，调用startActivty()又会做什么？
- 1.0.0.6 说下Activity的四种启动模式？singleTop和singleTask的区别以及应用场景？任务栈的作用是什么？
- 1.0.0.7 两个Activity之间怎么传递数据？intent和bundle有什么区别？为什么有了intent还要设计bundle？
- 1.0.0.9 Activity mActivity = new Activity() 可以直接这样吗？为什么？在Activity写main方法，会被执行吗？
- 1.0.1.4 是否能在Service进行耗时操作？如果非要可以怎么做，如何避免service线程卡顿？service里面可以弹土司吗？
- 1.0.1.5 介绍一下Service，启动Service有几种方式，生命周期是怎样的？说一下onStartCommand()的作用？service如何杀不死？
- 1.0.2.3 广播有几种形式？他们分别有什么特点，如何使用广播？广播发送和接收原理是什么？Android中哪些需要用到广播？
- 1.0.2.4 BroadcastReceiver能够做网络请求吗，为什么？如何正确处理广播中耗时操作，有何其他方案？
- 1.0.2.9 Activity创建Fragment的方式是什么？FragmentPageAdapter和FragmentPageStateAdapter的区别？
- 1.0.3.0 为什么fragment传递数据不用构造方法传递？FragmentManager中add 和replace有什么区别？getActivity()空指针？
- 1.0.3.9 Android Intent传递大量数据造成页面卡顿原因是什么，如何解决intent传递大数据崩溃？
- 1.0.4.0 Intent可以传递哪些数据？传递对象为何要实例化？Intent最大传递多大数据？Bundle存储数据是值传递(深拷贝)还是引用传递？
- 1.0.4.3 Context是什么？Context有哪些类型，分别作用是什么？Context下有哪些子类？哪些场景只能用activity上下文？
- 1.0.6.0 Android中日志级别有哪几种？开发中需要注意什么问题，打印日志源码分析原理是什么？




### 1.0.0.1 说下Activity的生命周期？屏幕旋转时生命周期？异常条件会调用什么方法？什么时候会引起异常生命周期？
- 在Activity的生命周期涉及到七大方法，分别是：
    - onCreate()表示Activity 正在创建，常做初始化工作，如setContentView界面资源、初始化数据
    - onStart()表示Activity 正在启动，这时Activity 可见但不在前台，无法和用户交互
    - onResume()表示Activity 获得焦点，此时Activity 可见且在前台并开始活动
    - onPause()表示Activity 正在停止，可做 数据存储、停止动画等操作
    - onStop()表示activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等
    - onDestroy()表示Activity 即将销毁，常做回收工作、资源释放
    - onRestart()表示当Activity由后台切换到前台，由不可见到可见时会调用，表示Activity 重新启动
- 屏幕旋转时生命周期
    - 屏幕旋转时候，如果不做任何处理，activity会经过销毁到重建的过程。一般这种效果都不是想要的。比如视频播放器就经常会涉及屏幕旋转场景。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 第一种情况：当前的Activity不销毁【设置Activity的android:configChanges="orientation|keyboardHidden|screenSize"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法】
        ```
        <activity
            android:name=".activity.VideoDetailActivity"
            android:configChanges="orientation|keyboardHidden|screenSize"
            android:screenOrientation="portrait"/>
        ```
        - 执行该方法
        ```
        //重写旋转时方法，不销毁activity
        @Override
        public void onConfigurationChanged(Configuration newConfig) {
        	super.onConfigurationChanged(newConfig);
        }
        ```
    - 第二种情况：销毁当前的Activity后重建，这种也尽量避免。【不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，默认首先销毁当前activity,然后重新加载】
- 异常条件会调用什么方法
    - 当非人为终止Activity时，比如系统配置发生改变时导致Activity被杀死并重新创建、资源内存不足导致低优先级的Activity被杀死，会调用 onSavaInstanceState() 来保存状态。该方法调用在onStop之前，但和onPause没有时序关系。
    - 有人会问，onSaveInstanceState()与onPause()的区别，onSaveInstanceState()适用于对临时性状态的保存，而onPause()适用于对数据的持久化保存。
    - 当异常崩溃后App又重启了，这个时候会走onRestoreInstanceState()方法，可以在该方法中取出onSaveInstanceState()保存的状态数据。
- 什么时候会引起异常生命周期
    - 资源相关的系统配置发生改变或者资源不足：例如屏幕旋转，当前Activity会销毁，并且在onStop之前回调onSaveInstanceState保存数据，在重新创建Activity的时候在onStart之后回调onRestoreInstanceState。其中Bundle数据会传到onCreate（不一定有数据）和onRestoreInstanceState（一定有数据）。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 防止屏幕旋转的时候重建，在清单文件中添加配置：android:configChanges="orientation"



### 1.0.0.2 后台的Activity被系统回收怎么办？说一下onSaveInstanceState()和onRestoreInstanceState()方法特点？
- 后台的Activity被系统回收怎么办？
    - Activity中提供了一个 onSaveInstanceState()回调方法，这个方法会保证一定在活动被回收之前调用，可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle中取值，第二个参数是真正要保存的内容。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
- 说一下onSaveInstanceState()和onRestoreInstanceState()方法特点？
    - Activity的 onSaveInstanceState()和onRestoreInstanceState()并不是生命周期方法，它们不同于onCreate()、onPause()等生命周期方法，它们并不一定会被触发。
        ```
        //保存数据
        @Override
        protected void onSaveInstanceState(Bundle outBundle) {
        	super.onSaveInstanceState(outBundle);
         	outBundle.putBoolean("Change", mChange);
        }
        
        //取出数据
        @Override 
        protected void onRestoreInstanceState(Bundle savedInstanceState) {
        	super.onRestoreInstanceState(savedInstanceState);
        	mChange = savedInstanceState.getBoolean("Change");
        }
        
        //或者在onCreate方法取数据也可以
        //onCreate()方法其实也有一个Bundle类型的参数。这个参数在一般情况下都是null，
        //但是当活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参就会带有之前所保存的全部数据
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            if (savedInstanceState != null) {
                String data = savedInstanceState.getString("data");
            }
        }
        ```
- 什么时候会触发走这两个方法？
    - 当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。
- onSaveInstanceState()被执行的场景有哪些？
    - 系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activityA是否会被销毁，因此系统都会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则当用户按下HOME键时
        - 长按HOME键，选择运行其他的程序时
        - 锁屏时
        - 从activity A中启动一个新的activity时
        - 屏幕方向切换时




### 1.0.0.3 如何避免配置改变时Activity重建？优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？
- 如何避免配置改变时Activity重建
    - 为了避免由于配置改变导致Activity重建，可在AndroidManifest.xml中对应的Activity中设置android:configChanges="orientation|screenSize"。此时再次旋转屏幕时，该Activity不会被系统杀死和重建，只会调用onConfigurationChanged。因此，当配置程序需要响应配置改变，指定configChanges属性，重写onConfigurationChanged方法即可。
    - 使用场景，比如视频播放器横竖屏切换播放视频，就需要设置这种属性。具体可以看我封装的视频播放器库，地址：https://github.com/yangchong211/YCVideoPlayer
- 优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态
    - 优先级低的Activity在内存不足被回收后重新打开会引发Activity重建。Activity被重新创建时会调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。因此可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。
- 如何判断activity的优先级？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 除了在栈顶的activity,其他的activity都有可能在内存不足的时候被系统回收，一个activity越处于栈底，被回收的可能性越大.如果有多个后台进程，在选择杀死的目标时，采用最近最少使用算法（LRU）。





### 1.0.0.4 app切换到后台，当前activity会走onDestory方法吗？一般在onstop方法里做什么？什么情况会导致app会被杀死，这时候会走onDestory吗？
- app切换到后台，当前activity会走onDestory方法吗？
    - 不会走onDestory方法，会先后走onPause和onStop方法。
- 一般在onstop方法里做什么？
    - 比如。写轮播图的时候，会在onstop方法里写上暂停轮播图无限轮播，在onStart方法中会开启自动无限轮播。
    - 再比如，写视频播放器的时候，当app切换到后台，则需要停止视频播放，也是可以在onstop中处理的。关于视频播放器，可以看我这个开源项目：[视频播放器](https://github.com/yangchong211/YCVideoPlayer)
- 什么情况会导致app会被杀死，这时候会走onDestory吗？
    - 系统资源不足，会导致app意外被杀死。应用只有在进程存活的情况下才会按照正常的生命周期进行执行，如果进程突然被kill掉，相当于System.exit(0); 进程被杀死，根本不会走（activity，fragment）生命周期。只有在进程不被kill掉，正常情况下才会执行ondestory（）方法。
- activity被回收如何恢复
    - 当系统内存不足时, activity会被回收，我们其实可以覆写onSaveInstanceState()方法。onSaveInstanceState()方法接受一个Bundle类型的参数, 开发者可以将状态数据存储到这个Bundle对象中,这样即使activity被系统摧毁,当用户重新启动这个activity而调用它的onCreate()方法时,上述的Bundle对象会作为实参传递给onCreate()方法,开发者可以从Bundle对象中取出保存的数据, 然后利用这些数据将activity恢复到被摧毁之前的状态。




### 1.0.0.5 Activity的启动过程是有几种方式？从桌面launcher上点击应用图标会干啥，调用startActivty()又会做什么？
- Activity的启动过程是怎样的，有几种方式？
    - 注意是启动过程，不是生命周期。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。
- 从桌面launcher上点击应用图标会干啥，调用startActivty()又会做什么？
    - 创建一个新的项目，默认的根activity都是MainActivity，而所有的activity都是保存在堆栈中的，启动一个新的activity就会放在上一个activity上面，而我们从桌面点击应用图标的时候，由于launcher本身也是一个应用，当我们点击图标的时候，系统就会调用startActivitySately(),一般情况下，我们所启动的activity的相关信息都会保存在intent中，比如action，category等等。
    - 我们在安装这个应用的时候，系统也会启动一个PackaManagerService的管理服务，这个管理服务会对AndroidManifest.xml文件进行解析，从而得到应用程序中的相关信息，比如service，activity，Broadcast等等，然后获得相关组件的信息。
    - 当我们点击应用图标的时候，就会调用startActivitySately()方法，而这个方法内部则是调用startActivty(),而startActivity()方法最终还是会调用startActivityForResult()这个方法。而在startActivityForResult()这个方法。因为startActivityForResult()方法是有返回结果的，所以系统就直接给一个-1，就表示不需要结果返回了。
    - 而startActivityForResult()这个方法实际是通过Instrumentation类中的execStartActivity()方法来启动activity，Instrumentation这个类主要作用就是监控程序和系统之间的交互。而在这个execStartActivity()方法中会获取ActivityManagerService的代理对象，通过这个代理对象进行启动activity。启动会就会调用一个checkStartActivityResult()方法，如果说没有在配置清单中配置有这个组件，就会在这个方法中抛出异常了。
    - 当然最后是调用的是Application.scheduleLaunchActivity()进行启动activity，而这个方法中通过获取得到一个ActivityClientRecord对象，而这个ActivityClientRecord通过handler来进行消息的发送，系统内部会将每一个activity组件使用ActivityClientRecord对象来进行描述，而ActivityClientRecord对象中保存有一个LoaderApk对象，通过这个对象调用handleLaunchActivity来启动activity组件，而页面的生命周期方法也就是在这个方法中进行调用。




### 1.0.0.6 说下Activity的四种启动模式？singleTop和singleTask的区别以及应用场景？任务栈的作用是什么？
- Activity的四种启动模式
    - standard标准模式：每次启动一个Activity就会创建一个新的实例
    - singleTop栈顶复用模式：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调 onNewIntent(intent) 方法
    - singleTask栈内复用模式：只要该Activity在一个任务栈中存在，都不会重新创建，并回调 onNewIntent(intent) 方法。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中
    - singleInstance单实例模式：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一一个实例
- singleTop和singleTask的区别以及应用场景
    - singleTop：同个Activity实例在栈中可以有多个，即可能重复创建；该模式的Activity会默认进入启动它所属的任务栈，即不会引起任务栈的变更；为防止快速点击时多次startActivity，可以将目标Activity设置为singleTop
    - singleTask：同个Activity实例在栈中只有一个，即不存在重复创建；可通过android：taskAffinity设定该Activity需要的任务栈，即可能会引起任务栈的变更；常用于主页和登陆页
- singleTop或singleTask的Activity在以下情况会回调onNewIntent()
    - singleTop：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调 onNewIntent(intent) 方法
    - singleTask：只要该Activity在一个任务栈中存在，都不会重新创建，并回调 onNewIntent(intent) 方法
- 任务栈的作用是什么？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 它是存放 Activity 的引用的，Activity不同的启动模式，对应不同的任务栈的存放；可通过 getTaskId()来获取任务栈的 ID，如果前面的任务栈已经清空，新开的任务栈ID+1，是自动增长的；首先来看下Task的定义，Google是这样定义Task的：Task实际上是一个Activity栈，通常用户感受的一个Application就是一个Task。从这个定义来看，Task跟Service或者其他Components是没有任何联系的，它只是针对Activity而言的。
- 同一程序不同的Activity是否可以放在不同的Task任务栈中？
    - 可以的。比如：启动模式里有个Singleinstance，可以运行在另外的单独的任务栈里面。用这个模式启动的activity，在内存中只有一份，这样就不会重复的开启。
    - 也可以在激活一个新的activity时候,给intent设置flag，Intent的flag添加FLAG_ACTIVITY_NEW_TASK，这个被激活的activity就会在新的task栈里面




### 1.0.0.7 两个Activity之间怎么传递数据？intent和bundle有什么区别？为什么有了intent还要设计bundle？
- 两个Activity之间怎么传递数据？
    - 基本数据类型可以通过Intent传递数据  
    - 把数据封装至intent对象中
        ```
        Intent intent = new Intent(content, MeActivity.class);
        intent.putExtra("goods_id", goods_id);
        content.startActivity(intent);
        ```
    - 把数据封装至bundle对象中[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 把bundle对象封装至intent对象中
        ```
        Bundle bundle = new Bundle();
        bundle.putString("malename", "李志");
        intent.putExtras(bundle);
        startActivity(intent); 
        ```
- intent和bundle有什么区别？
    - Intent传递数据和Bundle传递数据是一回事，Intent传递时内部还是调用了Bundle。
        ```
        public @NonNull Intent putExtra(String name, String value) {
            if (mExtras == null) {
                mExtras = new Bundle();
            }
            mExtras.putString(name, value);
            return this;
        }
        ```
- 为什么有了intent还要设计bundle？
    - 两者比较
        - Bundle只是一个信息的载体，内部其实就是维护了一个Map<String,Object>。
        - Intent负责Activity之间的交互，内部是持有一个Bundle的。
    - bundle使用场景
        - Fragment之间传递数据；比如，某个Fragment中点击按钮弹出一个DialogFragment。最便捷的方式就是通过Fragment.setArguments(args)传递参数。
        ```
        public static void showFragmentDialog(String title, String content, boolean is_open, AppCompatActivity activity) {
            ServiceDialogFragment mainDialogFragment = new ServiceDialogFragment();
            Bundle bundle = new Bundle();
            bundle.putString("title", title);
            bundle.putString("content", content);
            bundle.putBoolean("is_open",is_open);
            mainDialogFragment.setArguments(bundle);
            mainDialogFragment.show(activity.getSupportFragmentManager());
        }
        
        @Override
        public void onCreate(Bundle savedInstanceState) {
            setLocal(Local.CENTER);
            super.onCreate(savedInstanceState);
            Bundle bundle = getArguments();
            if (bundle != null) {
                title = bundle.getString("title");
                content = bundle.getString("content");
                is_open = bundle.getBoolean("is_open");
            }
        }
        ```





### 1.0.0.9 Activity mActivity = new Activity() 可以直接这样吗？为什么？在Activity写main方法，会被执行吗？
- **Activity mActivity =new Activity()可以直接这样吗**
    - 作为Android开发者，不知道你有没有思考过这个问题，Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，那上面的写法有什么问题呢？
    - 估计很多人说不清道不明。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行。
    - **Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境**，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例了，而是要有它们各自的上下文环境，也就是Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。
- **在Activity写main方法，会被执行吗？**
    - 不会被执行。注意，四大组件的启动需要依赖context。



### 1.0.1.4 是否能在Service进行耗时操作？如果非要可以怎么做，如何避免service线程卡顿？service里面可以弹土司吗？
- 是否能在Service进行耗时操作？
    - 默认情况,如果没有显示的指定service所运行的进程,Service和Activity是运行在当前app所在进程的mainThread(UI主线程)里面。
    - service里面不能执行耗时的操作(网络请求,拷贝数据库,大文件)，在Service里执行耗时操作，有可能出现主线程被阻塞（ANR）的情况。
- 如果非要可以怎么做，如何避免service线程卡顿？
    - 需要在子线程中执行 new Thread(){}.start();
- service里面可以弹土司吗？
    - 可以，但是有条件。一般很少这样做……[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 条件是，service里面弹toast需要添加到主线程里执行。
        ```
        @Override  
        public void onCreate(){  
            handler = new Handler(Looper.getMainLooper());                          
            System.out.println("service started");  
            handler.post(new Runnable() {    
                @Override    
                public void run() {    
                    Toast.makeText(getApplicationContext(), "Test",Toast.LENGTH_SHORT).show();
                }
            });
        }
        ```




### 1.0.1.5 介绍一下Service，启动Service有几种方式，生命周期是怎样的？说一下onStartCommand()的作用？service如何杀不死？
- Service分为两种
    - 本地服务，属于同一个应用程序，通过startService来启动或者通过bindService来绑定并且获取代理对象。如果只是想开个服务在后台运行的话，直接startService即可，如果需要相互之间进行传值或者操作的话，就应该通过bindService。
    - 远程服务（不同应用程序之间），通过bindService来绑定并且获取代理对象。
- 对应的生命周期如下：
    - context.startService() ->onCreate()- >onStartCommand()->Service running--调用context.stopService() ->onDestroy()
    - context.bindService()->onCreate()->onBind()->Service running--调用>onUnbind() -> onDestroy()
- 注意
    - Service默认是运行在main线程的，因此Service中如果需要执行耗时操作（大文件的操作，数据库的拷贝，网络请求，文件下载等）的话应该在子线程中完成。
- Service生命周期解释[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - onCreate（）：服务第一次被创建时调用
    - onStartComand（）：服务启动时调用
    - onBind（）：服务被绑定时调用
    - onUnBind（）：服务被解绑时调用
    - onDestroy（）：服务停止时调用
- 说一下onStartCommand()的作用？
- service如何杀不死？
    - 1.onStartCommand方法，返回START_STICKY（粘性）当service因内存不足被kill，当内存又有的时候，service又被重新创建
    - 2.设置优先级，在服务里的ondestory里发送广播 在广播里再次开启这个服务,双进程守护



### 1.0.2.3 广播有几种形式？他们分别有什么特点，如何使用广播？广播发送和接收原理是什么？Android中哪些需要用到广播？
- 广播有几种形式
    - 普通广播：一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们接收的先后是随机的。
    - 有序广播：一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递，所以此时的广播接收器是有先后顺序的，且优先级（priority）高的广播接收器会先收到广播消息。有序广播可以被接收器截断使得后面的接收器无法收到它。
    - 本地广播：发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收本应用程序发出的广播。
    - 粘性广播：这种广播会一直滞留，当有匹配该广播的接收器被注册后，该接收器就会收到此条广播。
- 广播的两种注册形式[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 广播的注册有两种方法：一种在活动里通过代码动态注册，另一种在配置文件里静态注册。两种方式的相同点是都完成了对接收器以及它能接收的广播值这两个值的定义；不同点是动态注册的接收器必须要在程序启动之后才能接收到广播，而静态注册的接收器即便程序未启动也能接收到广播，比如想接收到手机开机完成后系统发出的广播就只能用静态注册了。
- 动态注册
    - 需要使用广播接收者时，执行注册的代码，不需要时，执行解除注册的代码。安卓中有一些广播接收者，必须使用代码注册，清单文件注册是无效的。
- 静态注册
    - 可以使用清单文件注册。广播一旦发出，系统就会去所有清单文件中寻找，哪个广播接收者的action和广播的action是匹配的，如果找到了，就把该广播接收者的进程启动起来。
- 广播发送和接收原理是什么[binder如何运作的]？
    - 继承BroadcastReceiver，重写onReceive()方法。
    - 通过Binder机制向ActivityManagerService注册广播。
    - 通过Binder机制向ActivityMangerService发送广播。
    - ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。
    - BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。
- Android中哪些需要用到广播？
    - Android中：系统在运行过程中，会产生会多事件，那么某些事件产生时，比如：电量改变、收发短信、拨打电话、屏幕解锁、开机，系统会发送广播，只要应用程序接收到这条广播，就知道系统发生了相应的事件，从而执行相应的代码。使用广播接收者，就可以收听广播
- 广播的生命周期是怎样的？
    - a.广播接收者的生命周期非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁；
    - b.广播接收者中不要做一些耗时的工作，否则会弹出 Application No Response错误对话框；
    - c.最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉；
    - d.耗时的较长的工作最好放在服务中完成；
- 接入极光推送广播原理分析
    - 思考一下，配置自定义极光推送的广播，然后在清单文件中注册，添加一些action和Category，那么广播是怎么注册和接受消息呢？
    - 首先将要发送的消息和用于过滤的信息（Action，Category）装入一个 Intent对象，然后通过调用Context.sendBroadcast()、sendOrderBroadcast() 方法把 Intent 对象以广播形式发送出去。 广播发送出去后，所以已注册的 BroadcastReceiver 会检查注册时的 IntentFilter 是否与发送的 Intent 相匹配，若匹配则会调用 BroadcastReceiver 的 onReceiver() 方法



### 1.0.2.4 BroadcastReceiver能够做网络请求吗，为什么？如何正确处理广播中耗时操作，有何其他方案？
- BroadcastReceiver能够做网络请求吗
    - 不建议做耗时操作。如果要在BroadcastReceiver中执行耗时操作，通过创建子线程的方式是不可靠的，因为BroadcastReceiver的生命周期很短，一旦结束，其所在进程属于空进程（没有任何活动组件的进程），极易在系统内存不足时优先被杀死，如此，正在工作的子线程也会被杀死。
- 如何正确地在BroadcastReceiver中执行耗时操作：
    - 在 BroadcastReceiver 中执行耗时操作，可开启一个 Service 将耗时操作交给 Service ，这样可以提高宿主进程优先级，保证耗时操作执行完成。
- 如何正确操作
    - 在Android 开发中，一般耗时操作都会尽可能交给 Service 做，如上传图片，因为上传的过程可能应用被置于后台，Activity就会存在被系统回收的可能，如果担心 Service 被回收，还可通过startForeground(int, Notification)提升其优先级。
    - 我们知道，Service是工作在主线程的，所以不能直接在里面执行耗时操作，一般需要开启子线程去做，而IntentService是Service的子类，正是可以用来处理异步请求的，同Service有两个好处：一是其内部开启了一个异步处理工作线程HandlerThread，不用我们自己去 new Thread了；二是不需要考虑什么时候关闭该 Service，当完成所有的任务后会自动关闭。
- 如何回传数据到广播呢？
    - 比如，在IntentService做完了耗时操作，这个时候如何把结果返回给广播了，很简单，直接把发送广播即可，注意携带的数据需要序列化一下。




### 1.0.2.9 Activity创建Fragment的方式是什么？FragmentPageAdapter和FragmentPageStateAdapter的区别？
- Activity创建Fragment的方式是什么？
    - 静态创建具体步骤
        - 首先我们同样需要注册一个xml文件，然后创建与之对应的java文件，通过onCreatView（）的返回方法进行关联，最后我们需要在Activity中进行配置相关参数即在Activity的xml文件中放上fragment的位置。
    - 动态创建具体步骤
        - (1)创建待添加的碎片实例
        - (2)获取FragmentManager，在活动中可以直接通过调用 getSupportFragmentManager（）方法得到。
        - (3)开启一个事务，通过调用beginTransaction()方法开启。
        - (4)向容器内添加或替换碎片，一般使用repalce()方法实现，需要传入容器的id和待添加的碎片实例。
        - (5)提交事务，调用commit()方法来完成。
- Fragment与Activity之间是如何传值的？
    - 1.Activity向Fragment传值：
        - 要传的值，放到bundle对象里；
        - 在Activity中创建该Fragment的对象fragment，通过调用
        - fragment.setArguments()传递到fragment中；
        - 在该Fragment中通过调用getArguments()得到bundle对象，就能得到里面的值。
    - 2.Fragment向Activity传值：
        - 第一种：
            - 在Activity中调用getFragmentManager()得到fragmentManager,，调用findFragmentByTag(tag)或者通过findFragmentById(id)
            - FragmentManager fragmentManager = getFragmentManager()；
            - Fragment fragment = fragmentManager.findFragmentByTag(tag)；
        - 第二种：
            - 通过回调的方式，定义一个接口（可以在Fragment类中定义），接口中有一个空的方法，在fragment中需要的时候调用接口的方法，值可以作为参数放在这个方法中，然后让Activity实现这个接口，必然会重写这个方法，这样值就传到了Activity中
- FragmentPageAdapter和FragmentPageStateAdapter的区别？
    - FragmentPageAdapter在每次切换页面时，只是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。
    - FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存。





### 1.0.3.0 为什么fragment传递数据不用构造方法传递？FragmentManager中add 和replace有什么区别？getActivity()空指针？
- 为什么fragment传递数据不用构造方法传递？
    - activity给fragment传递数据一般不通过fragment的构造方法来传递，会通过setArguments来传递，因为当横竖屏会调用fragment的空参构造函数，数据丢失。
- FragmentManager , add 和 replace 有什么区别?
    - 使用FragmentTransaction的时候，它提供了这样两个方法，一个add，一个replace，add和replace影响的只是界面，而控制回退的，是事务。
    - add 是把一个fragment添加到一个容器container里。replace是先remove掉相同id的所有fragment，然后在add当前的这个fragment。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 在大部分情况下，这两个的表现基本相同。因为，一般，咱们会使用一个FrameLayout来当容器，而每个Fragment被add 或者 replace 到这个FrameLayout的时候，都是显示在最上层的。所以你看到的界面都是一样的。但是，使用add的情况下，这个FrameLayout其实有2层，多层肯定要比一层的来得浪费，所以还是推荐使用replace。当然有时候还是需要使用add的。比如要实现轮播图的效果，每个轮播图都是一个独立的Fragment，而他的容器FrameLayout需要add多个Fragment，这样他就可以根据提供的逻辑进行轮播了。而至于返回键的时候，这个跟事务有关，跟使用add还是replace没有任何关系。
    - replace()方法会将被替换掉的那个Fragment彻底地移除掉，因此最好的解决方案就是使用hide()和show()方法来隐藏和显示Fragment，这就不会让Fragment的生命周期重走一遍了。
- getActivity()为何会空指针
    - 这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式显得更妥当一些。
- 如何解决getActivity为null的异常问题[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    ```
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        activity = (PhoneNumActivity) context;
    }
    
    @Override
    public void onDetach() {
        super.onDetach();
        activity = null;
    }
    ```




### 1.0.3.9 Android Intent传递大量数据造成页面卡顿原因是什么，如何解决intent传递大数据崩溃？
- **遇到的问题分析**
    - 在Activity间使用Intent传递List含有大量序列化的对象的时候，或者传递较大bitmap等较大量数据的时候会引起页面卡顿。而且Android本身也限制了能够传递的数据大小在1MB左右。这就要求我们不得不为传输大量数据寻求一个解决方法。
- **如何解决intent传递大数据崩溃**
    - 创建对象的缓存区，可以使用单例模式，代码如下所示
        ```java
        public class ModelStorage {
        
            private List<PseriesModelPicListBean> picListBeans = new ArrayList<>();
        
            public static ModelStorage getInstance(){
                return SingletonHolder.instance;
            }
        
            private static class SingletonHolder{
                private static final ModelStorage instance = new ModelStorage();
            }
        
            public void clearPicListBeans(){
                picListBeans.clear();
            }
        
            public List<PseriesModelPicListBean> getPicListBeans() {
                return picListBeans;
            }
        
            public void setPicListBeans(List<PseriesModelPicListBean> picListBeans) {
                this.picListBeans.clear();
                this.picListBeans.addAll(picListBeans);
            }
        }
        ```
    - 创建需要序列化传递对象的基类，可以看到在Model中序列化了一个int值。将想要序列化的类继承Model，注意该类中的字段不需要序列化存储。最后存取的方式如常规使用
        ```
        intent.putExtra("key",new User("yc",26));
        User user = getIntent().getParcelableExtra("key");
        ```
        - 通过以上方式的封装，可以看到无论需要序列化传递的对象有多大，在传值的时候只是传递了一个“int”而已。使用该这种方法时需要注意的一点是在数据的接收页面只能使用getIntent()获取一次该对象的值，因为我们在取完一次值后便将该对象从缓存区移除了。



### 1.0.4.0 Intent可以传递哪些数据？传递对象为何要实例化？Intent最大传递多大数据？Bundle存储数据是值传递(深拷贝)还是引用传递？
- **Intent是一种运行时绑定（run-time binding）机制，它能在程序运行过程中连接两个不同的组件。**
    - 举例：比如，有一个Activity希望打开网页浏览器查看某一网页的内容，那么这个Activity只需要发出 WEB_SEARCH_ACTION给Android
    - Android就会根据Intent的请求内容，查询各组件注册时声明的 IntentFilter，找到网页浏览器的Activity来浏览网页
- **Intent可以传递的数据基本数据类型的数据，数组，还有集合，还有序列化的对象**
    - 序列化：表示将一个对象转换成可存储或可传输的状态
    - Android中序列化对象方式：[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - 第一种：JAVA中的Serialize机制，译成串行化、序列化……，其作用是能将数据对象存入字节流当中，在需要时重新生成对象。主要应用是利用外部存储设备保存对象状态，以及通过网络传输对象等。
        - 第二种：在Android系统中，定位为针对内存受限的设备，因此对性能要求更高，另外系统中采用了新的IPC（进程间通信）机制，必然要求使用性能更出色的对象传输方式。
- **Intent最大传递多大数据**
    - Intent 对数据大小是有限制的，当超过这个限制后，就会触发 TransactionTooLargeException 异常。可以直接写测试代码，传递一个1M的字节byte数组对象，测试发现直接抛出异常。
    - Intent 无法传递大数据是因为其内部使用了 Binder 通信机制，Binder 事务缓冲区限制了传递数据的大小。Binder 事务缓冲区的大小限定在 1MB，但是这个尺寸是共享的，也就是并不是传递 1MB 以下的数据就绝对安全，要视当前的环境而定。
- **为何说Intent不要传递大数据**
    - Intent 传输数据的机制中，用到了 Binder。Intent 中的数据，会作为 Parcel 被存储在 Binder 的事务缓冲区(Binder transaction buffer)中的对象进行传输。
    - 这个 Binder 事务缓冲区具有一个有限的固定大小，当前为 1MB。你可别以为传递 1MB 以下的数据就安全了，这里的 1MB 空间并不是当前操作独享的，而是由当前进程所共享。也就是说 Intent 在 Activity 间传输数据，本身也不适合传递太大的数据。
- **如何解决Intent传递大数据**
    - 可以通过创建对象的缓存区来解决该问题，可以使用单例模式，然后set和get需要传递的大数据。只是需要注意，在不需要用的时候，需要单利中数据对象置null操作。
- **Bundle存储数据是值传递(深拷贝)还是引用传递**
    - 首先说，是值传递。Activity 之间传递数据，首先要考虑跨进程的问题，而 Android 中又是通过 Binder 机制来解决跨进程通信的问题。涉及到跨进程，对于复杂数据就要涉及到序列化和反序列化的过程，这就注定是一次值传递（深拷贝）的过程。
    - 这个问题用反证法也可以解释，如果是引用传递，那传递过去的只是对象的引用，指向了对象的存储地址，就只相当于一个 Int 的大小，也就根本不会出现 TransactionTooLargeException 异常。
- **工作中使用过Intent传递bitmap图片吗**
    - Bitmap，本身就已经实现了 Parcelable 是可以支持序列化的。用 Intent 传输，稍微大一点的图一定会出现 TransactionTooLargeException。当然真是业务场景，肯定不存在传递 Bitmap 的情况。大数据总有数据源，从数据源还原数据，对我们而言只是调用一个方法而已。也可以用对象缓存区方法解决该问题。



### 1.0.4.3 Context是什么？Context有哪些类型，分别作用是什么？Context下有哪些子类？哪些场景只能用activity上下文？
- **Context是什么？**
    - Context是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。
- **Context有哪些类型，分别作用是什么？**
    - Context下有两个子类，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。
    - ContextWrapper又有三个直接的子类，ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。
- **Context下有哪些子类，主要是干什么的？**
    - Context一共有三种类型，分别是Application、Activity和Service。
    - 这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。
- **开启一个Dialog为何只能用Activity上下文？**
    - 不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是系统级别吐司），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。
- **可以用Application和Service上下文去打开activity或者inflate布局吗**
    - 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错`android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?`
        - 这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。
    - 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。
- **getApplication()和getApplicationContext()**
    - 上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。
    - 程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。
    - 那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。
    - getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，**但是这个方法只有在Activity和Service中才能调用的到**。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。


#### 1.0.6.0 Android中日志级别有哪几种？开发中需要注意什么问题，打印日志源码分析原理是什么？
- Android中日志级别有哪几种？
    - 1.Log.v 的输出颜色为黑色的，输出大于或等于VERBOSE日志级别的信息，也就是可见级别，一般是最低的信息提示
    - 2.Log.d的输出颜色是蓝色的，也就是调式级别，一般不会中止程序，一般是程序员为了调试而打印的log
    - 3.Log.i的输出为绿色，输出大于或等于INFO日志级别的信息，也就是信息界级别，不会中止程序，一般是系统中执行操作的信息提示
    - 4.Log.w的输出为橙色, 输出大于或等于WARN日志级别的信息，也就是警告级别，一般不会中止程序，但是可能会影响程序执行结果
    - 5.Log.e的输出为红色，仅输出ERROR日志级别的信息，也就是错误级别，一般会中止程序运行，是最严重的Log级别。
    - 解释：
        - verbose    
        - debug调试    
        - info信息     
        - warn警告     
        - error误差
- 通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志。









