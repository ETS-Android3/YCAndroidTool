#### 目录介绍
- 01.getActivity()空指针
- 02.Fragment发生重叠
- 03.Fragment高耦合性
- 04.处理返回键逻辑
- 05.commitAllowingStateLoss
- 06.Fragment叠加点击穿透
- 07.Fragment出现白屏
- 10.Fragment使用建议





### 好消息
- 博客笔记大汇总【16年3月到至今】，包括Java基础及深入知识点，Android技术博客，Python学习笔记等等，还包括平时开发中遇到的bug汇总，当然也在工作之余收集了大量的面试题，长期更新维护并且修正，持续完善……开源的文件是markdown格式的！同时也开源了生活博客，从12年起，积累共计N篇[近100万字，陆续搬到网上]，转载请注明出处，谢谢！
- **链接地址：https://github.com/yangchong211/YCBlogs**
- 如果觉得好，可以star一下，谢谢！当然也欢迎提出建议，万事起于忽微，量变引起质变！






### 01.getActivity()空指针
- 遇到的问题
    - 可能你遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。
- 出现的原因分析
    - 大多数情况下的原因：你在调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。
    - 比如：你在出栈了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。
- 解决的方法介绍
    - 在Fragment基类里设置一个Activity mActivity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使在onDetach后，仍持有Activity的引用（有引起内存泄露的风险，但是异步任务没停止的情况下，本身就可能已内存泄漏，相比Crash，这种做法“安全”些），即：
    ```
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        activity = (MainActivity) context;
    }
    
    @Override
    public void onDetach() {
        super.onDetach();
        activity = null;
    }
    ```





### 02.Fragment发生重叠
- **发生重叠的原因**
    - 发生了页面重启（旋转屏幕、内存不足等情况被强杀重启）。
        - 由于采用创建对象的方式去初始化Fragment对象，当宿主Activity在界面销毁或者界面重新执行onCreate()方法时,就有可能再一次的执行Fragment的创建初始，而之前已经存在的 Fragment 实例也会销毁再次创建，这不就与 Activity 中 onCreate() 方法里面第二次创建的 Fragment 同时显示从而发生 UI 重叠的问题。
        - 如果宿主界面Acitivity可以横竖屏切换，导致的生命周期重新刷新也同理可导致界面的重叠问题。
    - 重复replace｜add Fragment 或者 使用show , hide控制Fragment；
- **通过源码分析重叠原因**
    - Activity中有个onSaveInstanceState()方法，该方法会在Activity将要被kill的时候回调（例如进入后台、屏幕旋转前、跳转下一个Activity等情况下会被调用）。
    - 当Activity只执行onPause方法时（透明Activity），这时候如果App设置的targetVersion大于11则不会执行onSaveInstanceState方法。
    - 此时系统帮我们保存一个Bundle类型的数据，我们可以根据自己的需求，手动保存一些例如播放进度等数据，而后如果发生了页面重启，我们可以在onRestoreInstanceState()或onCreate()里get该数据，从而恢复播放进度等状态。
    - **产生Fragment重叠的原因就与这个保存状态的机制有关，大致原因就是系统在页面重启前，帮我们保存了Fragment的状态，但是在重启后恢复时，视图的可见状态没帮我们保存，而Fragment默认的是show状态，所以产生了Fragment重叠现象。**
- **如何模拟调试**
    - 当你不确定你的app是否存在该问题时，先检查fragment是否有背景，如果有，先删掉
    - 手机的 “设置” - “开发者选项” - 打开”不保留活动”(主要用于模拟Activity被及时回收)
    - 把 app 切换到后台，再重新打开，通过点按不同的 tab 来切换 Fragment，打开其他页面在回来，在切换tab
    - 如果有重影，请接着看下面的解决方案



#### 2.1 findFragmentByTag
- 即在add()或者replace()时绑定一个tag，一般我们是用fragment的类名作为tag，然后在发生“内存重启”时，通过findFragmentByTag找到对应的Fragment，并hide()需要隐藏的fragment。
- 解决办法：推荐利用savedInstanceState判断
    ```
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity);
    
        TargetFragment targetFragment;
        HideFragment hideFragment;
      
        if (savedInstanceState != null) {  // “内存重启”时调用
            targetFragment = getSupportFragmentManager().findFragmentByTag(TargetFragment.class.getName);
            hideFragment = getSupportFragmentManager().findFragmentByTag(HideFragment.class.getName);
            // 解决重叠问题
            getFragmentManager().beginTransaction()
                    .show(targetFragment)
                    .hide(hideFragment)
                    .commit();
        }else{  // 正常时
            targetFragment = TargetFragment.newInstance();
            hideFragment = HideFragment.newInstance();
    
            getFragmentManager().beginTransaction()
                    .add(R.id.container, targetFragment, targetFragment.getClass().getName())
                    .add(R.id,container,hideFragment,hideFragment.getClass().getName())
                    .hide(hideFragment)
                    .commit();
        }
    }
    ```
- 这种方式存在很大的弊端
    - 使用比较麻烦，代码量较多；
    - 在Fragment嵌套的场景下，恢复会有问题，原因在于：页面重启后，在父Fragment没有初始化完成前，getChildFragmentManager()子栈内的子Fragment是空，只有父Fragment初始化完成后，子栈内的子Fragment才能正确获取到。


#### 2.2 自己保存Fragment的Hidden状态
- 知道了发生Fragment重叠的根本原因在于FragmentState没有保存Fragment的显示状态，即mHidden，导致页面重启后，该值为默认的false，即show状态，所以导致了Fragment的重叠。
- 根据这个原因，我想到我们手动维护一个mSupportHidden不就行了吗？
    ```
    /**
     * https://github.com/yangchong211
     * 异常崩溃后会再次走onCreate方法，这也就是为啥有时候fragment重叠，因为被创建多次
     * 发生Fragment重叠的根本原因在于FragmentState没有保存Fragment的显示状态，
     * 即mHidden，导致页面重启后，该值为默认的false，即show状态，所以导致了Fragment的重叠。
     * 两种方案：第一种在activity中处理，第二种在fragment中处理
     * @param savedInstanceState                bundle
     */
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (savedInstanceState != null) {
            //异常启动
            boolean isSupportHidden = savedInstanceState.getBoolean(STATE_SAVE_IS_HIDDEN);
            FragmentTransaction ft = null;
            if (getFragmentManager() != null) {
                ft = getFragmentManager().beginTransaction();
                if (isSupportHidden) {
                    ft.hide(this);
                } else {
                    ft.show(this);
                }
                ft.commit();
            }
        } else {
            //正常启动
        }
    }
    
    /**
     * 异常崩溃，但是没有完全杀死app，内存重启，保存状态
     * @param outState                          bundle
     */
    @Override
    public void onSaveInstanceState(@NotNull Bundle outState) {
        outState.putBoolean(STATE_SAVE_IS_HIDDEN, isHidden());
    }
    ```
- 优点：不管多深的嵌套Fragment、同级Fragment等场景，全都可以正常工作，不会发生重叠！


#### 2.3 通过getFragment和putFragment方式
- 在首页MainActivity中的onSaveInstanceState(Bundle outState)方法里，判断当前所有Fragment，将已经加载的Fragment进行保存
    - 复制代码这里需要注意的是，通过getSupportFragmentManager().putFragment();方法按Tag保存Fragment时，需要先确认该Fragment已经add到FragmentManager中了，否则会出现 IllegalStateException: Fragment is not currently in the FragmentManager 错误。
    ```
    /**
     * 非法异常情况保存重要状态
     * @param outState						bundle
     */
    @Override
    protected void onSaveInstanceState(Bundle outState) {
    	LogUtil.d("MainActivity-----onSaveInstanceState");
    	//传入当前选中的tab值，在销毁重启后再定向到该tab
    	if (outState!=null){
    		/*fragment不为空时 保存*/
    		for (int i = 0; i < TAB_SIZE; i++) {
    			//确保fragment是否已经加入到fragment manager中
    			if (fragmentList.size()>i && fragmentList.get(i).isAdded() && fragmentList.get(i) != null) {
    				//保存已加载的Fragment
    				getSupportFragmentManager().putFragment(outState, mFragmentTags.get(i),
    						fragmentList.get(i));
    			}
    		}
    		outState.putInt("position",position);
    	}
    	super.onSaveInstanceState(outState);
    }
    ```
- 在onCreate(Bundle savedInstanceState)中恢复保存的Fragment
    - 复制代码在进入onCreate函数时，先判断savedInstanceState是否为null，逐步判断对应Tag的Fragment存不存在，存在则传入到存储Fragment的list中。
    ```
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (savedInstanceState != null) {
    		/*获取保存的fragment  没有的话返回null*/
    		for (int i = 0; i < TAB_SIZE; i++) {
    			Fragment fragment = getSupportFragmentManager().getFragment(
    					savedInstanceState, mFragmentTags.get(i));
    			if (fragment != null && fragmentList.size()>i) {
    				fragmentList.set(i, fragment);
    			}
    		}
    		position = savedInstanceState.getInt("position",0);
        }
        initFragment();
    }
    ```
- 初始化Fragment
    - 这一步本来是第一步，不过加了前面的操作之后，本来为空的FragmentList现在就不一定为空了，所以在初始化各个Fragment时，记得先判断是否已经存在了，如果不存在才创新一个新的对象，否则就是已经添加了之前保存的Fragment：
    ```
    private void initFragment() {
    	//避免异常重启后重复add
    	if (fragmentList.size()>=TAB_SIZE){
    		fragmentList.set(0, new IndexFragment());
    		fragmentList.set(1, new BaoFragment());
    		fragmentList.set(2, new MyFragment());
    	} else {
    		fragmentList.add(0, new IndexFragment());
    		fragmentList.add(1, new BaoFragment());
    		fragmentList.add(2, new MyFragment());
    	}
    }
    ```




### 03.Fragment高耦合性
- 那些场景体现fragment高耦合性
    - 当子Fragment需要调用宿主Acitivity的方法时，比如子Fragment需要发送一个广播，但是Fragment没有改方法，所以需要借助宿主Activity去发送，这时候常常需要强制转换content对象，然后调用宿主Acitivity发方发送广播，这种直接使用的方式违背了高聚低耦的设计原则；
- 解决办法：通过接口抽象的方法，通过接口去调用宿主Activity的方法。
    ```
    /**
     * 发送广播
     */
    public interface SendBListener {
        void send();
    }
    
    public class FirstFragment extends Fragment {
        SendBListener listener;
    
        public void setListener(SendBListener listener) {
            this.listener = listener;
        }
    
        @OnClick(value = R.id.tv)
        void onTvClick(View view) {
            listener.send();
        }
    }
    
    public class MainActivity extends AppCompatActivity implements SendBListener{
        @BindView(R.id.fl_fragment)
        FrameLayout mFlFragment;
    
        @Override
        public void send() {
            sendBroadcast(new Intent("xxxxxx"));
        }
    
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            
            FirstFragment firstFragment=new FirstFragment();
            firstFragment.setListener(this);
        }
    }
    ```



### 04.处理返回键逻辑
#### 4.1 使用transaction.addToBackStack(null)添加fragment
- 先看下代码
    - 出现的问题是：在某个activity上添加fragment，不处理宿主activity中返回键逻辑，点击返回键，关闭了fragment同时也关闭了activity。
    ```
    OrderStatesFragment fragment = new OrderStatesFragment();
    FragmentManager fragmentManager = activity.getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.add(android.R.id.content, fragment, "OrderStatesFragment");
    transaction.addToBackStack(null);
    transaction.commitAllowingStateLoss();
    ```
- 应该符合的逻辑
    - 在某个activity上添加fragment，如果不处理宿主activity中返回键逻辑，点击返回键，依次关闭了fragment直到没有，回到宿主activity页面。再次点击返回键，则关闭activity！
    ```
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            List<Fragment> fragments = getSupportFragmentManager().getFragments();
            //  fragmentManager里默认就有1个fragment，如果fragments大于1 说明activity添加里新的fragment
            if (fragments.size() > 2) {
                onBackPressed();
            } 
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }
    ```
- 然后更改一下代码，发现返回键逻辑就行不通了。
    ```
    OrderStatesFragment fragment = new OrderStatesFragment();
    FragmentManager fragmentManager = activity.getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.add(android.R.id.content, fragment, "OrderStatesFragment");
    transaction.commitAllowingStateLoss();
    ```
- 那么为什么会出现这种情况呢？




### 05.commitAllowingStateLoss
- 思考一下：commit 和 commitAllowingStateLoss 的区别？
- fragment 基本上是每个项目都会用到，一般我们会这么写：
    ```
    getSupportFragmentManager()
            .beginTransaction()
            .add(R.id.fragment_container, new MyFragment())
            .commit();
    ```
    - 但是有时候会报如下错误信息：Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
    - 意思就是说我们不能在调用onSaveInstanceState进行commit操作。
- 网上的解决办法是使用commitAllowingStateLoss替换commit。确实是不报错了，但是为什么呢？
    - 首先找到FragmentTransaction类。
    ```
    public abstract class FragmentTransaction {
        public abstract int commit();
        public abstract int commitAllowingStateLoss();
    }
    ```
    - 原来commit和commitAllowingStateLoss是抽象方法。继续往下找。
    ```
    final class BackStackRecord extends FragmentTransaction implements
            FragmentManager.BackStackEntry, FragmentManagerImpl.OpGenerator {
        @Override
        public int commit() {
            return commitInternal(false);
        }
    
        @Override
        public int commitAllowingStateLoss() {
            return commitInternal(true);
        }
    }
    ```
    - 发现BackStackRecord类继承了FragmentTransaction。可以看出，不同之处只有commitInternal的参数。感觉离真相又近了一步，继续往下看：
    ```
    int commitInternal(boolean allowStateLoss) {    
        // ...不显示无关代码
        mManager.enqueueAction(this, allowStateLoss);
        return mIndex;
    }
    ```
    - 在commitInternal方法内，只有mManager.enqueueAction(this,allowStateLoss);使用了该布尔值参数。离真相还差一点了，继续推测：
    ```
    public void enqueueAction(OpGenerator action, boolean allowStateLoss) {
        if (!allowStateLoss) {
            checkStateLoss();
        }
        synchronized (this) {
            if (mDestroyed || mHost == null) {
                if (allowStateLoss) {
                    // This FragmentManager isn't attached, so drop the entire transaction.
                    return;
                }
                throw new IllegalStateException("Activity has been destroyed");
            }
            // ...无关代码
        }
    }
    ```
    - 有了突破性进展！此处对allowStateLoss值进行了判断。checkStateLoss按照命名意思是校验状态。离真相仅剩一步了！
    ```
    private void checkStateLoss() {
        if (isStateSaved()) {
            throw new IllegalStateException(
                    "Can not perform this action after onSaveInstanceState");
        }
        if (mNoTransactionsBecause != null) {
            throw new IllegalStateException(
                    "Can not perform this action inside of " + mNoTransactionsBecause);
        }
    }
    
    @Override
    public boolean isStateSaved() {
        // See saveAllState() for the explanation of this.  We do this for
        // all platform versions, to keep our behavior more consistent between
        // them.
        return mStateSaved || mStopped;
    }
    ```
    - 这里会抛出异常信息，明显就是文章开头碰到的异常错误信息！isStateSaved()方法也一同显示了。到了此时，可以明白commit是会对状态进行检测，并抛出异常；而commitAllowingStateLoss方法只是不进行状态检测，因此不会抛出异常。这明显是有点逃避问题，那么这个状态是什么判断而得出的呢？
    ```
    Parcelable saveAllState() {
        // ...无关代码
        mStateSaved = true;
        // ...无关代码
    }
    ```
    - 主要看mStateSaved变量。在saveAllState方法内，把mStateSaved赋值为true。有意思的是saveAllState是在Activity和FragmentActivity内的onSaveInstanceState方法调用的。
- commit 和 commitAllowingStateLoss使用建议？
    - 谷歌在commitAllowingStateLoss方法的注释上也写明，调用此方法会有丢失页面状态信息的风险。
    - 一般情况下，尽量提早调用 commit 方法，比如说onCreate()；
    - 异步回调中避免使用commit；
    - 不得已的情况，可以使用commitAllowingStateLoss替代commit。毕竟报错奔溃，比页面状态信息丢失更严重；



### 06.Fragment叠加点击穿透
- 项目的首页是一个MainActivity包含多个Fragment，通过hide&show来进行tab切换。
    - 在刚开始就遇到了一个很恶心的问题：当前Fragment页，点击能跳转到其他Fragment页的内容。具体来说就是不应该被点击的位置，出现了其它Fragment页面对应位置的点击事件。这个问题不是100%的复现的，而且有些机型不会出现，有些又很频繁。
    - 还有种情形，app异常重启出现fragment叠加的时候，也会出现点击穿透……
- 为何出现该问题？
    - 实际上是点击事件分发的问题，当多个Fragment添加进Fragment栈时，栈底的Fragment的点击事件在上层Fragment出现后仍然有效。
- 解决问题办法
    - 在BaseFragment中全局添加了view.setClickable(true); 问题再也没复现过了。
    ```
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View rootView = inflater.inflate(this.getLayoutId(), container, false);
        rootView.setClickable(true);     //把View的click属性设为true，截断点击时间段扩散
        return super.onCreateView(inflater, container, savedInstanceState);
    }
    ```


### 07.Fragment出现白屏
- 触发原因
    - 当Fragment里面嵌套Fragment时，没有使用getChildFragmentManager(),在Activity恢复后无法获取FragmentManager内的Fragment，从而出现白屏。
- 解决方案
    - Fragment嵌套Fragment时,使用getChildFragmentManager()获取事务



### 10.Fragment使用建议
- 关于使用Fragment操作的使用建议
    - 如果Fragment视图被频繁的使用，或者一会要再次使用，建议使用show/hide方法，这样可以提升响应速度和性能。
    - 如果Fragment占用大量资源，使用完成后，可以使用replace方法，这样可以及时的释放资源。
- 传递参数建议
    - Fragment的数据传递通过setArguments/getArguments进行，这样在Activity重启时，系统会帮你保存数据，这点和Activity很相似。


### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e













