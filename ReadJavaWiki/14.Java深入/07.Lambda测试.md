#### 目录介绍
- 01.思考一个问题
- 02.先看测试用例
- 03.几种假设的回答



### 01.思考一个问题
- 问你的问题是，有人说“Lambda能让Java程序慢30倍”，你怎么看？对于这个问题，你该如何测试效率，如何写测试案例？



### 02.先看测试用例
- 为了让你清楚地了解这个背景，请参考下面的代码片段。在实际运行中，基于 Lambda/Stream 的版本（lambdaMaxInteger），比传统的 for-each 版本（forEachLoopMaxInteger）慢很多。
- 然后比较两者执行的时间，来看效率准确吗？
    ```
    // 一个大的 ArrayList，内部是随机的整形数据
    volatile List<Integer> integers = …
    
    // 基准测试 1
    public int forEachLoopMaxInteger() {
      int max = Integer.MIN_VALUE;
      for (Integer n : integers) {
       max = Integer.max(max, n);
      }
      return max;
    }
    
    // 基准测试 2
    public int lambdaMaxInteger() {
      return integers.stream().reduce(Integer.MIN_VALUE, (a, b) -> Integer.max(a, b));
    }
    ```

### 03.几种假设的回答
- 我认为，“Lambda 能让 Java 程序慢 30 倍”这个争论实际反映了几个方面：
    - 第一，基准测试是一个非常有效的通用手段，让我们以直观、量化的方式，判断程序在特定条件下的性能表现。
    - 第二，基准测试必须明确定义自身的范围和目标，否则很有可能产生误导的结果。前面代码片段本身的逻辑就有瑕疵，更多的开销是源于自动装箱、拆箱（auto-boxing/unboxing），而不是源自 Lambda 和 Stream，所以得出的初始结论是没有说服力的。
    - 第三，虽然 Lambda/Stream 为 Java 提供了强大的函数式编程能力，但是也需要正视其局限性：
        - 一般来说，我们可以认为 Lambda/Stream 提供了与传统方式接近对等的性能，但是如果对于性能非常敏感，就不能完全忽视它在特定场景的性能差异了，例如：初始化的开销。 Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建CallSite实例。这意味着，如果 Java 应用启动过程引入了很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。
        - 增加了程序诊断等方面的复杂性，程序栈要复杂很多，Fluent 风格本身也不算是对于调试非常友好的结构，并且在可检查异常的处理方面也存在着局限性等。

