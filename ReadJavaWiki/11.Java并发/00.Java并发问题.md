#### 目录介绍
- 9.0.0.1 并发切入点是什么？什么是线程安全？线程安全有那几个级别？线程安全必备那些因素和特性？
- 9.0.0.2 多线程三要素是什么？如何理解原子性？如何理解可见性？如何理解有序性？三要素作用是什么？
- 9.0.0.3 有哪些方式处理多线程并发？如何保证原子性？如何保证可见性？如何保证有序性？
- 9.0.0.4 Synchronize是什么？synchronized主要有哪些用法？synchronized可以修饰哪些内容？
- 9.0.0.5 Synchronize普通方法同步和静态方法同步有何区别？代码块同步中synchronized(this)和synchronized(o)区别？
- 9.0.0.6 平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性，说下你的理解？
- 9.0.0.7 同步代码块中，synchonized(this)和synchonized(object)区别？总结一下使用synchonized的特性？
- 9.0.0.8 Synchronize锁机制底层是怎么实现的？实现同步方法和同步代码块有何区别？
- 9.0.0.9 多线程下，synchronized底层如何保证原子性的？如何保证可见性的？synchronized锁优化有哪些操作？
- 9.0.1.0 什么是公平锁，什么是非公平锁？公平锁VS非公平锁区别？什么是乐观锁和悲观锁，说下你的理解？
- 9.0.1.1 说一下ReentrantLock是什么锁？什么场景下用ReentrantLock锁机制？ReentrantLock是公平锁还是非公平锁？
- 9.0.1.2 Synchronize和ReentrantLock相似点是什么？Synchronize和ReentrantLock有哪些方面的区别？两者性能比较？
- 9.0.1.5 死锁产生的条件有哪些？死锁类型有几种？请写出一个静态死锁？如何解决这种静态死锁？
- 9.0.1.6 死锁发生的场景有哪些？造成死锁原因有哪些？死锁的危害是什么？说一下你的看法……
- 9.0.1.7 什么是动态的锁顺序死锁？动态的锁顺序死锁解决方案是什么，说一下你的思路？
- 9.0.1.8 volatile轻量级锁用途是什么？volatile应用场景有哪些？为什么用volatile修饰instance？
- 9.0.1.9 被volatile的变量有何特点？多线程的条件下如何获取被volatile的最新值？
- 9.0.2.0 重入锁，为什么一个被Synchronize修饰的方法里面，在调用一个方法，这个方法需要加锁？多线程条件下，不加锁会造成死锁。








#### 9.0.0.1 并发切入点是什么？什么是线程安全？线程安全有那几个级别？线程安全必备那些因素和特性？
- **并发切入点是什么？**
    - 并发分析的切入点分为**两个核心，三大性质**。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性。
- **什么是线程安全**
    - 线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
    - 通俗来讲，如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的，或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。
- **线程安全有那几个级别**
    - 不可变：
        - 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
    - 绝对线程安全
        - 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
    - 相对线程安全
        - 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。
    - 线程非安全[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - ArrayList、LinkedList、HashMap等都是线程非安全的类.
- **线程安全需要保证几个基本特性**
    - 1、原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
    - 2、可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
    - 3、有序性，是保证线程内串行语义，避免指令重排等。





#### 9.0.0.2 多线程三要素是什么？如何理解原子性？如何理解可见性？如何理解有序性？三要素作用是什么？
- **多线程三要素是什么**
    - 三要素分别是：原子性，可见性，有序性
- **如何理解原子性**
    - 即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
    - 举一个例子
        - 关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。
- 如何理解可见性
    - 当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。
    - 举一个例子
        - CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。
- **如何理解有序性**
    - 顺序性指的是，程序执行的顺序按照代码的先后顺序执行。
    - 举一个例子
        - 语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。
- **三要素作用是什么**
    - 上面这三个要素主要作用是保障线程安全。保证线程安全可从多线程三特性出发：
    - 原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行
        - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
        - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
    - 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
        - volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
        - synchronized：在释放锁之前会将工作内存新值更新到主存中
    - 有序性（Ordering）：程序代码按照指令顺序执行
        - volatile： 本身就包含了禁止指令重排序的语义
        - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入





#### 9.0.0.3 有哪些方式处理多线程并发？如何保证原子性？如何保证可见性？如何保证有序性？
- **有哪些方式处理多线程并发？**
    - 保证原子性
        - 锁和同步：lock锁 或者 synchronized同步
        - CAS
    - 保证可见性
        - volatile：比如单利对象用volatile修饰
    - 保证有序性
        - synchronized和锁保证顺序性
- **如何保证原子性**
    - 第一种方式：锁和同步
        - 常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。
        - 使用锁
            - 可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。
            ```
            public void testLock () {
                lock.lock();
                try{
                    int j = i;
                    i = j + 1;
                } finally {
                    lock.unlock();
                }
            }
            ```
        - 同步方法或者同步代码块。
            - 使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例
            ```
            public void testLock () {
                synchronized (MainActivity.class){
                    int j = i;
                    i = j + 1;
                }
            }
            ```
        - 总结
            - 无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。
- **第二种方式：CAS**
    - 基础类型变量自增（i++）是一种常被误以为是原子操作而实际不是的操作。
        - Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下。
        ```
        AtomicInteger atomicInteger = new AtomicInteger();
        for(int b = 0; b < numThreads; b++) {
            new Thread(() -> {
                for(int a = 0; a < iteration; a++) {
                    atomicInteger.incrementAndGet();
                }
            }).start();
        }
        ```
- **如何保证可见性**
    - Java提供了volatile关键字来保证可见性。
        - 当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。
- **如何保证有序性**
    - Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。
    - synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。
    - 除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。





#### 9.0.0.4 Synchronize是什么？synchronized主要有哪些用法？synchronized可以修饰哪些内容？
- **Synchronize是什么**
    - `synchronized`关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。
    - 对于程序员来说，`synchronized`只是个关键字而已，用起来很简单。之所以我们可以在处理多线程问题时可以不用考虑太多，就是因为这个关键字帮我们屏蔽了很多细节。
    - synchronized实现同步的基础：Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得**对象锁**，退出或抛出异常时必须释放锁。
- **synchronized主要有哪些用法？**
    * synchronized 是java语言关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。
    * synchronized 关键字，主要有两种用法，分别是同步方法和同步代码块。也就是synchronized 方法和 synchronized 块。
        ``` 
        //同步的方法
        pubilc synchronized void test() {
        
        }
        
        //同步代码块上
        public void test() {
             synchronized(obj) {
                  System.out.println("===");
             }
        }
        ``` 
    - 被`synchronized`修饰的代码块及方法，在同一时间，只能被单个线程访问。
- **synchronized可以修饰哪些内容？**
    - 1.修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
    - 2.修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
    - 3.修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
    - 4.修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。



#### 9.0.0.5 Synchronize普通方法同步和静态方法同步有何区别？代码块同步中synchronized(this)和synchronized(o)区别？
- **Synchronize普通方法同步和静态方法同步有何区别？**
    - **①方法同步**
    
        ``` java
        public synchronized void method1
        ```
        - 锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。
    - **③静态方法同步**
        ``` java
        public synchronized static void method3
        ```
        - 锁住的是该类，当所有该类的对象(多个对象)在不同线程中调用这个static同步方法时，线程之间会形成互斥，达到同步效果。
- 代码块同步中synchronized(this)和synchronized(o)区别？
    - **②代码块同步(this)**
        ``` java
        synchronized(this){ //TODO }
        ```
        - 描述同①
    
    - **④代码块同步(.class)**
        ```
        synchronized(Test.class){ //TODO}
        ```
        - 同③
    - **⑤代码块同步(object)**
        ```
        synchronized(o) {}
        ```
        - 这里面的o可以是一个任何Object对象或数组，并不一定是它本身对象或者类，谁拥有o这个锁，谁就能够操作该块程序代码。
- **测试代码如下所示**
    ```
    private void test() {
        final TestSynchronized test1 = new TestSynchronized();
        final TestSynchronized test2 = new TestSynchronized();
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                test1.method01("a");
                //test1.method02("a");
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                test2.method01("b");
                //test2.method02("a");
            }
        });
        t1.start();
        t2.start();
    }
    
    private static class TestSynchronized{
        private int num1;
        public synchronized void method01(String arg) {
            try {
                if("a".equals(arg)){
                    num1 = 100;
                    System.out.println("tag a set number over");
                    Thread.sleep(1000);
                }else{
                    num1 = 200;
                    System.out.println("tag b set number over");
                }
                System.out.println("tag = "+ arg + ";num ="+ num1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    
        private static int  num2;
        public static synchronized void method02(String arg) {
            try {
                if("a".equals(arg)){
                    num2 = 100;
                    System.out.println("tag a set number over");
                    Thread.sleep(1000);
                }else{
                    num2 = 200;
                    System.out.println("tag b set number over");
                }
                System.out.println("tag = "+ arg + ";num ="+ num2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    //调用method01方法打印日志【普通方法】
    tag a set number over
    tag b set number over
    tag = b;num =200
    tag = a;num =100
    
    
    //调用method02方法打印日志【static静态方法】
    tag a set number over
    tag = a;num =100
    tag b set number over
    tag = b;num =200
    ```
    - 在static方法前加synchronized：静态方法属于类方法，它属于这个类，获取到的锁，是属于类的锁。 
    - 在普通方法前加synchronized：非static方法获取到的锁，是属于当前对象的锁。 
    - 结论：类锁和对象锁不同，synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。





#### 9.0.0.6 平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性，说下你的理解？
- **锁可以保证可见性？**
    - 锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。
- **锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？**
    - synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。
- 既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？
    - 锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。
- synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别
    - synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。



#### 9.0.0.7 同步代码块中，synchonized(this)和synchonized(object)区别？总结一下使用synchonized的特性？
- **synchonized(this)和synchonized(object)区别**
    * 其实并没有很大的区别，synchonized(object)本身就包含synchonized(this)这种情况，使用的场景都是对一个代码块进行加锁，效率比直接在方法名上加synchonized高一些（下面分析），唯一的区别就是对象的不同。
    * 对synchronized(this)的一些理解
    	* 一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 
    	* 二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
    	* 三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。
    	* 四、当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。
- **总结一下使用synchonized的特性**
    - 1.synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。 
    - 2.synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。 
    - 3.在static方法前加synchronized：静态方法属于类方法，它属于这个类，获取到的锁，是属于类的锁。
    - 4.在普通方法前加synchronized：非static方法获取到的锁，是属于当前对象的锁。
    - 5.类锁和对象锁不同，synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。




#### 9.0.0.8 Synchronize锁机制底层是怎么实现的？实现同步方法和同步代码块有何区别？
- **Synchronize锁机制底层是怎么实现的？**
    - Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。
    - 在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。
- **实现同步方法和同步代码块有何区别**
    - JVM基于进入和退出`Monitor`对象来实现 **代码块同步** 和 **方法同步** ，两者实现细节不同。
    - 代码块同步实现机制
        - **代码块同步：** 在编译后通过将`monitorenter`指令插入到同步代码块的开始处，将`monitorexit`指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个`monitor`与之关联，线程执行`monitorenter`指令时，会尝试获取对象对应的`monitor`的所有权，即尝试获得对象的锁。
    - 方法同步实现机制
        - **方法同步：** synchronized方法在`method_info结构`有`ACC_synchronized`标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。
    - 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。**任意一个对象都拥有自己的监视器**，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为`BLOCKED`。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。



#### 9.0.0.9 多线程下，synchronized底层如何保证原子性的？如何保证可见性的？synchronized锁优化有哪些操作？
- **synchronized底层如何保证原子性的**
    - 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。
        - 线程是CPU调度的基本单位。
            - CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。
    - 在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。
        - 前面中，介绍过，这两个字节码指令，在Java中对应的关键字就是`synchronized`。
        - 通过`monitorenter`和`monitorexit`指令，可以保证被`synchronized`修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。
    - 多线程保证了原子性
        - 线程1在执行`monitorenter`指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，除非线程1主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于`synchronized`的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。
- **synchronized底层如何保证可见性的**
    - 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    - Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。
    - 前面我们介绍过，被`synchronized`修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。
    - 所以，synchronized关键字锁住的对象，其值是具有可见性的。
- **synchronized锁优化有哪些操作？**
    - 前面介绍了`synchronized`的用法、原理以及对并发编程的作用。是一个很好用的关键字。
    - `synchronized`其实是借助Monitor实现的，在加锁时会调用objectMonitor的`enter`方法，解锁的时候会调用`exit`方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的`enter`和`exit`，这种锁被称之为重量级锁。
    - 所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。




#### 9.0.1.0 什么是公平锁，什么是非公平锁？公平锁VS非公平锁区别？什么是乐观锁和悲观锁，说下你的理解？
- **什么是公平锁**
    - 一句话概括
        - 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。
    - 为何需要公平锁
        - CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程**先到先得**的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。
        - 那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程**按照时间的先后顺序**执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。
    - ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。
- **什么是非公平锁**
    - 一句话概括
        - 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。
    - 非公平锁有哪些
        - 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。
- **公平锁VS非公平锁**
    - 1.公平锁每次获取到锁为同步队列中的第一个节点，**保证请求资源时间上的绝对顺序**，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，**造成“饥饿”现象**。
    - 2.公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，**保证了系统更大的吞吐量**。
- **什么是乐观锁和悲观锁？**
    - 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
    - 悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
        - 悲观锁在Java中的使用，就是利用各种锁。
        - 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
    - 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
    - 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。





#### 9.0.1.1 说一下ReentrantLock是什么锁？什么场景下用ReentrantLock锁机制？ReentrantLock是公平锁还是非公平锁？
- **ReentrantLock是什么**
    - ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：
        - 1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。
        - 2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
        - 3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。
- **什么场景下用ReentrantLock锁机制？**
    - 适用场景：
        - 时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票 
        - 在确实需要一些synchronized所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。
    - 如何选用
        - ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数 synchronized 块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用 synchronized 开发，直到确实证明 synchronized 不合适，而不要仅仅是假设如果使用 ReentrantLock “性能会更好”。请记住，这些是供高级用户使用的高级工具。（而且，真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。）。一如既往，首先要把事情做好，然后再考虑是不是有必要做得更快。 
- **ReentrantLock是公平锁还是非公平锁？**
    - 公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。
        - 1、公平锁能保证：老的线程排队使用锁，新线程仍然排队使用锁。
        - 2、非公平锁保证：老的线程排队使用锁；但是无法保证新线程抢占已经在排队的线程的锁。
    - ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。




#### 9.0.1.2 Synchronize和ReentrantLock相似点是什么？Synchronize和ReentrantLock有哪些方面的区别？两者性能比较？
- **Synchronize和ReentrantLock相似点**
    - 这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。
- **Synchronize和ReentrantLock有哪些方面的区别？**
    - 两者API层面的区别
        - 这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。
        - 而ReentrantLock它是JDK1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。
    - 等待可中断的区别
        - 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可等待特性对处理执行时间非常长的同步快很有帮助。
        - 具体来说，假如业务代码中有两个线程，Thread1 Thread2。假设 Thread1 获取了对象object的锁，Thread2将等待Thread1释放object的锁。
            - 使用synchronized。如果Thread1不释放，Thread2将一直等待，不能被中断。synchronized也可以说是Java提供的原子性内置锁机制。内部锁扮演了互斥锁（mutual exclusion lock ，mutex）的角色，一个线程引用锁的时候，别的线程阻塞等待。
            - 使用ReentrantLock。如果Thread1不释放，Thread2等待了很长时间以后，可以中断等待，转而去做别的事情。
    - 两者都是非公平锁但是有区别
        - synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。
        - ReentrantLock 构造器的一个参数是boolean值，它允许您选择想要一个公平（fair）锁，还是一个不公平（unfair）锁。公平锁：使线程按照请求锁的顺序依次获得锁, 但是有成本；不公平锁：则允许讨价还价
    - 锁定的对象或者方法区别
        - ReentrantLock可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。
        - synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件。但如果要和多于一个的条件关联的时候，就不得不额外添加一个锁。
- **ReentrantLock和synchronized使用分析**
    - ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。
    - 1 用法比较
        - Lock使用起来比较灵活，但是必须有释放锁的配合动作
        - Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
        - Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等
    - 2 特性比较
        - ReentrantLock的优势体现在：
            - 具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
            - 能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放
            - 超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回
    - 3 注意事项
        - 在使用ReentrantLock类的时，一定要注意三点：
            - 在finally中释放锁，目的是保证在获取锁之后，最终能够被释放
            - 不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。
            - ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。
- **两者性能比较？**
    - 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 **当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized** 。所以说，在具体使用时要根据适当情况选择。
    - 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。





#### 9.0.1.5 死锁产生的条件有哪些？死锁类型有几种？请写出一个静态死锁？如何解决这种静态死锁？
- **死锁产生的条件有哪些**
    - 一般来说，要出现死锁问题需要满足以下条件：
    - 1.互斥条件：一个资源每次只能被一个线程使用。
    - 2.请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
    - 3.不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
    - 4.循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。
- **死锁类型有几种**
    - 在JAVA编程中，有3种典型的死锁类型：静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间发生的死锁。
- **请写出一个静态死锁**
    - 启动两个线程，设置两个线程监听对象obj1 、obj2。
        - 线程1启动的时候，先获取obj1锁，暂停1秒，然后获取obj2锁。
        - 线程2启动时，先获取obj2，再获取obj1
    - 当线程2启动的时候获取obj2成功，然后去获取obj1的时候，obj1被线程1占用，此时就等待。线程1秒后去获取obj2，此时obj2锁被线程2握着，产生死锁，互相无法获取。
    ``` 
    //可能发生静态锁顺序死锁的代码
    class StaticLockOrderDeadLock {
        private final Object lockA = new Object();
        private final Object lockB = new Object();
    
        public void a() {
            synchronized (lockA) {
                synchronized (lockB) {
                    System.out.println("function a");
                }
            }
        }
    
        public void b() {
            synchronized (lockB) {
                synchronized (lockA) {
                    System.out.println("function b");
                }
            }
        }
    }
    ```
- **如何解决这种静态死锁**
    - **解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。**
    ```
    //正确的代码
    class StaticLockOrderDeadLock {
        private final Object lockA = new Object();
        private final Object lockB = new Object();
    
        public void a() {
            synchronized (lockA) {
                synchronized (lockB) {
                    System.out.println("function a");
                }
            }
        }
    
        public void b() {
            synchronized (lockA) {
                synchronized (lockB) {
                    System.out.println("function b");
                }
            }
        }
    }
    ```



#### 9.0.1.6 死锁发生的场景有哪些？造成死锁原因有哪些？死锁的危害是什么？说一下你的看法……
- 死锁发生的场景有哪些？
    - 死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。
- 造成死锁原因有哪些
    - 在申请锁时发生了交叉闭环申请。即线程在获得了锁1并且没有释放的情况下去申请锁2，这时，另一个线程已经获得了锁2，在释放锁2之前又要先获得锁1，因此闭环发生，陷入死锁循环。
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-7cec2c49929f7586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 死锁的危害是什么
    - 从9.0.1.5上面死锁代码案例可以知道，当发生死锁的时候，导致彼此一直处于等待之中，而导致代码无法执行下去。只能重启，后果比较严重！
    - 在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。系统发生死锁现象不仅浪费大量的系统资源，甚至导致整个系统崩溃，带来灾难性后果。





#### 9.0.1.7 什么是动态的锁顺序死锁？动态的锁顺序死锁解决方案是什么，说一下你的思路？
- **什么是动态的锁顺序死锁？**
    - 动态的锁顺序死锁是指两个线程调用同一个方法时，传入的参数颠倒造成的死锁。
    - 如下代码，一个线程调用了transferMoney方法并传入参数accountA,accountB；另一个线程调用了transferMoney方法并传入参数accountB,accountA。此时就可能发生在静态的锁顺序死锁中存在的问题，即：第一个线程获得了accountA锁并等待accountB锁，第二个线程获得了accountB锁并等待accountA锁。
    ```
    //可能发生动态锁顺序死锁的代码
    class DynamicLockOrderDeadLock {
        public void transefMoney(Account fromAccount, Account toAccount, Double amount) {
            synchronized (fromAccount) {
                synchronized (toAccount) {
                    //...
                    fromAccount.minus(amount);
                    toAccount.add(amount);
                    //...
                }
            }
        }
    }
    ```
- **动态的锁顺序死锁解决方案是什么，说一下你的思路？**
    - **动态的锁顺序死锁解决方案如下：使用System.identifyHashCode来定义锁的顺序。确保所有的线程都以相同的顺序获得锁。**
    ```java
    //正确的代码
    class DynamicLockOrderDeadLock {
        private final Object myLock = new Object();
    
        public void transefMoney(final Account fromAccount, final Account toAccount, final Double amount) {
            class Helper {
                public void transfer() {
                    //...
                    fromAccount.minus(amount);
                    toAccount.add(amount);
                    //...
                }
            }
            int fromHash = System.identityHashCode(fromAccount);
            int toHash = System.identityHashCode(toAccount);
    
            if (fromHash < toHash) {
                synchronized (fromAccount) {
                    synchronized (toAccount) {
                        new Helper().transfer();
                    }
                }
            } else if (fromHash > toHash) {
                synchronized (toAccount) {
                    synchronized (fromAccount) {
                        new Helper().transfer();
                    }
                }
            } else {
                synchronized (myLock) {
                    synchronized (fromAccount) {
                        synchronized (toAccount) {
                            new Helper().transfer();
                        }
                    }
                }
            }
    
        }
    }
    ```



#### 9.0.1.8 volatile轻量级锁用途是什么？volatile应用场景有哪些？为什么用volatile修饰instance？
- **volatile轻量级锁的用途是什么？**
    - synchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。
    - 线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。
    - **被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。**
- **volatile的应用场景有哪些？**
    - 第一个是状态标记量，比如：
        - 根据状态标记，终止线程。
        ``` 
        volatile boolean flag = false;
         //线程1
        while(!flag){
            doSomething();
        }
          //线程2
        public void setFlag() {
            flag = true;
        }
        ```
    - 第二个是单例模式中的double check，这个用的很常见……
- **为什么要使用volatile 修饰instance？**
    - 主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:
    - 1.给 instance 分配内存
    - 2.调用 Singleton 的构造函数来初始化成员变量
    - 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。
    - 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。



#### 9.0.1.9 被volatile的变量有何特点？多线程的条件下如何获取被volatile的最新值？
- 被volatile的变量有何特点？
    - 在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令**
    - 这个**Lock**指令肯定有神奇的地方，那么Lock前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：
        - 1.将当前处理器缓存行的数据写回系统内存；
        - 2.这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效
- 多线程的条件下如何获取被volatile的最新值
    - 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。
    - 如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
    - 因此，经过分析我们可以得出如下结论：
        - 1.Lock前缀的指令会引起处理器缓存写回内存；
        - 2.一个处理器的缓存回写到内存会导致其他处理器的缓存失效；
        - 3.当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
    - 这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。







