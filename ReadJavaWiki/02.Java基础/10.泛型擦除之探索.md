#### 目录介绍
- 01.编译器类型检查
- 02.可读性和灵活性
- 03.泛型方法和泛型类的比较
- 04.什么是泛型擦除
- 05.泛型擦除案例
- 06.泛型的使用限制
- 07.反射获得泛型类型参数



### 01.编译器类型检查
* 看一个网上的案例
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-b5e6e5cfa996fc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 在引入泛型之后，通过将代码中的“public class Box”更改为“public class Box<T>”来创建泛型类型的声明，而这个声明的背后实质上是引入了可以在类中任何地方使用的类型变量T。如实例4中所示：可以看到，除了新增的泛型类型声明<T>外，所有在原来代码中出现的Object都被类型变量T所替换。
* 乍一看类型变量这个词，感觉有点晦涩难懂，但其实如果仔细思量一番会发现它其实并不难理解，上面的实例4可以理解为“在使用泛型时，可以将类型参数T传递给Box类型本身”，结合Oracle给出的官方定义“泛型的本质是类型参数化”会有更深的理解。
* 在实例5中，在对象声明和初始化的时候，都指定了类型参数T，在场景一种，T为String；在场景二中，T为Integer。这样，在场景二中向IntegerBox中传入String类型的数据“aaaaa”时，程序会报错。实例6中的泛型集合对象的操作也与之类似，在声明了一个List<String>的boxes对象之后，如果向boxes中传入Integer对象11111，程序会报错。
* 可以看到，通过对于泛型的使用，之前的多业务场景中的问题都得到了解决，因为现在在编译阶段就可以解决之前类型不匹配的问题，而不用等到运行时才暴露问题，只要合理使用泛型，就能在很大程度上规避此类风险。对于泛型的使用，这种参数化类型的作用表面上看是声明，背后其实是约定。


### 02.可读性和灵活性
* 泛型除了能进行编译器类型检查和规避类型强制转换外，还能有效地提高代码的可读性。如果不使用泛型，当一个不清楚业务场景的人在对集合进行操作时，无法知道list中存储的是什么类型的对象，如果使用了泛型，就能够通过其类型参数判断出当前的业务场景，也增加了代码的可读性，同时也可以大胆地在抽象继承的基础上进行开发了。
* 泛型使用上的灵活性体现在很多方面，因为它本身实质上就是对于继承在使用上的一种增强。因为泛型在具体工作时，当编译器在编译源码的时候，首先要进行泛型类型参数的检查，检查出类型不匹配等问题，然后进行类型擦除并同时在类型参数出现的位置插入强制转换指令，从而实现泛型。[博客](https://github.com/yangchong211/YCBlogs)



### 03.泛型方法和泛型类的比较
- 例子：
    ```java
    public class A<T>(){
        //泛型类的成员方法，该T受A后面的T的限制
        public T memberFunc(){
            return null;
        }
        //泛型方法，这里的T和和类A的T是不同的
        public static <T> T genericFunc(T a){
            return null;
        }
        public static void main(String[] args) {
            //编译不通过
            //Integer i = A<String>().findByUserName("s");
            
            //编译通过
            Set<Integer> set=  A<String>().findByConditions("s");
        }
    }
    ```
- 这里`Integer i = A<String>().findByUserName("s");`会编译报错：
    ```
    Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer`
    ```
- 由这个例子可知，泛型方法的T和和类A的T是不同的。





### 04.什么是泛型擦除
- 就是指编译器编译带类型说明的集合时会去掉“类型”信息


### 05.泛型擦除案例
- 泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。
    ```
    public class GenericTest {
        public static void main(String[] args) {
            new GenericTest().testType();
        }
    
        public void testType(){
            ArrayList<Integer> collection1 = new ArrayList<Integer>();
            ArrayList<String> collection2= new ArrayList<String>();
            
            System.out.println(collection1.getClass()==collection2.getClass());
            //两者class类型一样,即字节码一致
            
            System.out.println(collection2.getClass().getName());
            //class均为java.util.ArrayList,并无实际类型参数信息
        }
    }
    ```
- 输出
    ```
    true
    java.util.ArrayList
    ```
- 为何会返回true
    - 这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。[博客](https://github.com/yangchong211/YCBlogs)
    - **在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。**
- 使用反射可跳过编译器，往某个泛型集合加入其它类型数据。
    - 只有引用类型才能作为泛型方法的实际参数
    - 例子：
    ```
    public class GenericTest {
        public static void main(String[] args) {
            swap(new String[]{"111","222"},0,1);//编译通过
            
            //swap(new int[]{1,2},0,1);
            //编译不通过,因为int不是引用类型
            
            swap(new Integer[]{1,2},0,1);//编译通过
        }
        
        /*交换数组a 的第i个和第j个元素*/
        public static <T> void swap(T[]a,int i,int j){
            T temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }
    ```
- 但注意基本类型**有时**可以作为实参，因为有**自动装箱**和**拆箱**。
    - 例子(编译通过了)：
    ```
    public class GenericTest {
        public static void main(String[] args) {
            new GenericTest().testType();
            int a = biggerOne(3,5);
            //int 和 double,取交为Number
            Number b = biggerOne(3,5.5);
            //String和int 取交为Object
            Object c = biggerOne("1",2);
        }
        //从x,y中返回y
        public static <T> T biggerOne(T x,T y){
            return y;
        }
    }
    ```
    - 同时，该例还表明，**当实参不一致时，T取交集，即第一个共同的父类。**
    - 另外，如果用`Number b = biggerOne(3,5.5);`改为`String c = biggerOne(3,5.5);`则编译报错:
    ```
    Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限
        推断: java.lang.Number&java.lang.Comparable<? extends java.lang.Number&java.lang.Comparable<?>>
        上限: java.lang.String,java.lang.Object
    ```


### 06.泛型的使用限制
#### 6.1模糊性错误
- 对泛型类 User< T, K > 而言，声明了两个泛型类参数：T 和 K。在类中试图根据类型参数的不同重载 set() 方法。这看起来没什么问题，可编译器会报错
    ```
    public class User<T, K> {
        
        //重载错误
        public void set(T t) {
            
        }
    
    	//重载错误
        public void set(K k) {
    
        }
    }
    ```
- 首先，当声明 User 对象时，T 和 K 实际上不需要一定是不同的类型，以下的两种写法都是正确的
    ```
    public class GenericMain {
        public static void main(String[] args) {
            User<String, Integer> stringIntegerUser = new User<>();
            User<String, String> stringStringUser = new User<>();
        }
    }
    ```
    - 对于第二种情况，T 和 K 都将被 String 替换，这使得 set() 方法的两个版本完全相同，所以会导致重载失败。
- 此外，对 set() 方法的类型擦除会使两个版本都变为如下形式：[博客](https://github.com/yangchong211/YCBlogs)
    - 一样会导致重载失败
    ```
    public void set(Object o) {
        
    }
    ```


#### 6.2 不能实例化类型参数
- 不能创建类型参数的实例。因为编译器不知道创建哪种类型的对象，T 只是一个占位符
    ```
    public class User<T> {
    
        private T t;
    
        public User() {
            //错误
            t = new T();
        }
    }
    ```



### 6.3 对静态成员的限制
- 静态成员不能使用在类中声明的类型参数，但是可以声明静态的泛型方法
    ```
    public class User<T> {
    
        //错误
        private static T t;
    
        //错误
        public static T getT() {
            return t;
        }
    
        //正确
        public static <K> void test(K k) {
    
        }
    }
    ```



#### 6.4 对泛型数组的限制
- 不能实例化元素类型为类型参数的数组，但是可以将数组指向类型兼容的数组的引用
    ```
    public class User<T> {
    
        private T[] values;
    
        public User(T[] values) {
            //错误，不能实例化元素类型为类型参数的数组
            this.values = new T[5];
            //正确，可以将values 指向类型兼容的数组的引用
            this.values = values;
        }
    }
    ```
- 此外，不能创建特定类型的泛型引用数组，但使用通配符的话可以创建指向泛型类型的引用的数组
    ```
    public class User<T> {
    
        private T[] values;
    
        public User(T[] values) {
            this.values = values;
        }
    }
    
    
    public class GenericMain {
    
        public static void main(String[] args) {
            //错误，不能创建特定类型的泛型引用数组
            User<String>[] stringUsers = new User<>[10];
            //正确，使用通配符的话，可以创建指向泛型类型的引用的数组
            User<?>[] users = new User<?>[10];
        }
    }
    ```



#### 6.5对泛型异常的限制
- 泛型类不能扩展 Throwable，意味着不能创建泛型异常类


### 07.反射获得泛型类型参数
- 把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数
- 例子：
    ```
    public class GenericTest {
    
        public static void main(String[] args) throws Exception {
            getParamType();
        }
        
         /*利用反射获取方法参数的实际参数类型*/
        public static void getParamType() throws NoSuchMethodException{
            Method method = GenericTest.class.getMethod("applyMap",Map.class);
            //获取方法的泛型参数的类型
            Type[] types = method.getGenericParameterTypes();
            System.out.println(types[0]);
            //参数化的类型
            ParameterizedType pType  = (ParameterizedType)types[0];
            //原始类型
            System.out.println(pType.getRawType());
            //实际类型参数
            System.out.println(pType.getActualTypeArguments()[0]);
            System.out.println(pType.getActualTypeArguments()[1]);
        }
    
        /*供测试参数类型的方法*/
        public static void applyMap(Map<Integer,String> map){
    
        }
    }
    ```
- 输出结果：
    ```
    java.util.Map<java.lang.Integer, java.lang.String>
    interface java.util.Map
    class java.lang.Integer
    class java.lang.String
    ```



### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e







