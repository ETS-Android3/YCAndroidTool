#### 目录介绍
- 01.什么是内存溢出和泄漏
- 02.内存溢出的案例说明
    - 2.1 堆和栈内存溢出
    - 2.2 为何会内存泄漏
- 03.内存泄漏的案例说明
- 04.OOM异常如何理解
    - 4.1 OOM出现区域
    - 4.2 OOM场景分析



### 02.内存溢出的案例说明
#### 2.1 堆和栈内存溢出
- Java中堆和栈的区别？
    - 栈内存：主要用来存放基本数据类型和局部变量；当在代码块定义一个变量时会在栈中为这个变量分配内存空间，当超过变量的作用域后这块空间就会被自动释放掉。
    - 堆内存：用来存放运行时创建的对象，比如通过new关键字创建出来的对象和数组；需要由Java虚拟机的自动垃圾回收器来管理。
- 分别写出堆内存溢出与栈内存溢出的程序？
    - 栈内存溢出
    ```
    public void A() {
        A();
    }
    ```
    - 堆内存溢出
    ```
    public void testd() {
        List<String> list = new ArrayList<>();
        int i = 0;
        while (true) {
            list.add(new String(i + ""));
            i++;
        }
    }
    ```


#### 2.2 为何会内存泄漏
- Java采用GC进行内存管理。
    - Android虚拟机的垃圾回收采用的是根搜索算法。GC会从根节点（GC Roots）开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。而内存泄漏出现的原因就是存在了无效的引用，导致本来需要被GC的对象没有被回收掉，从而导致内存泄漏。



### 04.OOM异常如何理解
#### 4.1 OOM出现区域
- OutOfMemoryError异常在哪些数据区域中可能会出现？
    - Java堆溢出
    - 虚拟机栈和本地方法栈溢出
    - 方法区和运行时常量池溢出



#### 4.2 OOM场景分析
- Java堆溢出
    - Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常
    - 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
    - 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
- 虚拟机栈和本地方法栈溢出
    - 对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：
    - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError
    - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
    - 在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常
    - 如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程
- 方法区和运行时常量池溢出
    - String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
    - 由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - Intern():JDK1.6 intern方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个









