#### 目录介绍
- 01.MD5加密介绍
- 02.MD5加密算法实现
- 03.MD5加密的应用
- 04.增强MD5的安全性



### 01.MD5加密介绍
#### 1.1 md5是什么
- md5加密是我们常用的一种加密算法，可以对明文进行处理产生一个128位（16字节）的散列值，为了便于展示和读写一般将128位的二进制数转换成32位16进制数（如：655A6E9A375DF4F82B730833C807AADD）。通常用在密码存储和文件的完整性校验上。



#### 1.2 md5是单向加密
- MD5加密算法是单向加密，是不可逆的一种的加密方式，只能用你的密码才能解开，要不就是会解密算法，否则想都别想解开。



#### 1.3 MD5加密的特点
- 压缩性：任意长度的数据，算出的MD5值长度都是固定的。
- 容易计算：从原数据计算出MD5值很容易。
- 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
- 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
- 不可逆：知道密文和加密方式，却无法反向计算出原密码。



### 02.MD5加密算法实现
#### 2.1 计算文件
- 计算文件的md5值，方法一：
    ```java
    public static String getMD5(File f) {
        BigInteger bi = null;
        try {
            byte[] buffer = new byte[8192];
            int len = 0;
            MessageDigest md = MessageDigest.getInstance("MD5");
            FileInputStream fis = new FileInputStream(f);
            while ((len = fis.read(buffer)) != -1) {
                md.update(buffer, 0, len);
            }
            fis.close();
            byte[] b = md.digest();
            bi = new BigInteger(1, b);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if(bi != null)
            return bi.toString(16);
        else
            return "";
    }
    ```
- 计算文件的md5值，方法二：
    ```java
    public static String md5(File file) {
        if (file == null || !file.isFile() || !file.exists()) {
            return "";
        }
        FileInputStream in = null;
        String result = "";
        byte buffer[] = new byte[8192];
        int len;
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            in = new FileInputStream(file);
            while ((len = in.read(buffer)) != -1) {
                md5.update(buffer, 0, len);
            }
            byte[] bytes = md5.digest();
    
            for (byte b : bytes) {
                String temp = Integer.toHexString(b & 0xff);
                if (temp.length() == 1) {
                    temp = "0" + temp;
                }
                result += temp;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            if(null!=in){
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
    ```

#### 2.2 计算字符串
- 计算字符串的md5值
    ```
    public static String md5(String string) {
        if (TextUtils.isEmpty(string)) {
            return "";
        }
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
            byte[] bytes = md5.digest(string.getBytes());
            String result = "";
            for (byte b : bytes) {
                String temp = Integer.toHexString(b & 0xff);
                if (temp.length() == 1) {
                    temp = "0" + temp;
                }
                result += temp;
            }
            return result;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return "";
    }
    ```
- 思路过程
    - str.getBytes():将字符串转化为字节数组。字符串中每个字符转换为对应的ASCII值作为字节数组中的一个元素。
    - 将字节数组通过固定算法转换为16个元素的有符号哈希值字节数组
    - 将哈希字节数组的每个元素通过0xff与运算转换为两位无符号16进制的字符串
    - 将不足两位的无符号16进制的字符串前面加0
    - 通过StringBuffer.append()或者StringBundle.append()将16个长度为2的无符号进制字符串合并为一个32位String类型的MD5码




### 03.MD5加密的应用
- 1.对密码进行加密，移动端会将用户密码通过MD5加密转换后发送给服务器，服务器会在数据库中保存加密后的md5值。这样做的好处是不会直接发送明文密码、服务器管理人员也无法确切的知道密码。但是一旦拿到密码的md5值后仍然存在被暴力破解的可能性。
- 2.文件的完整性校验，在传递文件的过程中附带传递文件的md5值，接收端通过比较文件的md5值判断文件的完整性。




### 04.增强MD5的安全性
- 虽然MD5加密理论上是不可逆的但仍存在被暴力破解的可能性，我们可以通过一下方法加强MD5加密的安全性。
    - 1.对明文多次MD5加密，对明文加密之后的MD5串再次进行MD5加密
    - 2.MD5加盐（salt），基本过程是这样的：当需要对明文进行MD5加密的时候，程序会添加一个salt值跟明文一起进行MD5加密，这样可以极大增强MD5被破解的难度。salt值可以是随机字符串或者username+password这种形式，当使用随机字符串作为salt加密是通常需要将salt一起上传服务器进行保存。
    ```java
    public final class ZgsMd5Utils {
        private static final char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    
        /**
         * MD5 加密
         *
         * @param data 明文字符串
         * @return 16 进制密文
         */
        public static String encryptMD5ToString(final String data) {
            return encryptMD5ToString(data.getBytes());
        }
    
        /**
         * MD5 加密
         *
         * @param data 明文字符串
         * @param salt 盐
         * @return 16 进制加盐密文
         */
        public static String encryptMD5ToString(final String data, final String salt) {
            return bytes2HexString(encryptMD5((data + salt).getBytes()));
        }
    
        /**
         * MD5 加密
         *
         * @param data 明文字节数组
         * @return 16 进制密文
         */
        public static String encryptMD5ToString(final byte[] data) {
            return bytes2HexString(encryptMD5(data));
        }
    
        /**
         * MD5 加密
         *
         * @param data 明文字节数组
         * @param salt 盐字节数组
         * @return 16 进制加盐密文
         */
        public static String encryptMD5ToString(final byte[] data, final byte[] salt) {
            if (data == null || salt == null) return null;
            byte[] dataSalt = new byte[data.length + salt.length];
            System.arraycopy(data, 0, dataSalt, 0, data.length);
            System.arraycopy(salt, 0, dataSalt, data.length, salt.length);
            return bytes2HexString(encryptMD5(dataSalt));
        }
    
        /**
         * MD5 加密
         *
         * @param data 明文字节数组
         * @return 密文字节数组
         */
        public static byte[] encryptMD5(final byte[] data) {
            return hashTemplate(data, "MD5");
        }
    
    
        /**
         * hash 加密模板
         *
         * @param data      数据
         * @param algorithm 加密算法
         * @return 密文字节数组
         */
        private static byte[] hashTemplate(final byte[] data, final String algorithm) {
            if (data == null || data.length <= 0) return null;
            try {
                MessageDigest md = MessageDigest.getInstance(algorithm);
                md.update(data);
                return md.digest();
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
                return null;
            }
        }
    
        private static String bytes2HexString(final byte[] bytes) {
            if (bytes == null) return null;
            int len = bytes.length;
            if (len <= 0) return null;
            char[] ret = new char[len << 1];
            for (int i = 0, j = 0; i < len; i++) {
                ret[j++] = hexDigits[bytes[i] >>> 4 & 0x0f];
                ret[j++] = hexDigits[bytes[i] & 0x0f];
            }
            return new String(ret);
        }
    }
    ```













