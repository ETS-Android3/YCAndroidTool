#### 目录介绍
- 01.线程生命周期是什么
    - 1.2 线程状态转换
    - 1.3 线程执行流程
- 02.线程是如何创建
    - 2.1 创建线程几种方式
    - 2.2 使用Thread类创建线程类
    - 2.3 通过Runnable接口创建线程类
    - 2.4 通过Callable和Future创建线程
    - 2.5 三种创建线程区别
- 03.线程start开启操作

- 04.线程sleep休眠操作
    - 4.1 sleep使用介绍
    - 4.2 sleep(0)的作用是什么
    - 4.3 sleep后怎么被唤醒
- 05.线程join加入操作
    - 5.1 join操作介绍
    - 5.2 如何保证多个线程顺序 
- 06.线程yield礼让操作
    - 6.1 yield礼让操作
- 07.线程setDaemon守护
- 08.线程stop中断操作




### 01.线程生命周期是什么
#### 1.2 线程状态转换
- 线程是会在不同的状态间进行转换。线程创建之后调用start()方法开始运行，当调用wait(),join(),LockSupport.lock()方法线程会进入到**WAITING**状态，而同样的wait(long timeout)，sleep(long),join(long),LockSupport.parkNanos(),LockSupport.parkUtil()增加了超时等待的功能，也就是调用这些方法后线程会进入**TIMED_WAITING**状态，当超时等待时间到达后，线程会切换到Runable的状态，另外当WAITING和TIMED _WAITING状态时可以通过Object.notify(),Object.notifyAll()方法使线程转换到Runable状态。当线程出现资源竞争时，即等待获取锁的时候，线程会进入到**BLOCKED**阻塞状态，当线程获取锁时，线程进入到Runable状态。线程运行结束后，线程进入到**TERMINATED**状态，状态转换可以说是线程的生命周期。另外需要注意的是：
- 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。


#### 1.3 线程执行流程
- 见图03.1
- ![image](https://upload-images.jianshu.io/upload_images/4432347-7a47153a444d450b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




### 02.线程是如何创建
#### 2.1 创建线程几种方式
- 那么，如何在用户程序中新建一个线程了，只要有三种方式：
    - 1.通过继承Thread类，重写run方法；
    - 2.通过实现runnable接口；
    - 3.通过实现callable接口这三种方式




#### 2.2 使用Thread类创建线程类
- 直接创建，如下所示
    ```
    new Thread(new Runnable() {
        @Override
        public void run() {
            
        }
    }).start();
    ```
- 继承Thread，创建步骤如下
    - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run\(\)方法称为执行体。
    - 创建Thread子类的实例，即创建了线程对象。调用线程对象的start\(\)方法来启动该线程。代码如下所示
    ```
    public class ThreadDemo {
    	public static void main(String[] args) {
    		// 创建对象
    		MyThread t1 = new MyThread() ;
    		MyThread t2 = new MyThread() ;
    		// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行
    //		t1.run() ;
    //		t1.run() ;
    		t1.start() ;		// 告诉jvm开启一个线程调用run方法
    		// t1.start() ;		// 一个线程只能被启动一次
    		t2.start() ;
    		
    	}
    }
    
    public class MyThread extends Thread {
    	@Override
    	public void run() {
    		for(int x = 0 ; x < 1000 ; x++) {
    			System.out.println(x);
    		}
    	}
    }
    ```


#### 2.3 通过Runnable接口创建线程类
- 创建步骤如下
    - 定义runnable接口的实现类，并重写该接口的run\(\)方法，该run\(\)方法的方法体同样是该线程的线程执行体。
    - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    - 调用线程对象的start\(\)方法来启动该线程。
- 代码如下所示
    ```
    public static void main(String[] args) {
    	// 创建定义的类的对象
    	MyThread mt = new MyThread() ;
    	// 创建Thread的对象吧第三步创建的对象作为参数传递进来
    	Thread t1 = new Thread(mt , "张三") ;
    	Thread t2 = new Thread(mt , "李四") ;
    	// 启动线程
    	t1.start() ;
    	t2.start() ;
    }
    
    public class MyThread implements Runnable {
    	@Override
    	public void run() {
    		for(int x = 0 ; x < 1000 ; x++) {
    			System.out.println(Thread.currentThread().getName() + "---" + x);
    		}
    		
    	}
    }
    ```


#### 2.4 通过Callable和Future创建线程
- **Callable基础介绍**
    - Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。
    - 它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。
- 通过对比两个接口得到这样的结论
    - Callable 接口下的方法是 call()，Runnable 接口的方法是 run()；
    - Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的；
    - call() 方法可以抛出异常，run()方法不可以的；
    - 运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果；
    ```
    public interface Runnable {
        public void run();
    }
    
    public interface Callable<V> {
        V call() throws Exception;
    }
    ```
- 创建步骤如下所示
    - 创建Callable接口的实现类，并实现call\(\)方法，该call\(\)方法将作为线程执行体，并且有返回值。
    - 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call\(\)方法的返回值。
    - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    - 调用FutureTask对象的get\(\)方法来获得子线程执行结束后的返回值，调用get\(\)方法会阻塞线程。
- 代码如下所示
    ```
    public class CallableThread implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            int i = 0;
            for (; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " " + i);
            }
            return i;
        }
    }
    
    
    public class ThreadDemo {
        public static void main(String[] args) {
            CallableThread ctt = new CallableThread();
            FutureTask<Integer> ft = new FutureTask<>(ctt);
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
                if (i == 20) {
                    new Thread(ft, "有返回值的线程").start();
                }
            }
            try {
                System.out.println("子线程的返回值：" + ft.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
    ```


#### 2.5 三种创建线程区别
- 采用实现Runnable、Callable接口的方式创见多线程时
    - 优势是：
        - 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
        - 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
    - 劣势是：[博客](https://github.com/yangchong211/YCBlogs)
        - 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread\(\)方法。
- 使用继承Thread类的方式创建多线程时
    - 优势是：
        - 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread\(\)方法，直接使用this即可获得当前线程。
    - 劣势是：
        - 线程类已经继承了Thread类，所以不能再继承其他父类。


### 03.线程start开启操作



### 04.线程sleep休眠操作
#### 4.1 sleep使用介绍
- sleep方法
    - public static void sleep(long time) ;	
    - time表达的意思是休眠的时间 , 单位是毫秒
- sleep方法具体作用
    - 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
    - 让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有Synchronized同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。
- sleep如何使低优先级线程执行
    - 比如有两个线程同时执行(没有Synchronized)，一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完成后，低优先级的线程才能执行；但当高优先级的线程sleep(5000)后，低优先级就有机会执行了。
    - 总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。


#### 4.2 sleep(0)的作用是什么
- Thread.sleep(0)的作用是啥？
    - 由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。[博客](https://github.com/yangchong211/YCBlogs)


#### 4.3 sleep后怎么被唤醒
- 怎么唤醒一个阻塞的线程？
    - 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
- 假设现在是 2018-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2018-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？
    - 答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。
    - 与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。


### 05.线程join加入操作
#### 5.1 join操作介绍
- join方法
    - public final void join()
    - 等待该线程执行完毕了以后,其他线程才能再次执行。
    - Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。
    - 保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。
- join()有什么作用？
    - Thread的join()的含义是等待该线程终止，即将挂起调用线程的执行，直到被调用的对象完成它的执行。比如存在两个线程t1和t2，下述代码表示先启动t1，直到t1的任务结束，才轮到t2启动。
    ```
    t1.start();
    t1.join(); 
    t2.start();
    ```
- 注意事项:
    - 在线程启动之后，才能调用调用方法。如果没有启动，调用该方法，则直接会……


#### 5.2 如何保证多个线程顺序
- 经典面试题：现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
    - Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。
    ```
    /**
     * 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
     */
    private void test2(){
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                Log.d("线程执行","Thread1");
            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                Log.d("线程执行","Thread2");
            }
        });
        Thread t3 = new Thread(new Runnable() {
            @Override
            public void run() {
                Log.d("线程执行","Thread3");
            }
        });
    
        t1.start();
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        t2.start();
        try {
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        t3.start();
        try {
            t3.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    ```



### 06.线程yield礼让操作
#### 6.1 yield礼让操作
- yield方法
    - public static void yield():	
    - 暂停当前正在执行的线程对象，并执行其他线程。 
    - 这是一个静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配**给当前线程相同优先级**的线程。
- 线程礼让的原理是: 
    - 暂定当前的线程,然CPU去执行其他的线程,这个暂定的时间是相当短暂的;当我某一个线程暂定完毕以后,其他的线程还没有抢占到cpu的执行权;那么这个是时候当前的线程会和其他的线程再次抢占cpu的执行权; 
- yield礼让线程会释放锁吗
    - yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。[博客](https://github.com/yangchong211/YCBlogs)
- 什么是线程优先级了？下面就来具体聊一聊。
    - 现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当前时间片用完后就会发生线程调度，并等待这下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。
    - 在Java程序中，通过一个**整型成员变量Priority**来控制优先级，优先级的范围从1~10.在构建线程的时候可以通过**setPriority(int)**方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同JVM以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。
    - 另外需要注意的是，sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。



### 07.线程setDaemon守护
- setDaemon方法
    - public final void setDaemon(boolean on)
    - 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。
- 注意要点：
    - 该方法必须在启动线程前调用。
    - jvm会线程程序中存在的线程类型,如果线程全部是守护线程,那么jvm就停止。
- 守护线程是一种特殊的线程
    - 就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。
- 下面以一个简单的例子来表述Daemon线程的使用。
    ```
    public class DaemonDemo {
        public static void main(String[] args) {
            Thread daemonThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            System.out.println("i am alive");
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } finally {
                            System.out.println("finally block");
                        }
                    }
                }
            });
            daemonThread.setDaemon(true);
            daemonThread.start();
            //确保main线程结束前能给daemonThread能够分到时间片
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```
- 输出结果为：
    ```
    > i am alive
    > finally block
    > i am alive
    ```
- 上面的例子中daemodThread run方法中是一个while死循环，会一直打印,但是当main线程结束后daemonThread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonThread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中"finally block"操作。紧接着main 线程结束后，daemonThread退出，这个时候只打印了"i am alive"并没有打印finnal块中的。因此，这里需要注意的是**守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的**线程可以通过setDaemon(true)的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于start()方法，否则会报
    > Exception in thread "main" java.lang.IllegalThreadStateException
    > 	at java.lang.Thread.setDaemon(Thread.java:1365)
    > 	at learn.DaemonDemo.main(DaemonDemo.java:19)
- 这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。


### 08.线程stop中断操作
- stop方法
    - public final void stop():		
    - 停止线程的运行
- interrupt方法
    - public void interrupt():		
    - 中断线程(这个翻译不太好),查看API可得当线程调用wait(),sleep(long time)方法的时候处于阻塞状态,可以通过这个方法清除阻塞
- 中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted（）来感知其他线程对其自身的中断操作，从而做出响应。
- 另外，同样可以调用Thread的静态方法interrupted（）对当前线程进行中断操作，该方法会清除中断标志位。**需要注意的是，当抛出InterruptedException时候，会清除中断标志位，也就是说在调用isInterrupted会返回false。**
- 下面结合具体的实例来看一看
    ```
    public class InterruptDemo {
        public static void main(String[] args) throws InterruptedException {
            //sleepThread睡眠1000ms
            final Thread sleepThread = new Thread() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    super.run();
                }
            };
            //busyThread一直执行死循环
            Thread busyThread = new Thread() {
                @Override
                public void run() {
                    while (true) ;
                }
            };
            sleepThread.start();
            busyThread.start();
            sleepThread.interrupt();
            busyThread.interrupt();
            while (sleepThread.isInterrupted()) ;
            System.out.println("sleepThread isInterrupted: " + sleepThread.isInterrupted());
            System.out.println("busyThread isInterrupted: " + busyThread.isInterrupted());
        }
    }
    ```
- 输出结果
    ```
    > sleepThread isInterrupted: false
    > busyThread isInterrupted: true
    ```
- 开启了两个线程分别为sleepThread和BusyThread,sleepThread睡眠1s，BusyThread执行死循环。然后分别对着两个线程进行中断操作，可以看出sleepThread抛出InterruptedException后清除标志位，而busyThread就不会清除标志位。
- 另外，同样可以通过中断的方式实现线程间的简单交互， while (sleepThread.isInterrupted()) 表示在Main中会持续监测sleepThread，一旦sleepThread的中断标志位清零，即sleepThread.isInterrupted()返回为false时才会继续Main线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。
- 一般在**结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。**




### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e





















