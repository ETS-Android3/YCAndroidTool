#### 目录介绍




### 03.wait和sleep方法
- wait和sleep方法的区别
    - 最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。[博客](https://github.com/yangchong211/YCBlogs)
- wait()和sleep()其他区别
    - sleep()方法是Thread的静态方法，而wait是Object实例方法
    - 调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁 
    - sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU 
    - sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒。
    - wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
    - sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。
- 通俗解释
    - Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。





### 02.sleep方法为何需要捕获异常
- 先来看一下下面代码
    ``` java
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    ```
- 然后看一下源码
    - 从这里可以看出，当millis为0的时候，并且线程调用了interrupted方法，如果使用sleep则会抛出异常InterruptedException，所以需要捕获一下。
    - sleep方法添加了锁
    ``` java
    public static void sleep(long millis) throws InterruptedException {
        Thread.sleep(millis, 0);
    }
    
    public static void sleep(long millis, int nanos) throws InterruptedException {
        if (millis < 0) {
            throw new IllegalArgumentException("millis < 0: " + millis);
        }
        if (nanos < 0) {
            throw new IllegalArgumentException("nanos < 0: " + nanos);
        }
        if (nanos > 999999) {
            throw new IllegalArgumentException("nanos > 999999: " + nanos);
        }

        // The JLS 3rd edition, section 17.9 says: "...sleep for zero
        // time...need not have observable effects."
        if (millis == 0 && nanos == 0) {
            // ...but we still have to handle being interrupted.
            if (Thread.interrupted()) {
              throw new InterruptedException();
            }
            return;
        }

        long start = System.nanoTime();
        long duration = (millis * NANOS_PER_MILLI) + nanos;

        Object lock = currentThread().lock;

        // Wait may return early, so loop until sleep duration passes.
        synchronized (lock) {
            while (true) {
                sleep(lock, millis, nanos);

                long now = System.nanoTime();
                long elapsed = now - start;

                if (elapsed >= duration) {
                    break;
                }

                duration -= elapsed;
                start = now;
                millis = duration / NANOS_PER_MILLI;
                nanos = (int) (duration % NANOS_PER_MILLI);
            }
        }
    }
    ```


### 03.sleep(0)作用是什么
- Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？
    - 答案是：有，而且区别很明显。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0)，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。
- sleep(0)会抛出异常吗？
    - 会抛出异常，代码如下所示
    ```java
    public static void sleep(long millis, int nanos)
        throws InterruptedException {
            if (millis < 0) {
                throw new IllegalArgumentException("millis < 0: " + millis);
            }
            if (nanos < 0) {
                throw new IllegalArgumentException("nanos < 0: " + nanos);
            }
            if (nanos > 999999) {
                throw new IllegalArgumentException("nanos > 999999: " + nanos);
            }
    
            // The JLS 3rd edition, section 17.9 says: "...sleep for zero
            // time...need not have observable effects."
            if (millis == 0 && nanos == 0) {
                // ...but we still have to handle being interrupted.
                if (Thread.interrupted()) {
                  throw new InterruptedException();
                }
                return;
            }
    ```






