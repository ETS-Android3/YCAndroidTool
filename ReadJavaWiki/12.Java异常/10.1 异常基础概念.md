### 目录介绍
- 01.异常的概念说明
- 02.什么是基本异常
- 03.什么是捕获异常
- 04.异常有哪些分类
- 05.异常先抛出后捕获
- 06.创建自定义异常
- 07.异常的限制说明
- 08.异常构造器介绍




### 01.异常的概念说明
#### 01.1 传递错误信息给接收者
- 发现错误的理想时机是在编译阶段，也就是程序在编码过程中发现错误，然而一些业务逻辑错误，编译器并不能一定会找到错误，余下的问题需要在程序运行期间解决，这就需要发生错误的地方能够准确的将错误信息传递给某个接收者，以便接收者知道如何正确的处理这个错误信息。



#### 01.2 基础的概念
- C语言以及其它早期语言的错误处理方式通常是一些约定俗成的模式，比如返回某个错误标记或者设置某个特殊的值通过判断值来确认是否发生了错误。然而长期来看这种错误处理方式由于需要大量的判断以及细致的错误检查而使代码逻辑较为复杂，因此不利于构建大型健壮性的系统。
- 解决的方法是，用强制规定的形式来消除错误处理过程中随心所欲的因素。“异常”这个词有“我对此感到意外”的意思，当错误问题出现了，你可能不知道出现在哪里，或者出现了什么错误，也不知道怎么解决。
- 那么就停下来，将这个问题提供给更高的环境，看看有没有正确的解决方案。使用异常的另一个好处是，它能够明显的降低代码的复杂程度，避免了大量的错误检查，只需要在一个特定的地方进行异常捕获，并且不需要做任何判断，异常捕获区能够捕获所有发生的错误。
- 这种异常的处理方式与之前的错误处理方式相比，完全的将“正常做的事儿”与“出现问题怎么办”隔离开来。是代码的读写变得更加井井有条。



### 02.什么是基本异常
#### 2.1 区分异常和普通问题
- “异常情形”是指阻止当前方法或者作用域继续执行的问题，要把异常情形与普通问题区分开来，普通问题是指在当前的错误收集情况下，能够解决这个问题并继续执行正常的程序。而对于异常情形，这个程序就不能够正常的执行下去了。



#### 2.2 举个案例了解异常
- 除法是一个简单的例子，除数有可能为0，所以先进行检查很有必要。但除数为0如果是一个意外的值，你也不清楚该如何处理，那么抛出异常就显得尤为重要了，而不是顺着原来的路走下去。



#### 2.3 异常后发生什么
- 当抛出异常之后有几件事儿会随之发生，同 Java中其它对象的创建相同，将使用new在堆上创建对象，然后当前程序的执行路径被终止了，因为发生了异常，不能继续执行下去，并且从当前执行的环境中弹出异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方继续执行程序，这个恰当的地方就是异常处理程序。它的任务是使程序从错误的状态中恢复，要么换一种方式运行，要么继续运行下去。



#### 2.4 异常案例分析
- 举一个抛出异常的简单例子，对于一个对象引用t，传递给你的时候可能没有被初始化，所以在使用这个对象引用调用执行方法之前，进行合理的判断是非常有必要的。可以创建一个代表错误信息的对象，并且将它从当前环境中抛出，这样就把错误异常抛到更大的环境中去了。所以一个异常，看起来是这样的：
    ```
    if(t==null){
        throw new NullPointerException();
    }
    ```
- 上面代码中，我们判断当前对象引用是否没有进行初始化，如果没有进行初始化，那么就创建一个NullPointerException（）对象，然后使用throw关键字，将该对象的引用抛出。



#### 2.5 把异常看作事物
- 异常使我们将每件事都当做一个事务考虑，我们还可以将异常看作是一种内建的恢复系统，因为我们在程序中拥有不同的恢复点，如果程序的某部分失败了，异常将“恢复”到程序的某个已知点上。异常最大的好处就是在发生错误的时候能够强制程序终止当前线路的运行。
- 同其它对象的处理方式一样，我们使用new关键字在堆上创建异常对象，因此同样伴随着存储空间的分配和构造器的调用。所有标准异常器都有两个构造函数，一个是无参构造函数，另一个是可以传递一个字符串的构造函数，将相关信息放入到构造器中。此外，异常处理能够抛出任意类型的Throwable对象，它是异常类型的根类。通常对于不同类型的错误，要抛出对应的异常，错误信息可以保存在异常对象内部，或者使用异常的名称来暗示。




### 03.什么是捕获异常
#### 3.1 不捕获异常会怎样
- 没有被程序捕获的所有异常，最终都会交由Java运行时系统提供的默认处理程序捕获。默认处理程序会显示一个描述异常的字符串，输出异常发生的堆栈踪迹并终止程序。例如，运行如下代码：
    ```
    public class Demo {
    	public static void main(String[] args) {
    		int a=520/0;
    	}
    }
    ```
- 生成的异常信息：
    ```
    Exception in thread "main" java.lang.ArithmeticException: / by zero
    	at Demo.main(Demo.java:5)
    ```
- 抛出的异常的类型是Exception的子类ArithmeticException，即算术异常，更具体地描述了发生的错误类型。Java提供了一些能与可能产生的各种运行时错误相匹配的内置异常类型。



#### 3.1 方法块捕获异常
- 可以在程序中专门定义一个方法块儿，用来尝试各种可能产生异常的方法，这个块的定义形式如下：
    ```
    try{
        //---
    }
    ```
- 在关键字try后包围的一部分代码块，称作try块，这样做比起之前说的要在每个会产生错误的地方进行判断要容易的多，并且代码的可读性大大增强，产生异常之后抛出的异常必须在某处得到处理，这个地点就是异常处理区，异常处理区紧跟着try块，使用catch关键字表示：
    ```
    try {
       // 业务代码
       // …
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```


#### 3.2 catch语句作用
- 每个catch语句看起来像是一个接收一个且仅接收一个的特殊参数类型的方法。可以在方法块内部处理这个参数，当然有的异常见名知意，因此可以不用处理参数，但并不可以省略。可以有多个catch块与try对应，用来捕获多种不同的异常。异常处理程序必须紧跟在try块之后，当异常被抛出之后，异常处理机制负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch块中执行，此时认为异常得到了处理。一旦catch子句结束，则认为处理程序的查找过程结束。
- 只有匹配的catch字句才会执行，在try块内部不同的方法可能会产生相同的异常，而你只需要提供一个针对此类型的异常处理程序。



#### 3.3 异常处理两种模型
- 异常的处理理论上有两种模型，一种是终止模型，另一种模型是恢复模型。
- **终止模型**。这种模型中，会假设错误的出现会让程序无法返回到异常发生的地方继续执行。异常被抛出意味着错误已经无法挽回。这也是 Java 和 C++ 所支持的模型。
- **恢复模型**。异常处理程序的工作是修正错误，然后尝试重新调用出问题的方法。在 Java 中可以在 while 循环内放入 try 块，达到类似的效果。这种效果一般会导致耦合度过高--恢复性处理程序的出口一般是非通用型代码（针对特殊异常情况），不好维护。
- **目前终止模型已经基本取代了恢复模型**，虽然这种恢复模型看起来很好，但是实际上使用起来并不容易。



#### 3.4 如何捕获异常
- 在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。
- 运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。



#### 3.5 异常注意事项
- 异常注意事项(针对编译期异常)
* a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)
* b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常
* c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws



### 04.异常有哪些分类
- Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。


#### 4.1 可查异常
- **可查异常**（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。



#### 4.2 不可查异常
- **不可查异常**(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。




### 05.异常先抛出后捕获
- 一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。
- **处理运行时异常**。由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。[博客](https://github.com/yangchong211/YCBlogs)
- **处理Error**。对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。
- **处理可查异常**。对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。





### 06.创建自定义异常
#### 6.1 为何用自定义异常
- Java中虽然提供了很多默认的异常类型，但是要想完全覆盖会发生的异常情况显然是不现实的，因此我们可以自定义异常来表示我们预期可能会出现的异常。自定义的形式也非常简单，只需要继承一个相似的异常类即可。建立一个新的异常类最贱的方法就是让编译器为你产生默认构造器，所以这几乎不需要多少代码。




#### 6.2 自定义异常步骤
- 使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。
- 在程序中使用自定义异常类，大体可分为以下几个步骤。
    - （1）创建自定义异常类。
    - （2）在方法中通过throw关键字抛出异常对象。
    - （3）如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。
    - （4）在出现异常方法的调用者中捕获并处理异常。


#### 6.3 举一个案例说明
- 自定义异常如下所示：
    ```
    class MyException extends Exception{
    	public MyException(){
    		
    	}
    	public MyException(String msg){
    		super(msg);
    	}
    }
    
    public class FullConstructors {
    	public static void f() throws MyException {
    		System.out.println("Throwing myException from f()");
    		throw new MyException();
    	}
    	public static void g() throws MyException{
    		System.out.println("Throwing myException from g()");
    		throw new MyException("Originated in g()");
    	}
    	public static void main(String[] args) {
    		try{
    			f();
    		}catch(MyException e){
    			e.printStackTrace();
    		}
    		try{
    			g();
    		}catch(MyException e){
    			e.printStackTrace(System.out);
    		}
    	}
    }
    ```
- 在带参数的异常构造器中，显示的调用了其基类的带参构造方法。在catch块的异常处理程序中，调用了在Throwable类（所有异常的基类）声明的printStackTrace方法，该方法如果不带参数则将异常信息也就是从方法调用处到异常产生出的所有方法调用信息打印到标准错误流上，如果带了标准输出流参数，则打印在标准输出流上。区别可以从控制台错误信息的眼神看出。标准错误流更加的引人注目。




### 07.异常的限制说明
- 在覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。-->这个限制意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作（包括异常也能工作）。针对构造器以及继承或实现的方法有几点：
- 异常限制对构造器不起作用，构造器可以抛出任何异常，而不必理会基类构造器所抛出的异常。
- 然而基类构造器必须以这样或那样的方式被调用（这里默认构造器将自动被调用）后，派生类构造器的异常说明就必须包含基类构造器的异常说明。
- 派生类构造器不能捕获基类构造器抛出的异常（意味着只能抛出）。通过强制派生类遵守基类方法的异常说明，对象的可替换性得到了保证。
- 派生类的方法可以选择不抛出任何异常，即使它是基类所定义的异常。
- 使用派生类时，编译器只会强制要求捕获该派生类所抛出的异常；但是如果将其向上转型，那么编译器就会要求捕获基类抛出的异常。
- 异常说明本身不属于方法类型的一部分，方法类型是由方法的名字与参数的类型组成的。因此不能基于异常说明来重载方法。
- 一个出现在基类方法的异常说明中的异常，不一定会出现在炮声类方法的异常说明里。与继承中，基类的方法必须出现在派生类里的这种方法相比较，在继承和覆盖的过程中，某个特定方法的“异常说明的接口”是变小了的，与类方法的继承正好相反。




### 08.异常构造器介绍
- 对于构造器被调用时产生的异常，如果简单的使用try...catch...finally结构来处理异常，容易丢失掉异常，并且不能完成finally 内的代码逻辑，或是在不希望的情况下去完成了finally下的逻辑。对于这种情况，需要再用一层 try...catch 来捕获这个容易丢失的异常。
- 如下：
    ```
    public static void main(String[] args) {
        try {
            InputFile in = new InputFile("Cleanup.java");
            try {
                String s;
                int i = 1;
                while ((s = in.getLine()) != null) {
                    // Perform line-by-line processing here...
                }
            } catch (Exception e) {
                System.out.println("Caught Exception in main");
                e.printStackTrace(System.out);
            } finally {
                in.dispose();
            }
        } catch (Exception e) {
            System.out.println("InputFile construction failed");
        }
    }
    ```
- 在构造之后以及创建一个新的 try 块，将构造与其他可能抛出异常的逻辑区分开，这样不会让 finally 内的逻辑被意外执行。这种方式的基本规则是，在创建需要清理的对象之后，立即进入一个 try...finally 语句块。总之在创建构造器的时候，如果容易产生异常，应该仔细考虑如何处理构造器的异常。




### 09.异常链说明
#### 9.1 什么是异常链
- 常常会想要在捕获一个异常后抛出另一个异常,并且希望把原始异常的信息保存下来,这被称为异常链。在JDK1.4以前,程序员必须自己编写代码来保存原始异常的信息。现在所有Throwable的子类在构造器中都可以接受一个 cause(因由)对象作为参数。这个cause就用来表示原始异常,这样通过把原始异常传递给新的异常,使得即使在当前位置创建并抛出了新的异常,也能通过这个异常链追踪到异常最初发生的位置。
- 有趣的是,在 Throwable的子类中,只有三种基本的异常类提供了带caue参数的构造器。它们是Error(用于Java虚拟机报告系统错误)、 Exception以及 Runtimeexception。如果要把其他类型的异常链接起来,应该使用 initCause方法而不是构造器。



#### 9.2 链式异常
- 链式异常用于为异常关联另一个异常，第二个异常用于描述当前异常产生的原因。
    - 例如，某个方法从文件读取数值来作为除法运算的除数，由于发生了I/O错误导致获取到的数值是0，从而导致了ArithmeticException异常。
    - 如果想要让代码调用者知道背后的原因是I/O错误，使用链式异常就可以来处理这种情况以及其他存在多层异常的情况。
- 为了使用链式异常，Throwable有两个构造函数和两个方法用于处理这种情况。两个构造函数：
    ```
    Throwable(Throwable cause)
    Throwable(String message, Throwable cause)
    ```
- cause即是用于指定引发当前异常的背后原因，message则可以用于同时指定异常描述。两个方法：
    ```
    Throwable getCause()
    Throwable initCause(Throwable cause)
    getCause() 方法用来返回引发当前异常的异常，如果不存在背后异常则返回null。
    initCause(Throwable cause)方法将cause和明面上的异常关联到一起，并返回对异常的引用。因此可以在创建异常之后将异常和背后异常关联到一起。但是，背后异常只能设置一次，即initCause(Throwablecause)方法只能调用一次。此外，如果通过构造函数设置了背后异常，也不能再使用该方法来设置背后异常了。
    ```
- 案例展示
    - 例如，参照如下代码：
    ```
    public class Demo {
    	
    	public static void demo(){
    		NullPointerException nullPointerException=new NullPointerException("nullPointer");
    		nullPointerException.initCause(new ArithmeticException("Arithmetic"));
    		throw nullPointerException;
    	}
    
    	public static void main(String[] args) {
    		try {
    			demo();
    		} catch (Exception e) {
    			System.out.println(e.getMessage());
    			System.out.println(e.getCause().getMessage());
    		}
    	}
    }
    ```
- 运行结果是：[博客](https://github.com/yangchong211/YCBlogs)
    ```
    nullPointer
    Arithmetic
    ```
- 链式异常可以包含所需要的任意深度，但是，过长的异常链可能是一种不良的设计。








