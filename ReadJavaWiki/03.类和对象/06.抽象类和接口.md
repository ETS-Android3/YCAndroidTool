#### 目录介绍
- 01.为何需要抽象类
- 02.抽象类特点
- 03.抽象类可以new吗
- 04.抽象类设计注意要点
- 03.抽象类名作为形参




### 01.什么是接口
- 接口（Interface）在Java语言中是一个抽象类型，是服务提供者和服务使用者之间的一个协议，在JDK1.8之前一直是抽象方法的集合，一个类通过实现接口从而来实现两者间的协议
- 接口可以定义字段和方法。在JDK1.8之前，接口中所有的方法都是抽象的，从JDK1.8开始，也可以在接口中编写默认的和静态的方法。除非显式指定，否则接口方法都是抽象的



### 02.接口特点
- 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。
- 接口的特点有哪些呢？
    - 接口没有构造方法
    - 接口不能用于实例化对象
    - 接口中的字段必须初始化，并且隐式地设置为公有的、静态的和final的。因此，为了符合规范，接口中的字段名要全部大写
    - 接口不是被类继承，而是要被类实现
    - 接口中每一个方法默认是公有和抽象的，即接口中的方法会被隐式的指定为 **public abstract**。从JDK 1.8开始，可以在接口中编写默认的和静态的方法。声明默认方法需要使用关键字**default**。并且不允许定义为 private 或者 protected。
    - 当类实现接口时，类要实现接口中所有的方法。否则，类必须声明为抽象的
    - 接口支持多重继承，即可以继承多个接口



### 03.看一个接口案例代码
- 代码如下所示
    ```
    public interface Name {
        
        //接口中的变量其实就是常量，默认被final修饰
        int age = 10;
    
    	String getName();
    	// 等价于以下三种形式
    	// public String getName();
    	// public abstract String getName();
    	// abstract String getName();
    
    	// 静态方法，可以省略public声明，因为在接口中的静态方法默认就是公有的
    	public static void setName(String name) {
    		// 实现具体业务
    	}
    	
    	// 默认方法
        default void defaultMethod(){
    		// 实现具体业务
    		System.out.println("defaultMethod");
    	}
    
    }
    ```





### 04.Marker Interface
- 接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。
- 有一类没有任何方法的接口，通常叫作 Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的 Cloneable、Serializable 等。这种用法，也存在于业界其他的 Java 产品代码中。




### 05.Java 8接口变化
- 从 Java 8 开始，interface 增加了对 default method 的支持。Java 9 以后，甚至可以定义 private default method。Default method 提供了一种二进制兼容的扩展已有接口的办法。比如，我们熟知的 java.util.Collection，它是 collection 体系的 root interface，在 Java 8 中添加了一系列 default method，主要是增加 Lambda、Stream 相关的功能。
    ```
    public interface Collection<E> extends Iterable<E> {
         default Stream<E> stream() {
             return StreamSupport.stream(spliterator(), false);
         }
    }
    ```



### 01.为何需要抽象类
- 在面向对象的概念中，所有的对象都是通过类来描绘的。但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类（Abstract）。



### 02.抽象类特点
- 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
    - 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。
    - 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。其目的主要是代码重用。
    - 抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。
    ```
    public abstract class AbstractClassExample {
    
        protected int x;
        private int y;
    
        public abstract void func1();
    
        public void func2() {
            System.out.println("func2");
        }
    }
    
    public class AbstractExtendClassExample extends AbstractClassExample {
        @Override
        public void func1() {
            System.out.println("func1");
        }
    }
    ```



### 03.抽象类可以new吗
- 注意抽象类是不能被实例化的，也就是不能new出来的！
    - 如果执意需要new，则会提示
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-7519b80e53e22ea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




### 04.抽象类设计注意要点
- 如果想要设计这样一个类，该类包含一个特别的成员方法，方法的具体实现由它的子类确定，那么可以在父类中声明该方法为抽象方法
- Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。声明抽象方法会造成以下两个结果：
    - 如果一个类包含抽象方法，则该类必须声明为抽象类
    - 子类必须重写父类的抽象方法，否则自身也必须声明为抽象类




### 05.抽象类名作为形参
- 案例
    ```
    /*抽象类作为参数的时候如何进行调用*/
    abstract class Animal {
        // 定义一个抽象方法
        public abstract void eat() ;
    }
    
    // 定义一个类
    class Cat extends Animal {
        public void eat(){
            System.out.println("吃.................") ;
        }
    }
    
    
    // 定义一个类
    class AnimalDemo {
        public void method(Animal a) {
            a.eat() ;
        }
    }
    
    // 测试类
    class ArgsDemo2  {
        public static void main(String[] args) {
            // 创建AnimalDemo的对象
            AnimalDemo ad = new AnimalDemo() ;
            // 对Animal进行间接实例化
            // Animal a = new Cat() ;
            Cat a = new Cat() ;
            // 调用method方法
            ad.method(a) ;
        }
    }
    ```




### 01.理解抽象和接口概念
- abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 
- abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，避免使用时在进行抽象类定义时对于 abstract class和interface的选择随意。
- 其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。



### 02.抽象和接口语法上不同
- 抽象类
   ```
   abstract class Student ｛    
       abstract void method1();    
       abstract void method2();    
   ｝    
   ```
- 接口
   ```
   interface Student {    
       void method1();    
       void method2();    
   }    
   ```
- 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。




### 03.抽象和接口编程角度不同
- abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。
- 其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用`default`关键字实现默认方法。
    ```
    interface InterfaceA {
        default void foo() {
            System.out.println("InterfaceA foo");
        }
    }
    ```
- 在 Java 8 之前，接口与其实现类之间的 **耦合度** 太高了（**tightly coupled**），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为Java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。




### 04.通俗理解两者区别
- 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是 **“like-a”** 关系，抽象类反映的是 **“is-a”** 关系。
- 抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。
- 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.
- 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。





### 05.抽象类与接口的区别
#### 5.1 区别
- 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
    - 1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
    - 2.抽象类要被子类继承，接口要被类实现。
    - 3.接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
    - 4.抽象类里可以没有抽象方法。
    - 5.从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类，抽象类只能被单继承。
    - 6.接口中没有 `this` 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。
    - 7.抽象类不能在Java 8 的 lambda 表达式中使用。
    - 8.接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。
    - 9.接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 语法层次
    ```
    public abstract class People {  //关键词abstract，声明该类为抽象类
        void Num();　　　　　　
        abstract void Name(); 　　　//声明该方法为抽象方法
    }
     
    Interface Person {
    　　void Num();
    　　void Name();
    }　
    ```
    * 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，
    * 但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。
    * 在某种程度上来说，接口是抽象类的特殊化。
    * 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。
- 设计层次
    - 抽象层次不同
        - 抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
    - 跨域不同
        - 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。
    - 设计层次不同
        * 对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！
        * 但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。
- 语法规范区别：
    - 1）接口不能有构造方法，抽象类可以有。
    - 2）接口不能有方法体，抽象类可以有。
    - 3）接口不能有静态方法，抽象类可以有。
    - 4）在接口中凡是变量必须是public static final，而在抽象类中没有要求。 



#### 5.2 如何选择
- 使用接口：
    - 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
    - 需要使用多重继承。
- 使用抽象类：
    - 需要在几个相关的类中共享代码。
    - 需要能控制继承来的成员的访问权限，而不是都为 public。
    - 需要继承非静态和非常量字段。



### 07.面向对象之类名作为返回值类型
- 案例
    ```
    /*具体类作为返回值类型*/
    class Student {
        public void show() {
            System.out.println("student....show.....................") ;
        }
    }
    
    // 定义一个类
    class StudentDemo {
        public Student getStudent() {
            return new Student() ;
        }
    }
    
    // 测试类
    class ReturnDemo {
        public static void main(String[] args) {
            // 创建StudentDemo的对象
            StudentDemo sd = new StudentDemo() ;
            // 调用 public Student getStudent()
            Student s = sd.getStudent() ;
            // 调用方法
            s.show() ;
        }
    }
    ```


### 08.面向对象之抽象类名作为返回值类型
- 案例
    ```
    /*抽象类作为返回值类型*/
    abstract class Animal {
        public abstract void eat() ;
    }
    
    // 定义一个子类
    class Cat extends Animal {
        public void eat(){
            System.out.println("吃..........................") ;
        }
    }
    
    // 定义一个类
    class AnimalDemo {
        public static Animal getAnimal() {   
            // Animal a = new Cat() ;
            // return a;
            return new Cat() ;
        }   
    }
    
    // 测试类
    class ReturnDemo2  {
        public static void main(String[] args) {
            // 调用AnimalDemo的getAnimal这个方法
            Animal a =  AnimalDemo.getAnimal() ;
            // 调用方法
            a.eat() ;
        }
    }
    ```


### 09.面向对象之接口名作为返回值类型
- 案例
    ```
    /*接口作为返回值类型*/
    interface Jump {
        public abstract void jump() ;
    }
    
    // 定义一个子类
    class JumpImpl implements Jump {
        public void jump(){
            System.out.println("jum....................") ;
        }
    }
    
    // 定义一个类
    class JumpDemo {
        public static Jump getJump() {
            return new JumpImpl() ;
        }
    }
    
    // 测试类
    class ReturnDemo3  {
        public static void main(String[] args) {
            // 调用getJump方法
            Jump jump = JumpDemo.getJump() ;
            // 调用
            jump.jump() ;
        }
    }
    ```




### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e














### 关于其他内容介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
