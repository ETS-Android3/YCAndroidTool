#### 目录介绍
- 01.什么是复用
- 02.组合
- 03.结合组合与继承
- 04.组合与继承的选择






### 01.什么是复用
- 对于像 C 语言等面向过程语言来说，“复用”通常指的就是“复制代码”。任何语言都可通过简单复制来达到代码复用的目的，但是这样做的效果并不好。Java 围绕“类”（Class）来解决问题。我们可以直接使用别人构建或调试过的代码，而非创建新类、重新开始。
- 如何在不污染源代码的前提下使用现存代码是需要技巧的。在本章里，你将学习到两种方式来达到这个目的：
- 第一种方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”（Composition），通过这种方式复用代码的功能，而非其形式。
- 第二种方式更为微妙。创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。



### 02.组合
- 你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。例如，假设你需要一个对象，其中内置了几个 String 对象，两个基本类型（primitives）的属性字段，一个其他类的对象。对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。
    ```
    class WaterSource {
      private String s;
      WaterSource() {
        System.out.println("WaterSource()");
        s = "Constructed";
      }
      @Override
      public String toString() { return s; }
    }
    
    public class SprinklerSystem {
      private String valve1, valve2, valve3, valve4;
      private WaterSource source = new WaterSource();
      private int i;
      private float f;
      @Override
      public String toString() {
        return
          "valve1 = " + valve1 + " " +
          "valve2 = " + valve2 + " " +
          "valve3 = " + valve3 + " " +
          "valve4 = " + valve4 + "\n" +
          "i = " + i + " " + "f = " + f + " " +
          "source = " + source; // [1]
      }
      public static void main(String[] args) {
        SprinklerSystem sprinklers = new SprinklerSystem();
        System.out.println(sprinklers);
      }
    }
    ```
- 这两个类中定义的一个方法是特殊的:  toString()。每个非基本类型对象都有一个 toString() 方法，在编译器需要字符串但它有对象的特殊情况下调用该方法。因此，在 [1] 中，编译器看到你试图“添加”一个 WaterSource 类型的字符串对象 。因为字符串只能拼接另一个字符串，所以它就先会调用 toString() 将 source 转换成一个字符串。然后，它可以拼接这两个字符串并将结果字符串传递给 System.out.println()。要对创建的任何类允许这种行为，只需要编写一个 toString() 方法。在 toString() 上使用 @Override 注释来告诉编译器，以确保正确地覆盖。@Override 是可选的，但它有助于验证你没有拼写错误 (或者更微妙地说，大小写字母输入错误)。类中的基本类型字段自动初始化为零，正如 object Everywhere 一章中所述。但是对象引用被初始化为 null，如果你尝试调用其任何一个方法，你将得到一个异常（一个运行时错误）。方便的是，打印 null 引用却不会得到异常。
- 编译器不会为每个引用创建一个默认对象，这是有意义的，因为在许多情况下，这会导致不必要的开销。初始化引用有四种方法:
    - 当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
    - 在该类的构造函数中。
    - 在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
    - 使用实例初始化。
- 以上四种实例创建的方法例子在这：
    ```
    class Soap {
      private String s;
      Soap() {
        System.out.println("Soap()");
        s = "Constructed";
      }
      @Override
      public String toString() { return s; }
    }
    
    public class Bath {
      private String // Initializing at point of definition:
        s1 = "Happy",
        s2 = "Happy",
        s3, s4;
      private Soap castille;
      private int i;
      private float toy;
      public Bath() {
        System.out.println("Inside Bath()");
        s3 = "Joy";
        toy = 3.14f;
        castille = new Soap();
      }
      // Instance initialization:
      { i = 47; }
      @Override
      public String toString() {
        if(s4 == null) // Delayed initialization:
          s4 = "Joy";
        return
          "s1 = " + s1 + "\n" +
          "s2 = " + s2 + "\n" +
          "s3 = " + s3 + "\n" +
          "s4 = " + s4 + "\n" +
          "i = " + i + "\n" +
          "toy = " + toy + "\n" +
          "castille = " + castille;
      }
      public static void main(String[] args) {
        Bath b = new Bath();
        System.out.println(b);
      }
    }
    /* Output:
    Inside Bath()
    Soap()
    s1 = Happy
    s2 = Happy
    s3 = Joy
    s4 = Joy
    i = 47
    toy = 3.14
    castille = Constructed
    */
    ```
- 在 Bath 构造函数中，有一个代码块在所有初始化发生前就已经执行了。当你不在定义处初始化时，仍然不能保证在向对象引用发送消息之前执行任何初始化——如果你试图对未初始化的引用调用方法，则未初始化的引用将产生运行时异常。
- 当调用 toString() 时，它将赋值 s4，以便在使用字段的时候所有的属性都已被初始化。


### 03.结合组合与继承
- 你将经常同时使用组合和继承。下面的例子展示了使用继承和组合创建类，以及必要的构造函数初始化:
    ```
    class Plate {
      Plate(int i) {
        System.out.println("Plate constructor");
      }
    }
    
    class DinnerPlate extends Plate {
      DinnerPlate(int i) {
        super(i);
        System.out.println("DinnerPlate constructor");
      }
    }
    
    class Utensil {
      Utensil(int i) {
        System.out.println("Utensil constructor");
      }
    }
    
    class Spoon extends Utensil {
      Spoon(int i) {
        super(i);
        System.out.println("Spoon constructor");
      }
    }
    
    class Fork extends Utensil {
      Fork(int i) {
        super(i);
        System.out.println("Fork constructor");
      }
    }
    
    class Knife extends Utensil {
      Knife(int i) {
        super(i);
        System.out.println("Knife constructor");
      }
    }
    
    // A cultural way of doing something:
    class Custom {
      Custom(int i) {
        System.out.println("Custom constructor");
      }
    }
    
    public class PlaceSetting extends Custom {
      private Spoon sp;
      private Fork frk;
      private Knife kn;
      private DinnerPlate pl;
      public PlaceSetting(int i) {
        super(i + 1);
        sp = new Spoon(i + 2);
        frk = new Fork(i + 3);
        kn = new Knife(i + 4);
        pl = new DinnerPlate(i + 5);
        System.out.println("PlaceSetting constructor");
      }
      public static void main(String[] args) {
        PlaceSetting x = new PlaceSetting(9);
      }
    }
    /* Output:
    Custom constructor
    Utensil constructor
    Spoon constructor
    Utensil constructor
    Fork constructor
    Utensil constructor
    Knife constructor
    Plate constructor
    DinnerPlate constructor
    PlaceSetting constructor
    */
    ```
- 尽管编译器强制你初始化基类，并要求你在构造函数的开头就初始化基类，但它并不监视你以确保你初始化了成员对象。注意类是如何干净地分离的。你甚至不需要方法重用代码的源代码。你最多只导入一个包。(这对于继承和组合都是正确的。)




### 04.组合与继承的选择
- 组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。你或许想知道这二者之间的区别，以及怎样在二者间做选择。
- 当你想在新类中包含一个已有类的功能时，使用组合，而非继承。也就是说，在新类中嵌入一个对象（通常是私有的），以实现其功能。新类的使用者看到的是你所定义的新类的接口，而非嵌入对象的接口。
- 组合，下面的 car 对象是个很好的例子：
    ```
    class Engine {
        public void start() {}
        public void rev() {}
        public void stop() {}
    }
    
    class Wheel {
        public void inflate(int psi) {}
    }
    
    class Window {
        public void rollup() {}
        public void rolldown() {}
    }
    
    class Door {
        public Window window = new Window();
        
        public void open() {}
        public void close() {}
    }
    
    public class Car {
        public Engine engine = new Engine();
        public Wheel[] wheel = new Wheel[4];
        public Door left = new Door(), right = new Door(); // 2-door
        
        public Car() {
            for (int i = 0; i < 4; i++) {
                wheel[i] = new Wheel();
            }
        }
        
        public static void main(String[] args) {
            Car car = new Car();
            car.left.window.rollup();
            car.wheel[0].inflate(72);
        }
    }
    ```
- 因为在这个例子中 car的组合也是问题分析的一部分（不是底层设计的部分），所以声明成员为 public 有助于客户端程序员理解如何使用类，且降低了类创建者面临的代码复杂度。但是，记住这是一个特例。通常来说，属性还是应该声明为 private。
- 当使用继承时，使用一个现有类并开发出它的新版本。通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化。稍微思考下，你就会发现，用一个交通工具对象来组成一部车是毫无意义的——车不包含交通工具，它就是交通工具。这种“是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达。


