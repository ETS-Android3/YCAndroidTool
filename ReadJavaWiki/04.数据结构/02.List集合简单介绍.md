### 目录介绍
- 01.ArrayList
- 02.Vector
- 03.LinkedList
- 04.选择合适list
- 05.list集合读写
- 06.list集合删除
- 07.list集合遍历性能


### 好消息
- 博客笔记大汇总【16年3月到至今】，包括Java基础及深入知识点，Android技术博客，Python学习笔记等等，还包括平时开发中遇到的bug汇总，当然也在工作之余收集了大量的面试题，长期更新维护并且修正，持续完善……开源的文件是markdown格式的！同时也开源了生活博客，从12年起，积累共计N篇[近100万字，陆续搬到网上]，转载请注明出处，谢谢！
- **链接地址：https://github.com/yangchong211/YCBlogs**
- 如果觉得好，可以star一下，谢谢！当然也欢迎提出建议，万事起于忽微，量变引起质变！




### 01.ArrayList
#### 1.1 ArrayList集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：线程不安全
- 【底层数据结构】：底层由数组实现（顺序表），因为由顺序表实现，所以会具备顺序表的特点，如：需要声明长度、超出长度时需要进行扩容、不适合频繁的移动删除元素、检索元素快；





### 02.Vector
#### 2.1 Vectot集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：Vector通过synchronized方法保证线程安全；
- 【底层数据结构】：底层由动态数组实现，特点和ArrayList一样，是一样而不是类似。查询快 , 增删慢
- 常用方法
	* public void addElement(E obj)        添加元素
	* public E elementAt(int index)        根据索引获取元素
	* public Enumeration elements()        使用类似于迭代器 , 作用: 用来遍历Vector集合
- 遍历
    ```
    Enumeration enumeration = vector.elements() ;
    // boolean hasMoreElements(): 判断集合中是否存在下一个元素
    // E nextElement(): 获取下一个元素
    while(enumeration.hasMoreElements()) {
        System.out.println(enumeration.nextElement());
    }
    ```



### 03.LinkedList
#### 3.1 LinkedList集合特点
- 【支持类型】：只能装入引用对象（基本类型要转换为封装类）
- 【线程是否安全】：线程不安全
- 【底层数据结构】：底层实现为链表，具备链表的特点，如：不用声明长度、检索性能较差，但是插入移动删除较快。链表通过Node对象实现



### 04.选择合适list
#### 4.1 如何选择合适list
- 对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList。
- LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。
- 对于Vector而已，我们一般都是避免使用。（ArrayList可用通过Collections中的方法转换为线程安全类）
- 将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。



### 05.list集合读写
#### 5.1 不同容器类型适合的场景
- Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。
- 而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。



#### 5.2 list集合读写机制和读写效率
- **读写机制**
    - ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作；在删除元素时并不会减少数组的容量（如果需要缩小数组容量，可以调用trimToSize()方法）；在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。
    - LinkedList在插入元素时，须创建一个新的Entry对象，并更新相应元素的前后元素的引用；在查找元素时，需遍历链表；在删除元素时，要遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。
    - Vector与ArrayList仅在插入元素时容量扩充机制不一致。对于Vector，默认创建一个大小为10的Object数组，并将capacityIncrement设置为0；当插入元素数组大小不够时，如果capacityIncrement大于0，则将Object数组的大小扩大为现有size+capacityIncrement；如果capacityIncrement<=0,则将Object数组的大小扩大为现有大小的2倍。
- **读写效率**
    - ArrayList对元素的增加和删除都会引起数组的内存分配空间动态发生变化。因此，对其进行插入和删除速度较慢，但检索速度很快。
    - LinkedList由于基于链表方式存放数据，增加和删除元素的速度较快，但是检索速度较慢。


### 06.list集合删除
- 使用普通for循环删除元素
    ```java
    public static void main(String[] args){  
        List<Integer> list = new ArrayList<>();  
        for (int i = 0; i < 5; i++)  {
            list.add(i);  
        }
        for (int i = 0; i < list.size(); i++) {  
             list.remove(i);  
        } 
        for (int i = 0; i < list.size(); i++) {  
             System.out.println(list.get(i)); 
        } 
        int size = list.size();
        for (int i=0 ; i<size; i++) {
        	list.remove(i);
        }
    }  
    ```
    - 希望通过list.remove(index)方式删除所有元素。但结果显示只删除了部分元素。删除元素后，会该变其它元素的index下标 以及整个list的Size大小
- 通过增强for循环删除元素
    ```
    public static void main(String[] args)
    {  
    	List<Integer> list = new ArrayList<>();  
            for (int i = 0; i < 5; i++)  
                list.add(i);  
            for (Integer num : list) 
                if (num % 2 == 0) 
                   list.remove(num);  
     
    }  
    ```
    - 运行时直接出现ConcurrentModificationException异常。
    - 原因分析： 增强for循环内部采用 Iterator迭代器进行遍历
        - fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。
- 在单线程环境下的解决办法
    - 其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法：
    - 在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作：expectedModCount = modCount;
    ``` java
    public void remove() {
        if (lastRet == -1)
        throw new IllegalStateException();
           checkForComodification();
     
        try {
        AbstractList.this.remove(lastRet);
        if (lastRet < cursor)
            cursor--;
        lastRet = -1;
        expectedModCount = modCount;
        } catch (IndexOutOfBoundsException e) {
        throw new ConcurrentModificationException();
        }
    }
    ```
- Iterator迭代器移除元素
    - Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 
    - Iterator被创建之后会建立一个指向原来对象的单链索引表（副本），当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。
    ```java
    public class List_test {
    	public static void main(String[] args)
    	{  
    		List<Integer> list = new ArrayList<>();  
    	        for (int i = 0; i < 5; i++)  
    	            list.add(i);  
    	        Iterator<Integer> it=list.iterator();
    	        while(it.hasNext())
    	        {
    	        	if(it.next()%2==0)
    	        		it.remove();
    	        }
    	        
    	 }  
    }  
    ```
    - Iterator迭代器可以认为是一个由头指针开始的访问指针，即使删除元素，依旧保持勾连状态，可以正确删除List中元素。
- 在多线程环境下的解决方法
    - 有可能有朋友说ArrayList是非线程安全的容器，换成Vector就没问题了，实际上换成Vector还是会出现这种错误。
    - 原因在于，虽然Vector的方法采用了synchronized进行了同步，但是实际上通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也即是说expectedModCount是每个线程私有。假若此时有2个线程，线程1在进行遍历，线程2在进行修改，那么很有可能导致线程2修改后导致Vector中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增，此时线程1遍历时就会出现expectedModCount不等于modCount的情况了。
    - 因此一般有2种解决办法：
        - 1）在使用iterator迭代的时候使用synchronized或者Lock进行同步；
        - 2）使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。




### 07.list集合遍历性能
- 经常使用的 LinkedList 集合，如果使用 for 循环遍历该容器，将大大降低读的效率，但这种效率的降低很难导致系统性能参数异常。
- 这时有经验的同学，就会改用 Iterator （迭代器）迭代循环该集合，这是因为 LinkedList 是链表实现的，如果使用 for 循环获取元素，在每次循环获取元素时，都会去遍历一次 List，这样会降低读的效率。



### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e


