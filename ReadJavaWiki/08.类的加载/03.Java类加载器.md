#### 目录介绍
- 01.类加载器分类
    * 1.1 类加载器的概述
    * 1.2 类加载器的分类
    * 1.3 类加载器的作用
- 02.类加载器工作机制
    - 2.1 类的加载定义
    - 2.2 类加载器工作机制




### 01.类加载器分类
#### 1.1 类加载器的概述
- 什么是类加载
    - 负责读取 Java 字节代码，将.class文件加载到内存中，并转换成java.lang.Class类的一个实例对象；
- 那么有人会问.class文件是哪里来的
    - 它是由javac编译器将java文件编译成.class文件的。




#### 1.2 类加载器的分类
- Bootstrap ClassLoader 根类加载器(引导类加载器)
- Extension ClassLoader 扩展类加载器
- System ClassLoader    系统类加载器
- Application ClassLoader   应用程序类加载器




#### 1.3 类加载器的作用
- 1.3.1 Bootstrap ClassLoader 根类加载器
    - 也被称为引导类加载器，负责Java核心类的加载；比如System,String等。在JDK中JRE的lib目录下rt.jar文件中
    - 由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。
- 1.3.2 Extension ClassLoader 扩展类加载器
    - 负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录
- 1.3.3 Sysetm ClassLoader 系统类加载器
    - 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径
- 1.3.4 Application ClassLoader
    - 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。



### 02.类加载器工作机制
#### 2.1 类的加载定义
- 类进行初始化
    - 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。
- 更加详细一点说，类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
- 在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。



#### 2.2 类加载器工作机制
- 是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型的过程。另外，类型的加载、连接和初始化过程都是在程序运行期完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。下面介绍类加载每个阶段的任务： 
    - 加载（Loading）：通过类的全限定名来获取定义此类的二进制字节流；将该二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构，该数据存储数据结构由虚拟机实现自行定义；在内存中生成一个代表这个类的java.lang.Class对象，它将作为程序访问方法区中的这些类型数据的外部接口
    - 验证（Verification）：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，包括文件格式验证、元数据验证、字节码验证和符号引用验证
    - 准备（Preparation）：为类变量分配内存，因为这里的变量是由方法区分配内存的，所以仅包括类变量而不包括实例变量，后者将会在对象实例化时随着对象一起分配在Java堆中；设置类变量初始值，通常情况下零值
    - 解析（Resolution）：虚拟机将常量池内的符号引用替换为直接引用的过程
    - 初始化（Initialization）：是类加载过程的最后一步，会开始真正执行类中定义的Java字节码。而之前的类加载过程中，除了在『加载』阶段用户应用程序可通过自定义类加载器参与之外，其余阶段均由虚拟机主导和控制







### 01.分类说明
- 系统类加载器
    - BootClassLoader：**预加载常用类**，由 Java 实现，继承 ClassLoader
    - PathClassLoader：**加载系统类和应用程序的类**，继承 BaseDexClassLoader，没有参数 optimizedDirectory（给了默认 /data/dalvik-cache）无法定义解压的 dex 文件存储路径，常用来加载已经安装 apk 的 dex 文件（/data/dalvik-cache）
    - DexClassLoader：加载 dex 文件以及包含 dex 的压缩文件（apk 和 jar 文件），继承 BaseDexClassLoader，
- 自定义加载器
    - 自定义加载器，通过继承ClassLoader实现，一般是加载我们的自定义类

- 类加载器种类？
    - 启动类加载器，Bootstrap ClassLoader，加载JACA_HOME\lib，或者被-Xbootclasspath参数限定的类
    - 扩展类加载器，Extension ClassLoader，加载\lib\ext，或者被java.ext.dirs系统变量指定的类
    - 应用程序类加载器，Application ClassLoader，加载ClassPath中的类库
    - 自定义类加载器，通过继承ClassLoader实现，一般是加载我们的自定义类


### 02.其他的类
* ClassLoader：抽象类，定义一些主要功能，BootClassLoader 是它的内部类
* SecureClassLoader：拓展 CLassLoader 类加入权限方面的功能，加强了 ClassLoader 的安全性
* URLClassLoader：继承 SecureClassLoader ，通过 URL路径从 jar 文件和文件夹中加载类和资源
* InMemoryDexClassLoader：加载内存中的 dex 文件
* BaseDexClassLoader：继承自 ClassLoader，是抽象类 ClassLoader 的具体实现类



### 03.ClasLoader加载过程
- 和 Java 一样都遵循双亲委托机制。
    ```java
    protected Class<?> loadClass(String name, boolean resolve) 
        throws ClassNotFoundException {
            //检测是否已经加载过,若加载过，则直接返回
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        //调用父类的loadClass
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                   
                }
    
                if (c == null) {
                    //还是未找到，使用 findClass 在当前 dex 查找
                    c = findClass(name);
                }
            }
            return c;
    }
    
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);//需要子类去实现 BaseDexClassLoader
    }
    ```
- BaseDexClassLoader#findClass
    ```java
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
        //pathList类型为 DexPathList 保存 dexfile 文件的句柄等 dex 的操作
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ...
            throw cnfe;
        }
        return c;
    }
    ```
- DexPathList#findClass
    ```java
    public Class<?> findClass(String name, List<Throwable> suppressed) {
       //Element 内部封装 DexFile 用于加载 dex
       for (Element element : dexElements) {
           Class<?> clazz = element.findClass(name, definingContext, suppressed);
           if (clazz != null) {
               return clazz;
           }
       }
       ...
       return null;
    }
    ```
- Element#findClass
    ```java
    public Class<?> findClass(String name, ClassLoader definingContext,
            List<Throwable> suppressed) {
        //dexFile.loadClassBinaryName
        return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null;
    }
    ```
- DexFile#loadClassBinaryName
    ```java
    public Class loadClassBinaryName(String name, ClassLoader loader, List<Throwable> suppressed) {
        return defineClass(name, loader, mCookie, this, suppressed);
    }
    
    private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                     DexFile dexFile, List<Throwable> suppressed) {
        Class result = null;
        try {
            //加载 dex 文件
            result = defineClassNative(name, loader, cookie, dexFile);
        } 
        ...
        return result;
    }
    
    // 调用 Native 层代码
    private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile)
    ```



### 01.Classloader作用
- Classloader的作用，概括来说就是将编译后的class装载、加载到机器内存中，为了以后的程序的执行提供前提条件。
- 每个被ClassLoader加载的class文件，最终都会以Class类的实例被程序员引用，我们可以把Class类当作是普通类的一个模板，JVM根据这个模板生成对应的实例，最终被程序员所使用。



### 02.loadClass分析
- 源码代码如下所示。
    ```
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
    
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
    ```
- 关于loadClass方法
    ```
    Class<?> loadClass(String name)
    Class<?> loadClass(String name, boolean resolve)
    ```
    - 看到上面两个方法声明，第二个方法的第二个参数是用于设置加载类的时候是否连接该类，true就连接，否则就不连接。
    - 说到连接，不得不在此做一下解释，在JVM加载类的时候，需要经过三个步骤，装载、连接、初始化（切记这里的初始化是类的初始化，可不是new对象）。装载就是找到相应的class文件，读入JVM，初始化就不用说了（见下一篇博文），最主要就说说连接。
    - 连接分三步，第一步是验证class是否符合规格，第二步是准备，就是为类变量分配内存同时设置默认初始值，第三步就是解释，而这步就是可选的，根据上面loadClass方法的第二个参数来判定是否需要解释，所谓的解释根据《深入JVM》这本书的定义就是根据类中的符号引用查找相应的实体，再把符号引用替换成一个直接引用的过程。
- resolve参数为false含义
    - 再来看看那个两个参数的loadClass方法，该方法的定义是protected，那也就是说该方法是被保护的，而用户真正应该使用的方法是一个参数的那个，一个参数的loadclass方法实际上就是调用了两个参数的方法，而第二个参数默认为false，因此在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类进行解释，因此也不会初始化该类。
- 看一个测试案例
    ``` java
    public class Main {
    	public static void main(String[] args) {
    		TestOrder tOrder = new TestOrder();	
    		try {
    			tOrder.getClass().getClassLoader().loadClass("com.yc.Test");
    		} catch (ClassNotFoundException e) {
    			e.printStackTrace();
    		}
    	}
    }
    
    public class Test {
        static {
            System.out.println("test静态代码段");
        }
    }
    ```
    - 不会输出"test静态代码段"的（静态代码块是跟初始化绑定的）。




### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yczbj/activities
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e



