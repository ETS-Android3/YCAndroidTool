#### 目录介绍
- 7.0.0.1 Java内存模型里包含什么？程序计数器的作用是什么？常量池的作用是什么？
- 7.0.0.2 什么是类加载器？类加载器工作机制是什么？类加载器种类？什么是双亲委派机制？
- 7.0.0.3 什么时候发生类初始化？类初始化后对类的做了什么，加载变量，常量，方法都内存那个位置？
- 7.0.0.4 通过下面一个代码案例理解类加载顺序？当遇到 类名.变量 加载时，只加载变量所在类吗？
- 7.0.0.5 看下面这段代码，说一下准备阶段和初始化阶段常量变化的原理？变量初始化过程？
- 7.0.0.7 说收垃圾回收机制？为什么引用计数器判定对象是否回收不可行？有哪些引用类型？
- 7.0.0.8 谈谈Java的类加载过程？加载做了什么？验证做了什么？准备做了什么？解析做了什么？初始化做了什么？
- 7.0.0.9 详细介绍一下什么是双亲委派机制？它的工作流程是什么？为何说具有不同优先级？代码实现双亲委派模型？







#### 7.0.0.3 什么时候发生类初始化？类初始化后对类的做了什么，加载变量，常量，方法都内存那个位置？
- 什么时候发生类初始化
    - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
        - 调用一个类型的静态方法时（即在字节码中执行invokestatic指令）
        - 调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式
    - 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
    - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    - 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例左后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄锁对应的类没有进行过初始化时。
- 类初始化后对类的做了什么[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 这个阶段主要是对类变量初始化，是执行类构造器的过程。
    - 换句话说，只对static修饰的变量或语句进行初始化。
    - 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
    - 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。




#### 7.0.0.5 看下面这段代码，说一下准备阶段和初始化阶段常量变化的原理？
- 看下面这段代码
    ```
    public static int value1  = 5;
    public static int value2  = 6;
    static{
        value2 = 66;
    }
    ```
- 准备阶段和初始化阶段常量变化？
    - 结果
        - 在准备阶段value1和value2都等于0；
        - 在初始化阶段value1和value2分别等于5和66；
- 变量初始化过程？
    - 所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法，该方法只能在类加载的过程中由JVM调用；
    - 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；
    - 如果超类还没有被初始化，那么优先对超类初始化，但在<clinit>方法内部不会显示调用超类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的超类<clinit>方法已经被执行。
    - JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。(所以可以利用静态内部类实现线程安全的单例模式)
    - 如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<clinit>方法；






#### 7.0.0.8 谈谈Java的类加载过程？加载做了什么？验证做了什么？准备做了什么？解析做了什么？初始化做了什么？
- Java文件从编码完成到最终执行过程
    - 编译：编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。
    - 运行：运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。
    - 举个通俗点的例子来说，JVM在执行某段代码时，遇到了classA，然而此时内存中并没有classA的相关信息，于是JVM就会到相应的class文件中去寻找classA的类信息，并加载进内存中，这就是我们所说的类加载过程。
- 谈谈Java的类加载过程？
    - 类加载的过程主要分为三个部分：
    - 加载
    - 链接
        - 而链接又可以细分为三个小部分：
        - 验证
        - 准备
        - 解析
    - 初始化
- 加载做了什么？
    - 加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
        - 这里有两个重点：
        - 字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
        - 类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
    - 在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情：
        - 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
        - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
        - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
    - 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。
- 验证做了什么？[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    - 主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。
    - 包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？
    - 对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？
    - 对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。
    - 对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？
- 准备做了什么？
    - 主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。
    - 特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。
    - 比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static a = 123， 那么该阶段a的初值就是123
- 解析做了什么？
    - 将常量池内的符号引用替换为直接引用的过程。
    - 两个重点：
        - 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
        - 直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量
    - 举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。
    - 在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
- 初始化做了什么？
    - 这个阶段主要是对类变量初始化，是执行类构造器的过程。
    - 换句话说，只对static修饰的变量或语句进行初始化。
    - 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
    - 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。








### 其他介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
- 掘金：https://juejin.im/user/5939433efe88c2006afa0c6e










