#### 目录介绍
- 01.Classloader作用
- 02.loadClass分析



### 01.Classloader作用
- Classloader的作用，概括来说就是将编译后的class装载、加载到机器内存中，为了以后的程序的执行提供前提条件。
- 每个被ClassLoader加载的class文件，最终都会以Class类的实例被程序员引用，我们可以把Class类当作是普通类的一个模板，JVM根据这个模板生成对应的实例，最终被程序员所使用。



### 02.loadClass分析
- 源码代码如下所示。
    ```
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
    
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
    ```
- 关于loadClass方法
    ```
    Class<?> loadClass(String name)
    Class<?> loadClass(String name, boolean resolve)
    ```
    - 看到上面两个方法声明，第二个方法的第二个参数是用于设置加载类的时候是否连接该类，true就连接，否则就不连接。
    - 说到连接，不得不在此做一下解释，在JVM加载类的时候，需要经过三个步骤，装载、连接、初始化（切记这里的初始化是类的初始化，可不是new对象）。装载就是找到相应的class文件，读入JVM，初始化就不用说了（见下一篇博文），最主要就说说连接。
    - 连接分三步，第一步是验证class是否符合规格，第二步是准备，就是为类变量分配内存同时设置默认初始值，第三步就是解释，而这步就是可选的，根据上面loadClass方法的第二个参数来判定是否需要解释，所谓的解释根据《深入JVM》这本书的定义就是根据类中的符号引用查找相应的实体，再把符号引用替换成一个直接引用的过程。
- resolve参数为false含义
    - 再来看看那个两个参数的loadClass方法，该方法的定义是protected，那也就是说该方法是被保护的，而用户真正应该使用的方法是一个参数的那个，一个参数的loadclass方法实际上就是调用了两个参数的方法，而第二个参数默认为false，因此在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类进行解释，因此也不会初始化该类。
- 看一个测试案例
    ``` java
    public class Main {
    	public static void main(String[] args) {
    		TestOrder tOrder = new TestOrder();	
    		try {
    			tOrder.getClass().getClassLoader().loadClass("com.yc.Test");
    		} catch (ClassNotFoundException e) {
    			e.printStackTrace();
    		}
    	}
    }
    
    public class Test {
        static {
            System.out.println("test静态代码段");
        }
    }
    ```
    - 不会输出"test静态代码段"的（静态代码块是跟初始化绑定的）。
























