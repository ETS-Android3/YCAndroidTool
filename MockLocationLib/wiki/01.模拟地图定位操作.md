#### 目录介绍
- 01.目前定位方式有哪些
- 02.定位的基础概念
- 03.Android重要类说明
- 04.关于定位权限说明
- 05.如何获取定位信息
- 06.如何mock定位经纬度
- 07.如何改变手机经纬度



### 01.目前定位方式有哪些
#### 1.1 目前定位方式
- 1、GPS定位。2、基站定位。3、WiFi辅助定位。4、AGPS定位。5、Glonass定位。6、北斗定位。

#### 1.2 GPS定位
- GPS定位
    - 它是由美国研究的一种定位方式。其系统由在轨道上运行的卫星和地面终端构成。
    - 它们的轨道是有规律的：无论你在全球什么地方，至少同时有4颗卫星在你头顶，其实跟我们关系不大。
- 地面终端
    - 其实通俗说的GPS，它可以接收你头顶上那些飞来飞去卫星的信号，然后根据信号计算出你当前的位置。
    - 常见的终端有车载导航GPS、手机内置GPS和徒步户外GPS等。一般民用级别的精确度在10米左右。
    - 使用GPS时，需要在室外空旷能接收到GPS卫星信号的地方才可以，室内基本无望。
- 它的特点是
    - 不需要sim卡，不需要连接网络，只要在户外，基本上随时随地都可以准确定位。
    - 但是GPS启动后搜索卫星的时间比较多，一般需要2分钟左右（俗称冷启动）。


#### 1.3 基站定位
- 基站定位
    - 手机在插入sim卡开机以后，需要搜索周围的基站信息（就是找信号），通常在有信号的地方，手机能搜索到的基站不止一个，就像你的笔记本在小区里能搜到不止一个开着的路由器一样。
    - 然后手机会自动从这些基站中选择信号最好的（假如是基站A）连接注册。其余的基站就不用了吗？不不，手机仍然搜索着它们，一旦你离开基站A一段距离，基站A的信号不如基站B了，手机会自动切换成基站B。
    - 这也就是为什么同样是待机一天，你在火车上比在家里耗电要多的原因，手机需要不停的搜索、连接基站。
- 原理如下
    - 众所周知，距离基站越远，信号越差，所以用信号的强度可以大致估计距离基站的远近。
    - 由于基站都是中国移动中国联通等运营商建立的，所以他们可以确定每个基站准确的位置，当手机同时搜索到至少三个基站的信号时（现在的网络覆盖这是很轻松的一件事情），手机除了连接信号最好的一个外，同时根据基站信号的强弱，大致估计出距离基站的远近。
    - 由于基站位置是确定的，所以确定位置是很容易的，只需要以基站为圆心，距离为半径多次画圆即可，不过至少需要三个基站的信号才可以。
- 它的特点
    - 由于基站定位时，信号很容易受到干扰，所以先天就决定了它定位的不准确性，精度大约在150米左右，基本无法开车导航。
    - 定位条件是必须在有基站信号的位置，手机处于sim卡注册状态（飞行模式下开wifi和拔出sim卡都不行），而且必须收到3个基站的信号，无论是否在室内。
    - 但是，定位速度超快，一旦有信号就可以定位，目前主要用途是没有GPS没有wifi的情况下快速大体了解下你的位置（比如可以使天气预报走到哪儿更新到哪儿）。
    - 另外，如果你的手机里没有基站位置数据包，还需要联网才行。


#### 1.4 WiFi辅助定位
- wifi依赖定位
    - wifi依赖，顾名思义，周围必须有wifi才可以！这个技术貌似最初是谷歌提出来的，目的是解决室内精确定位，原理类似基站定位。
    - 谷歌的工程师们是这样想的：一个wifi热点的覆盖范围仅有几十米，全世界绝大多数的wifi热点都是固定位置的，他们又拥有独一无二的MAC地址（一种编码，作用类似热点的身份证号码），如果应用基站定位的原理，那么就可以获得相当精确的位置信息了。
    - 可是，世界上那么多wifi热点，你总不能跑到各个国家，敲开市民的门去测量吧？谷歌想到了他的神器——谷歌地图。
- 举一个案例理解
    - 假如你的家里有个自己设立的无线路由器，经常开机，你的邻居正在阳台上用手机玩谷歌地图，恰好他手机的wifi是开着的，不过没有连接你家的热点。
    - 当你的邻居用GPS准确在地图上定位后，谷歌服务器会记录周边的wifi热点信息。正好，你的路由器开着，然后被记录到数据库了：某国家某省某市某小区某楼东侧（其实是用经纬度）有一个MAC地址为12-2e-3f-4a-09-3d的wifi热点。
    - 几天后你打算晚上吃川菜，于是连上你的路由器打开谷歌地图打算搜索，这时你惊奇的发现没开GPS，但是你的位置却精确的定位在某国家某省某市某小区某楼东侧。这是为什么呢？
    - 这就是wifi依赖定位：你打开谷歌地图后，会上传周围的wifi热点信息，然后2-2e-3f-4a-09-3d上传到服务器上，服务器根据这个地址反馈你邻居用GPS定位出来的经纬度给你，从而实现精确匹配位置。
    - 当世界上N多N多人重复上述定位的时候，谷歌就可以建立起来一个丰富而且强大的wifi热点位置数据库。
- 定位条件也不难：
    - 1、必须开启wifi，无论是否连接某一个热点。
    - 2、手机必须能上网，移动数据或者wifi联网皆可。（不要指望谷歌允许手机内置这些热点的位置信息，这可是笔财富）
- 它的特点
    - ①定位精度高，wifi密集人流多的地方相当精确；
    - ②速度快；
    - ③周围的wifi即使连接不上也能定位。
- 缺点也是显而易见的
    - ①wifi依赖！————没有打开wifi就不能定位；
    - ②必须处于联网状态。


#### 1.5 AGPS定位
- AGPS定位
    - 必须有GPS模块存在，如果没有GPS模块，这种定位是不起什么作用的。
    - 由于GPS冷启动时，搜星速度很慢，大约2分钟才能搜到。什么是冷启动呢？就是GPS内的卫星位置信息清空了（比如 ①GPS初次使用 ②GPS电池耗尽 ③关机状态下移动1000公里以上的距离或持续关机超过4小时）
- AGPS大概原理
    - 就是先利用基站大体定位下你所在的位置，然后通过网络将这个位置发送到服务器，服务器根据这个位置将此时经过你头顶的卫星参数（哪几颗、频率、位置、仰角等信息）反馈给你的手机，你手机的GPS就可以很有目的的去搜索卫星，此时你的搜星速度大大提高，几秒钟就可以定位。
- 举个案例分析
    - 打个比方，GPS搜星就像在一家大型超市里找到一瓶百事可乐。冷启动呢，就是这个超市很陌生，你不知道食品冷饮区在哪儿，需要一点一点的找。AGPS呢，就像你给超市经理打了个电话，然后他告诉你百事可乐在二楼西南角靠近楼梯的位置。两者搜星速度差别之大是显而易见的。
- 总结一下
    - AGPS是辅助GPS定位的一种方法，支持GPS，不一定支持AGPS（比如有的古董机器不能上网）。
    - 支持AGPS，一定支持GPS，但是这个GPS模块不一定内置在手机里，也有可能是需要额外购买外置蓝牙GPS模块（这种恶心型号是极少极少的，一般标注AGPS基本就是都内置GPS模块了）。


### 02.定位的基础概念
#### 2.1 LBS位置服务介绍
- LBS是什么东西
    - LBS位置服务
        - Location Based Services，LBS，又称定位服务，是指通过 GPS 卫星或者蜂窝网络获取各种终端的地理坐标（经度和纬度），在电子地图平台的支持下，为用户提供基于位置导航、查询的一种信息业务。
- LBS优势和缺点
    - 优势
        - LBS 系统通过移动和固定网络发送基于位置的信息与服务，使得这种服务可以应用到任何人、任何位置、任何时间和任何设备，这就是 LBS 的优势所在。
    - 缺点
        - 这种基站定位的方法，在没有基站的位置上，误差范围会比较大，并且有些地方没有基站是不能实现定位功能的，因此如果手机是使用 LBS 定位的，就一定要问清自己所在的地方是不是有服务基站，这是 LBS 的不足。




#### 2.2 GPS位置服务介绍
- GPS是什么东西
    - GPS
        - Global Position System，全球定位系统是 20 世纪 70 年代由美国陆海空三军联合研制的新一代空间卫星导航定位系统。
    - 位置
        - 由于卫星的位置精确，在 GPS 观测中，我们可以得到卫星到接收机的距离，然后利用三维坐标中的距离公式和 3 颗卫星就可以组成 3 个方程式，解出观测点的位置（X、Y、Z）。
        - 考虑到卫星的时钟与接收机时钟之间的误差，实际上有 4 个未知数，X、Y、Z 和时钟差，然后用 4 个方程将这 4 个未知数解出来，所以如果想知道接收机所处的位置，至少要能接收到 4 个卫星的信号，从而得到观测点的经纬度和高程。
        - 所以说 GPS 定位最大的优点就是精准，并且 GPS 定位能够再网上查询到运动轨迹，因此应用面也是非常广的。




### 03.Android重要类说明
#### 3.1 location定位介绍
- Android SDK 提供了 android.location 包和 Google Maps API 支持位置服务功能，开发人员可以方便地开发自己的位置服务应用程序。
- Android 系统支持 GPS 定位方式和网络定位方式。
    - GPS 方式的位置信息来自卫星，精度很高，但是 GPS 方式仅在户外有效，其首次获取位置时间较长并且非常耗费电量。
- 网络定位方式使用的是移动通信基站和WIFI信号。
    - 这种方式在室内和户外都可以使用，响应快速，费电较少，但是精度难以保证。开发者应该根据应用程序的使用环境来确定具体的定位方式。


#### 3.2 LocationManager
- 在 Android 的位置服务中，LocationManager 是一个非常重要的类，它位于 android.location 包中。
    - LocationManager 类用于管理 Android 用户位置服务信息，提供确定用户位置的 API，通过这个类可以实现定位、跟踪和目标趋近等功能。
    - LocationManager 对象不能直接实例化，可以通过 Context.getSystemService(Context. LOCATION_SERVICE) 方法获得。
- LocationManager 对象可以完成以下三个方面的任务：
    - 从用户的位置查询所有可用的 LocationProvider 列表。
    - 从特定的 LocationProvider 周期性获取用户当前位置的功能。
    - 当用户位置接近某个特定区域时，启动相关任务。
- LocationManager 常用方法
    ```
    getAllProviders()	获得所有 LocationProvider 列表
    getBestProvider (Criteria criteria,Boolean enabldOny) 	根据 criteria 返回最合适的 LocationProvider，其中 criteria 指定了一系列条件
    getLastKnownLocation (String provider) 	根据 provider 获得最新位置信息
    getProvider (String name) 	获得指定名称的 LocationProvider
    getProviders (boolean enabledOnly)	获得可用的 LocationProvider 列表
    ddProximityAlert (double latitude, double longitude, float radius, long expiration, PendingIntent intent)	设定目标趋近警告
    removeProximityAlert (PendingIntent intent)	删除趋近警告
    ```


#### 3.3 LocationProvider
- LocationProvider是什么
    - LocationProvider 为位置提供者的抽象类，位置提供者提供手机设备周期性的地理位置报告。
- LocationProvider 的常用方法
    ```
    getAccuracy()	获取 LocationProvider 提供位置信息的精度
    getName()	获得 LocationProvider 的名称
    getPowerRequirement()	获得 LocationProvider 对电源的需求
    hasMonetaryCost()	获取当前 LocationProvider 是免费的还是收费的
    meetsCriteria (Criteria criteria)	确定当前 LocationProvider 是否符合特定条件
    requiresCell() 	LocationProvider 定位是否需要访问基站网络
    requiresNetwork()	LocationProvider 定位是否需要 Internet 网络数据
    requiresSatellite()	LocationProvider 定位是否需要获取卫星数据
    supportsAltitude()	LocationProvider 提供的位置信息是否包含高度信息
    supportsBearing()	是否能够提供方向信息
    supportsAltitude()	LocationProvider 是否能够提供速度信息
    ```
- LocationListener，提供定位信息发生改变时的回调功能。
    ```
    //当坐标改变时触发此方法，如果 Provider 传进相同的坐标，他就不会被触发。
    onLocationChanged (Location location)	
    //Provider 禁用时触发此方法,例如，GPS 被关闭时
    onProviderDisabled (String provider)	
    //Provider 启用时触发此方法,例如，GPS 被打开时
    onProviderEnabled (String provider)	
    //Provider 的状态可用 AVAILABLE 暂时不可用 TEMPORARILY_UNAVAILABLE 和无服务 OUT_OF_SERVICE 三个状态之间切换时触发此函数。
    onStatusChanged (String provider,int status,Bundle extras)	
    ```



### 04.关于定位权限说明
- 关于获取系统模拟服务
- Android 6.0系统以下
    - 可以通过Setting.Secure.ALLOW_MOCK_LOCATION获取是否【允许模拟位置】
    - 当【允许模拟位置】开启时，可addTestProvider；
- Android 6.0系统及以上
    - 弃用Setting.Secure.ALLOW_MOCK_LOCATION变量，没有【允许模拟位置】选项， 
    - 增加【选择模拟位置信息应用】，此时需要选择当前应用，才可以addTestProvider， 
    - 但未找到获取当前选择应用的方法，因此通过addTestProvider是否成功来判断是否可用模拟位置。
- 需要注意配置清单文件权限
    ```
    <!--允许程序访问WiFi网络信息-->
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <!--允许程序访问CellID或WiFi热点来获取粗略的位置-->
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <!--允许mock位置-->
    <uses-permission android:name="android.permission.ACCESS_MOCK_LOCATION"
        tools:ignore="MockLocation,ProtectedPermissions" />
    ```


### 05.如何获取定位信息
#### 5.1 Android中获取定位实践
- 获取用户的当前位置：
    - 1.在AndroidManifest.xml当中声明相应的权限；
    - 2.获取LocationManager对象；
    - 3.选择LocationProvider；
    - 4.绑定LocationListener对象。
- 获取定位信息的大概步骤思路
    - 1.首先获取定位管理器LocationManager对象，然后需要判断是否有定位相关的权限。
    - 2.获取位置提供器，GPS或是NetWork
    - 3.获取上次的位置，一般第一次运行，此值为null
        - 3.1 如果为null，从网络获取定位信息
        - 3.2 获取经纬度，然后Geocoder通过经纬度获取具体信息
    - 4.监视地理位置变化
- 大概核心代码如下所示
    - 第一步：首先获取定位管理器LocationManager对象
    ```
    //1.获取位置管理器
    locationManager = (LocationManager) mContext.getSystemService(Context.LOCATION_SERVICE);
    //判断权限这块省略，具体看代码
    ```
    - 第二步：获取位置提供器，GPS或是NetWork
    ```
    // 获取所有可用的位置提供器
    List<String> providerList = locationManager.getProviders(true);
    String locationProvider;
    if (providerList.contains(LocationManager.GPS_PROVIDER)) {
        //GPS 定位的精准度比较高，但是非常耗电。
        System.out.println("=====GPS_PROVIDER=====");
        locationProvider = LocationManager.GPS_PROVIDER;
    } else if (providerList.contains(LocationManager.NETWORK_PROVIDER)) {//Google服务被墙不可用
        //网络定位的精准度稍差，但耗电量比较少。
        System.out.println("=====NETWORK_PROVIDER=====");
        locationProvider = LocationManager.NETWORK_PROVIDER;
    } else {
        System.out.println("=====NO_PROVIDER=====");
        // 当没有可用的位置提供器时，弹出Toast提示用户
        Intent intent = new Intent();
        intent.setAction(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
        mContext.startActivity(intent);
        return;
    }
    ```
    - 第三步：获取上次的位置
    ```
    location = locationManager.getLastKnownLocation(locationProvider);
    if (location != null) {
        // 显示当前设备的位置信息
        showLocation();
    } else {
        //当GPS信号弱没获取到位置的时候可从网络获取
        getLngAndLatWithNetwork();
    }
    ```
    - 第四步：监视地理位置变化
    ```
    // 监视地理位置变化，第二个和第三个参数分别为更新的最短时间minTime和最短距离minDistace
    // LocationManager 每隔 5 秒钟会检测一下位置的变化情况，当移动距离超过 10 米的时候，
    // 就会调用 LocationListener 的 onLocationChanged() 方法，并把新的位置信息作为参数传入。
    locationManager.requestLocationUpdates(locationProvider,
            5000, 10, locationListener);
    ```
- 如何根据经纬度获取定位信息
    ```
    private void getAddress(double latitude, double longitude) {
        //Geocoder通过经纬度获取具体信息
        Geocoder gc = new Geocoder(mContext, Locale.getDefault());
        try {
            List<Address> locationList = gc.getFromLocation(latitude, longitude, 1);
            if (locationList != null) {
                Address address = locationList.get(0);
                String countryName = address.getCountryName();//国家
                String countryCode = address.getCountryCode();
                String adminArea = address.getAdminArea();//省
                String locality = address.getLocality();//市
                String subLocality = address.getSubLocality();//区
                String featureName = address.getFeatureName();//街道
                if(addressCallback != null){
                    addressCallback.onGetAddress(address);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    ```
- 当位置发生变化时，会调用onLocationChanged方法
    ```
    //当坐标改变时触发此函数
    @Override
    public void onLocationChanged(Location loc) {
        location = loc;
        showLocation();
        if (addressCallback!=null){
            addressCallback.onGetLocation(loc.getLatitude(),loc.getLongitude());
        }
    }
    ```
- 最后使用定位代码如下所示
    ```
    //注意6.0及以上版本需要在申请完权限后调用方法
    LocationUtils.getInstance(LocationActivity.this).setAddressCallback(new LocationUtils.AddressCallback() {
        @SuppressLint("SetTextI18n")
        @Override
        public void onGetAddress(Address address) {
            String countryName = address.getCountryName();//国家
            String adminArea = address.getAdminArea();//省
            String locality = address.getLocality();//市
            String subLocality = address.getSubLocality();//区
            String featureName = address.getFeatureName();//街道
            ToolLogUtils.d("LocationUtils 定位地址 countryName："+countryName
                    +" adminArea："+ adminArea+" locality："+ locality+" subLocality："
                    + subLocality+" featureName："+ featureName);
            tv11.setText(""+countryName + "," + adminArea + ","
                    +locality+","+subLocality+"," +featureName);
        }
    
        @SuppressLint("SetTextI18n")
        @Override
        public void onGetLocation(double lat, double lng) {
            ToolLogUtils.d("LocationUtils 定位经纬度"+" lat："+ lat+" lng："+ lng);
            tv12.setText("lat："+ lat+" lng："+ lng);
        }
    });
    ```


#### 5.2 遇到的问题说明



### 06.如何mock定位经纬度
#### 6.1 项目中如何使用mock数据
- 首先看一下定位sdk的api
    - 通过getLastKnownLocation方法获取经纬度的对象，看一下代码
    ```
    LocationService.getInstance().getLastKnownLocation()
    ```
- 然后追溯到LocationPerformerImpl类中
    - 可以发现如果是mock，则使用mock定位经纬度数据，否则是获取实际定位经纬度数据
    ```
    public DIDILocation getLastKnownLocation() {
        if (this.mDelegateListener.isMockEnabled()) {
            return this.mDelegateListener.getMockDidiLocation();
        } else {
            return this.mLocationManager == null ? null : this.mLocationManager.getLastKnownLocation();
        }
    }
    ```
    - 当位置发生变化的时候，如果是mock环境，则直接使用mock的经纬度数据。
    ```
    public void onLocationChanged(DIDILocation didiLocation) {
        if (this.isMockEnabled()) {
            didiLocation = this.updateMockLocation();
        }
    
        this.dump();
    
        for(int i = 0; i < this.mCallback.size(); ++i) {
            if (this.mCallback.get(i) != null) {
                ((DIDILocationListener)this.mCallback.get(i)).onLocationChanged(didiLocation);
            }
        }
    
        if (didiLocation != null) {
            this.mLogger.warn("location" + didiLocation.toString(), new Object[0]);
        }
    }
    ```



#### 6.2 如何mock设置经纬度
- 如何判断是否可以mock位置，通过addTestProvider是否成功来判断是否可用模拟位置
    - 主要是创建一个模拟位置的活动，然后并且给它设置启用模拟的值。
    - 如果启用成功则模拟位置可用，如果抛出异常就需要到开发者选项中打开模拟定位。最多重拾三次……
    ```
    /**
     * 判断模拟位置是否启用
     * @return
     */
    private boolean getUseMockPositionEnable() {
        boolean isAvailable;
        try {
            List<String> providers = mLocationManager.getProviders(true);
            LogMockGps.log("MockGpsManager", "当前可用的 providers 有:" + providers);
            //创建一个模拟位置提供程序并将其添加到活动提供程序集。
            mLocationManager.addTestProvider("gps",
                    false, false, false,
                    false, true, true,
                    true, 0, 5);
            //为给定的提供程序设置启用模拟的值。该值将在适当的地方使用提供程序的任何实际值。
            mLocationManager.setTestProviderEnabled(LocationManager.GPS_PROVIDER, true);
            isAvailable = true;
        } catch (Exception var6) {
            String msg = "请到开发者选项中打开模拟定位\n初始化失败 tried " + triedInit;
            onMessage(msg + var6.getMessage());
            disableTestProvider();
            LogMockGps.e("MockGpsManager", msg);
            isAvailable = false;
        } finally {
            ++triedInit;
        }
        return isAvailable;
    }
    ```
- 然后开启mock操作
    - 目前使用gsp设置模拟位置操作，如果设置出现异常，则获取最后位置进行重拾
    ```
    /**
     * 为给定的提供程序设置模拟位置
     * @param lat                           纬度
     * @param lng                           经度
     */
    public void teleportWgs(double lat, double lng) {
        if (!mIsAvailable) {
            String msg = "第一、设置我们手机允许模拟定位【系统设置】=》开发者选项=》" +
                    "打开允许模拟位置\n第二、进入位置服务切换成只是用gps确定位置";
        }
        try {
            mLocation.setLatitude(lat);
            mLocation.setLongitude(lng);
            // 为给定的提供程序设置模拟位置。此位置将用于替代提供者提供的任何实际位置。
            // location对象必须设置一个最小数量的字段，才能被认为是有效的LocationProvider location
            mLocationManager.setTestProviderLocation(LocationManager.GPS_PROVIDER, mLocation);
        } catch (SecurityException var8) {
            String msg = "请到开发者选项中打开模拟定位";
            onMessage(msg);
        } catch (Exception var9) {
            LogMockUtils.log("MockGpsManager", "Exception Provider \"gps\" unknown. 拦截下来了.");
            try {
                removeTestProvider();
                //创建一个模拟位置提供程序并将其添加到活动提供程序集。
                mLocationManager.addTestProvider(LocationManager.GPS_PROVIDER,
                        false, false, false,
                        false, true, true,
                        true, 0, 5);
                //为给定的提供程序设置启用模拟的值。该值将在适当的地方使用提供程序的任何实际值。
                mLocationManager.setTestProviderEnabled(LocationManager.GPS_PROVIDER, true);
                //递归调用
                teleportWgs(mLastPoint.getLatitude(), mLastPoint.getLongitude());
            } catch (Exception var7) {
                var7.printStackTrace();
                disableTestProvider();
            }
        }
    }
    ```
- 遇到的问题说明
    - 发现在初始化判断是否可以开启定位的时候，总是报开启定位mock失败。注意这里，已经在设置修改允许打开模拟定位操作，这是为什么呢？
    



### 07.如何改变手机经纬度




















### 01.如何查看域名是否是海外服务器
- 1、看IP归属地，网址：ip138.com
    - 看一下域名多少，直接在站长工具或者本地测ping，可以测出对应的 ip。然后直接在百度上输入ip地址，就可以知道服务器是哪里的呢。
- 2、ping服务器的IP，看延迟
- 3、tracert路由跟踪









