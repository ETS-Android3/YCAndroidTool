#### 目录介绍
- 4.1 IllegalArgumentException导致崩溃【url地址传入非法参数，转义字符】
- 4.2 ClassNotFoundException: Didn't find class "*****" on path: /data/app/**错误
- 4.3 NoClassDefFoundError异常【该异常表示找不到类定义】
- 4.4 公司之前项目使用客服udesk，sdk更新后初始化导致崩溃问题
- 4.5 java.util.concurrent.ExecutionException: com.android.tools.aapt2.Aapt2Exception
- 4.6 java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException
- 4.7 00768556 /vendor/lib/libllvm-glnext.so [armeabi-v8]无法加载so库导致崩溃
- 4.8 Only the original thread that created a view hierarchy can touch its views
- 4.9 NoSuchMethodException  android.support.v4.app.Fragment$InstantiationException



### 4.1 IllegalArgumentException导致崩溃【url地址传入非法参数，转义字符】
- A.详细崩溃日志信息
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-2cb3f7e2b25530a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- B.查看崩溃类信息
- C.项目中异常分析
    - 只有很少一部分传入非法参数导致崩溃，不能直接用常规方法。需要过滤
- D.引发崩溃日志的流程分析
- F.解决办法
    - Java调用 URLDecoder.decode(str,"UTF-8");抛出以上的异常，其主要原因是%在URL中是特殊字符，需要特殊转义一下
    ```
    public static String replacer(String data) {
        try {
            //使用%25替换字符串中的%号
            data = data.replaceAll("%(?![0-9a-fA-F]{2})", "%25");      
            data = URLDecoder.decode(data, "utf-8");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }
    ```



### 4.2 ClassNotFoundException: Didn't find class "*****" on path: /data/app/**错误
- A.详细崩溃日志信息
    ```
    java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{*****Activity}: java.lang.ClassNotFoundException: Didn't find class "*****Activity" on path: /data/app/*******.apk
    ```
- B.查看崩溃类信息
    - 当应用程序尝试使用字符串名称加载类时引发：但无法找到具有指定名称的类的定义。从1.4版开始，已对此异常进行了修改，以符合通用的异常链接机制。在构建时提供并通过{@link#getException()}方法访问的“在加载类时引发的可选异常”现在称为<i>原因</i>，并且可以通过{@link Throwable#getCace()}方法以及前面提到的“遗留方法”进行访问。
    ```
    public class ClassNotFoundException extends ReflectiveOperationException {
        private static final long serialVersionUID = 9176873029745254542L;
        private Throwable ex;
        public ClassNotFoundException() {
            super((Throwable)null);  // Disallow initCause
        }
        public ClassNotFoundException(String s) {
            super(s, null);  //  Disallow initCause
        }
        public ClassNotFoundException(String s, Throwable ex) {
            super(s, null);  //  Disallow initCause
            this.ex = ex;
        }
        public Throwable getException() {
            return ex;
        }
        public Throwable getCause() {
            return ex;
        }
    }
    ```
- C.项目中异常分析
- D.引发崩溃日志的流程分析
- F.解决办法
    - 1。Manifest文件中注册的Activity的名称，有没有写错，包名有没有搞错，有些网友，可能只写一个类名，前面用点号代替，但是这个类不在默认的包内，所以报这个错，那么只要写上类的全名，即可。
    - 2.你的使用的class，是一个外部的JAR包，当在工程中编译使用时，发布成APK并没有包含JAR文件，所以APK在执行的时候就找不到JAR文件，会报错。有些android，需要一些第三方的包，直接将其引入，在以前是可以的，但是在最新的adt中不行，必须在程序中新建一个libs文件夹，将第三方的jar文件copy到libs文件夹中，才行，很多人因为这样才报错，特别是以前的项目，默认并没有这个libs文件夹，但是新版本的adt,默认就建了libs这个文件夹。
    - 3。有一点也很重要，在Java Build Path面板下的Order and Export中，一定要把你引入的jar文件，勾上，否则，跟没引用一样，切记。


### 4.3 NoClassDefFoundError异常【该异常表示找不到类定义】
- A.详细崩溃日志信息
    - 经常碰到java.lang.NoClassDefFoundError这样的错误，需要花费很多时间去找错误的原因，具体是哪个类不见了？类明明还在，为什么找不到？而且我们很容易把java.lang.NoClassDefFoundError和java.lang.ClassNotfoundException这两个错误搞混，事实上这两个错误是完全不同的。
- B.查看崩溃类信息
- C.项目中异常分析
    - 该异常表示找不到类定义，当JVM或者ClassLoader实例尝试装载该类的定义（这通常是一个方法调用或者new表达式创建一个实例过程的一部分）而这个类定义并没有找时所抛出的错误。
    - NoClassDefFoundError错误的发生，是因为Java虚拟机在编译时能找到合适的类，而在运行时不能找到合适的类导致的错误。
    - 例如在运行时我们想调用某个类的方法或者访问这个类的静态成员的时候，发现这个类不可用，此时Java虚拟机就会抛出NoClassDefFoundError错误。
    - 总结：这个错误，是编译器可用，运行期不可用
- D.引发崩溃日志的流程分析
    - 对应的Class在java的classpath中不可用
    - 你可能用jar命令运行你的程序，但类并没有在jar文件的manifest文件中的classpath属性中定义
    - 可能程序的启动脚本覆盖了原来的classpath环境变量
    - 因为NoClassDefFoundError是java.lang.LinkageError的一个子类，所以可能由于程序依赖的原生的类库不可用而导致
    - 检查日志文件中是否有java.lang.ExceptionInInitializerError这样的错误，NoClassDefFoundError有可能是由于静态初始化失败导致的
- F.解决办法
    - 当发生由于缺少jar文件，或者jar文件没有添加到classpath，或者jar的文件名发生变更会导致java.lang.NoClassDefFoundError的错误
    - 由于NoClassDefFoundError是LinkageError的子类，而LinkageError的错误在依赖其他的类时会发生，所以如果你的程序依赖原生的类库和需要的dll不存在时，有可能出现java.lang.NoClassDefFoundError。这种错误也可能抛出java.lang.UnsatisfiedLinkError: no dll in java.library.path Exception Java这样的异常。解决的办法是把依赖的类库和dll跟你的jar包放在一起。
    - 如果你使用Ant构建脚本来生成jar文件和manifest文件，要确保Ant脚本获取的是正确的classpath值写入到manifest.mf文件
    - Jar文件的权限问题也可能导致NoClassDefFoundError，如果你的程序运行在像linux这样多用户的操作系统种，你需要把你应用相关的资源文件，如Jar文件，类库文件，配置文件的权限单独分配给程序所属用户组，如果你使用了多个用户不同程序共享的jar包时，很容易出现权限问题。比如其他用户应用所属权限的jar包你的程序没有权限访问，会导致java.lang.NoClassDefFoundError的错误。
    - 基于XML配置的程序也可能导致NoClassDefFoundError的错误。比如大多数Java的框架像Spring，Struts使用xml配置获取对应的bean信息，如果你输入了错误的名称，程序可能会加载其他错误的类而导致NoClassDefFoundError异常。我们在使用Spring MVC框架或者Apache Struts框架，在部署War文件或者EAR文件时就经常会出现Exception in thread “main” java.lang.NoClassDefFoundError。
- G.其他延申，常见场景
    - 1.分dex包编程，如果依赖的dex包删除了指定的类，执行初始化方法时将会报错；
    - 2.使用第三方SDK或插件化编程时，动态加载或实例化类失败将会报错；
    - 3.系统资源紧张时，当大量class需要加载到内存的时候，处于竞争关系，部分calss竞争失败，导致加载不成功；
    - 4.装载并初始化一个类时失败（比如静态块抛 java.lang.ExceptionInInitializerError 异常），然后再次引用此类也会提示NoClassDefFoundErr 错误；
    - 5.手机系统版本或硬件设备不匹配（如ble设备只支持18以上SDK），程序引用的class在低版本中不存在，导致NoClassDefFoundErr 错误。
    - 6.so文件找不到,设备平台armeabi-v7a,但是我的so库是放在armeabi中的,解决方法新建一个armeabi-v7a包,并且把armeabi的文件拷贝过来.
- H.NoClassDefFoundError和ClassNotFoundException区别
    - NoClassDefFoundError发生在JVM在动态运行时，根据你提供的类名，在classpath中找到对应的类进行加载，但当它找不到这个类时，就发生了java.lang.NoClassDefFoundError的错误
    - ClassNotFoundException是在编译的时候在classpath中找不到对应的类而发生的错误




### 4.4 公司之前项目使用客服udesk，sdk更新后初始化导致崩溃问题
- 出错原因：初始化udesk客服sdk时，需要传入token，name等信息。token是作为客户的唯一标识，而客服第三方sdk是以token命名创建sqlite数据库，造成数据库名称过长……
- 报错信息：
    ```
    Could not open database, (OS error - 36:File name too long)
    {"code":"4444","message":"未知错误","exception":"Data too long for column 'sdk_token' at row 1"}
    ```
- 日志错误截图
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-b18eb9374e7d1410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-72dc0f1299961af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 解决办法
    - 第一种解决办法：客户端裁剪token前10位[或者15位也行，就是不要长度过长]字符串作为客户唯一标识，经过测试可以解决问题，但是需要发版，并且无法改正之前版本的问题。
    - 第二种解决办法：第三方平台解决，因为之前使用没有问题，后来出现了该问题。可能是他们改代码引起该问题！已经跟第三方发过信息，周一看……



### 4.5 java.util.concurrent.ExecutionException: com.android.tools.aapt2.Aapt2Exception
- A.详细崩溃日志信息
    ```
    Caused by: java.util.concurrent.ExecutionException: java.util.concurrent.ExecutionException: com.android.tools.aapt2.Aapt2Exception: AAPT2 error: check logs for details
    Caused by: com.android.tools.aapt2.Aapt2Exception: AAPT2 error: check logs for details
    ```
- B.查看崩溃类信息
    ```
    public class ExecutionException extends Exception {
        protected ExecutionException() {
            throw new RuntimeException("Stub!");
        }
    
        protected ExecutionException(String message) {
            throw new RuntimeException("Stub!");
        }
    
        public ExecutionException(String message, Throwable cause) {
            throw new RuntimeException("Stub!");
        }
    
        public ExecutionException(Throwable cause) {
            throw new RuntimeException("Stub!");
        }
    }
    ```
- C.项目中异常分析
- D.引发崩溃日志的流程分析
- F.解决办法
    - 在项目的中，gradle.properties文件中添加一行代码就行，即gradle.properties(Project properties)
    ```    
    android.enableAapt2=false
    ```
- G.其他延申
    - gradle.properties 里面配置的东西，在gradle 文件里面可以直接引用
    - 在项目根目录的gradle.properties文件配置:
    ```
    # 应用版本名称
    VERSION_NAME=1.0.0
    # 应用版本号
    VERSION_CODE=100
    # 支持库版本
    SUPPORT_LIBRARY=24.2.1
    # MIN_SDK_VERSION
    ANDROID_BUILD_MIN_SDK_VERSION=14
    # TARGET_SDK_VERSION
    ANDROID_BUILD_TARGET_SDK_VERSION=24
    # BUILD_SDK_VERSION
    ANDROID_BUILD_SDK_VERSION=24
    # BUILD_TOOLS_VERSION
    ANDROID_BUILD_TOOLS_VERSION=24.0.3
    ```
    - 这时候配置app和lib的build.gradle可以这样写:
    ```
    android {
        compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int
        buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
     
        defaultConfig {
            applicationId project.APPLICATION_ID // lib项目不需要配置这一项
            versionCode project.VERSION_CODE as int
            versionName project.VERSION_NAME
            minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int
            targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int
        }
    }
     
    dependencies {
        compile fileTree(include: ['*.jar'], dir: 'libs')
        //这里注意是双引号
        compile "com.android.support:appcompat-v7:${SUPPORT_LIBRARY}"
        compile "com.android.support:design:${SUPPORT_LIBRARY}"
        compile "com.android.support:recyclerview-v7:${SUPPORT_LIBRARY}"
        compile "com.android.support:support-annotations:${SUPPORT_LIBRARY}"
        compile "com.android.support:cardview-v7:${SUPPORT_LIBRARY}"
        compile "com.android.support:support-v4:${SUPPORT_LIBRARY}"
    }
    ```


### 4.6 java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException
- A.详细崩溃日志信息
    - 也就是执行异常，进程异常。
    ```
    Caused by: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: Error while executing process /Users/duanzheng/WorkSpace/AndroidSdk/build-tools/27.0.3/aapt with arguments {package -f --no-crunch -I /Users/duanzheng/WorkSpace/AndroidSdk/platforms/android-27/android.jar -M /Users/duanzheng/.jenkins/workspace/android_hwmc_project/UdeskSDKUI/build/intermediates/manifests/aapt/release/AndroidManifest.xml -S /Users/duanzheng/.jenkins/workspace/android_hwmc_project/UdeskSDKUI/build/intermediates/res/merged/release --non-constant-id -0 apk --no-version-vectors}
    
    Caused by: org.gradle.process.internal.ExecException: Process 'command '/Users/duanzheng/WorkSpace/AndroidSdk/build-tools/27.0.3/aapt'' finished with non-zero exit value 1
    
    
    //注意这里看重点：aapt'' finished with non-zero exit value 1
    ```
- B.查看崩溃类信息
- C.项目中异常分析
- D.引发崩溃日志的流程分析
- F.解决办法
    - 网上搜索第一种方法：初步猜测可能由同步下来不需要的build文件造成，clean一下项目看是否能解决。
- H.aapt是啥
    - AAPT是Android资源打包工具
    - https://www.jianshu.com/p/8d691b6bf8b4




### 4.7 00768556 /vendor/lib/libllvm-glnext.so [armeabi-v8]无法加载so库导致崩溃
- A.详细崩溃日志信息
    - 魅族手机，一打开就崩溃。思考[armeabi-v8]是啥？
    ```
    1 #00 pc 00768556 /vendor/lib/libllvm-glnext.so [armeabi-v8]
    2 #01 pc 000011e0 <unknown>
    3 java:
    4 [Failed to get java stack] 
    ```
- B.查看崩溃类信息
- C.项目中异常分析
- D.引发崩溃日志的流程分析
- F.解决办法
- G.其他延申




### 4.8 Only the original thread that created a view hierarchy can touch its views
- A.详细崩溃日志信息
    ```
    UncaughtException detected: io.reactivex.exceptions.OnErrorNotImplementedException: Only the original thread that created a view hierarchy can touch its views.
    Caused by: android.view.ViewRootImpl$CalledFromWrongThreadException: 
    Only the original thread that created a view hierarchy can touch its views.
    ```
- B.查看崩溃类信息
    - 异常的意思是说只有创建这个view的线程才能操作这个view，普通会认为是将view创建在非UI线程中才会出现这个错误。
- C.项目中异常分析
    - Android中相关的view和控件操作都不是线程安全的，所以Android才会禁止在非UI线程更新UI，对于显式的非法操作，比如说直接在Activity里创建子线程，然后直接在子线程中操作UI等，Android会直接异常退出，并提示should run on UIThread之类的错误日志信息。
    - 对于隐式非法操作，App不会直接简单粗暴地异常退出，只是出现奇怪结果，Only the original thread that created a view hierarchy can touch its views便是一个例子，字面意思是只有创建视图层次结构的原始线程才能操作它的View，明显是线程安全相关的。
- D.引发崩溃日志的流程分析
    - 在intentService中发送通知更新购物车页面数据刷新，导致出现该问题。
- F.解决办法
    - 
- G.其他延申



### 4.9 NoSuchMethodException  android.support.v4.app.Fragment$InstantiationException
- 详细日志错误
    ```
    vity.baojia.ChoiceResultPsActivity}: android.support.v4.app.Fragment$InstantiationException: 
    Unable to instantiate fragment com.cheoo.app.fragment.choiceresultps.QuotationDaQuanFragment: 
    could not find Fragment constructor
    ```
- 可能导致的出现该bug的原因分析
    - 问题主要跟Activity的数据恢复有关，其可能产生的Exception：android.support.v4.app.Fragment$InstantiationException
    - 每个Fragment必须要有一个无参构造方法，这样该Fragment在Activity恢复状态的时候才可以被实例化。
    - 强烈建议，Fragment的子类不要有其他含参构造方法，因为这些构造方法在Fragment重新实例化时不会被调用。取而代之的方式是，通过setArguments(Bundle)设置参数，然后通过getArguments获得参数。如果的Fragment没有无参构造方法，app在恢复Activity时（例如旋转设备），会出现crash。
- 问题代码如下所示，解决办法就是添加一个无参构造方法即可。
    ```
    public static BusinessHotCarFragment newInstance(Map<String,String> map) {
        BusinessHotCarFragment fragment = new BusinessHotCarFragment(map);
        return fragment;
    }
    
    public BusinessHotCarFragment(Map<String,String> map) {
        this.pMap =map;
    }
    
    //解决问题办法，添加一个无参构造方法
    public BusinessHotCarFragment(){}
    ```
- 深入分析为何Fragment需要无参构造函数才可以实例化
    - 既然报的找不到构造方法的错误，先来看一下Fragment的构造函数：
        - 谷歌翻译一下可知。构造函数上有一段注释：默认构造器。每一个Fragment必须有一个无参的构造函数，以便当Activity恢复状态时fragment可以实例化。强烈建议fragment的子类不要有其他的有参构造函数，因为当fragment重新实例化时不会调用这些有参构造函数；如果要传值应该使用setArguments方法，在需要获取这些值时调用getArguments方法。
        ```
        /**
         * Default constructor.  <strong>Every</strong> fragment must have an
         * empty constructor, so it can be instantiated when restoring its
         * activity's state.  It is strongly recommended that subclasses do not
         * have other constructors with parameters, since these constructors
         * will not be called when the fragment is re-instantiated; instead,
         * arguments can be supplied by the caller with {@link #setArguments}
         * and later retrieved by the Fragment with {@link #getArguments}.
         *
         * <p>Applications should generally not implement a constructor. Prefer
         * {@link #onAttach(Context)} instead. It is the first place application code can run where
         * the fragment is ready to be used - the point where the fragment is actually associated with
         * its context. Some applications may also want to implement {@link #onInflate} to retrieve
         * attributes from a layout resource, although note this happens when the fragment is attached.
         */
        public Fragment() {
        }
        ```
    - 这个异常是从哪里来的？
        - 这一段注释明确的告诉我们使用有参构造函数会出问题，建议使用无参构造函数，但是并没有告诉我们具体是哪里的问题。我们在Fragment源码中搜索could not find Fragment constructor这个异常，发现是在instantiate方法中抛出的。
        - 看上面的代码我们可以知道，Fragment的实例化是通过调用类对象的getConstructor()方法获取构造器对象并调用其newInstance()方法创建对象的。此时还会将args参数设置给Fragment。
        ```
        public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) {
            try {
                Class<?> clazz = sClassMap.get(fname);
                if (clazz == null) {
                    // Class not found in the cache, see if it's real, and try to add it
                    clazz = context.getClassLoader().loadClass(fname);
                    sClassMap.put(fname, clazz);
                }
                Fragment f = (Fragment) clazz.getConstructor().newInstance();
                if (args != null) {
                    args.setClassLoader(f.getClass().getClassLoader());
                    f.setArguments(args);
                }
                return f;
            } catch (ClassNotFoundException e) {
                throw new InstantiationException("Unable to instantiate fragment " + fname
                        + ": make sure class name exists, is public, and has an"
                        + " empty constructor that is public", e);
            } catch (java.lang.InstantiationException e) {
                throw new InstantiationException("Unable to instantiate fragment " + fname
                        + ": make sure class name exists, is public, and has an"
                        + " empty constructor that is public", e);
            } catch (IllegalAccessException e) {
                throw new InstantiationException("Unable to instantiate fragment " + fname
                        + ": make sure class name exists, is public, and has an"
                        + " empty constructor that is public", e);
            } catch (NoSuchMethodException e) {
                throw new InstantiationException("Unable to instantiate fragment " + fname
                        + ": could not find Fragment constructor", e);
            } catch (InvocationTargetException e) {
                throw new InstantiationException("Unable to instantiate fragment " + fname
                        + ": calling Fragment constructor caused an exception", e);
            }
        }
        ```
    - 这个异常是哪里触发的呢？
        - 找到了具体报错的地方，但是这个方法是在哪里调用触发的呢？在Fragment没有找到调用的地方，由于Fragment是由FragmentManager管理的，在该类发现是在restoreAllState方法中调用的
        - 这方法名意为恢复所有的状态，而其中注释为创建激活Fragment的列表，并将他们从保存的状态中实例化。这个方法应该是Fragment重新实例化时调用的方法。该方法在Fragment的restoreChildFragmentState被调用。
        ```
        void restoreAllState(Parcelable state, FragmentManagerNonConfig nonConfig) {
            // Build the full list of active fragments, instantiating them from
            // their saved state.
            mActive = new SparseArray<>(fms.mActive.length);
            for (int i=0; i<fms.mActive.length; i++) {
                FragmentState fs = fms.mActive[i];
                if (fs != null) {
                    FragmentManagerNonConfig childNonConfig = null;
                    if (childNonConfigs != null && i < childNonConfigs.size()) {
                        childNonConfig = childNonConfigs.get(i);
                    }
                    ViewModelStore viewModelStore = null;
                    if (viewModelStores != null && i < viewModelStores.size()) {
                        viewModelStore = viewModelStores.get(i);
                    }
                    Fragment f = fs.instantiate(mHost, mContainer, mParent, childNonConfig,
                            viewModelStore);
                    if (DEBUG) Log.v(TAG, "restoreAllState: active #" + i + ": " + f);
                    mActive.put(f.mIndex, f);
                    // Now that the fragment is instantiated (or came from being
                    // retained above), clear mInstance in case we end up re-restoring
                    // from this FragmentState again.
                    fs.mInstance = null;
                }
            }
        ...   
        }
        ```
    - 然后看一下在Fragment的restoreChildFragmentState方法源码。
        - restoreChildFragmentState方法又在Fragment的onCreate方法中调用，这里将保存的savedInstanceState状态又传递给了restoreChildFragmentState以完成Fragment的重新实例化。
        ```
        void restoreChildFragmentState(@Nullable Bundle savedInstanceState) {
            if (savedInstanceState != null) {
                Parcelable p = savedInstanceState.getParcelable(
                        FragmentActivity.FRAGMENTS_TAG);
                if (p != null) {
                    if (mChildFragmentManager == null) {
                        instantiateChildFragmentManager();
                    }
                    mChildFragmentManager.restoreAllState(p, mChildNonConfig);
                    mChildNonConfig = null;
                    mChildFragmentManager.dispatchCreate();
                }
            }
        }
        ```
    - 接着看看Fragment中的onCreate方法
        ```
        @CallSuper
        public void onCreate(@Nullable Bundle savedInstanceState) {
            mCalled = true;
            restoreChildFragmentState(savedInstanceState);
            if (mChildFragmentManager != null
                    && !mChildFragmentManager.isStateAtLeast(Fragment.CREATED)) {
                mChildFragmentManager.dispatchCreate();
            }
        }
        ```
    - 得出结论
        - 经过以上的分析，我们就知道了为什么这个错误出在了Fragment的有参构造函数上。因为当Fragment因为某种原因重新创建时，会调用到onCreate方法传入之前保存的状态，在instantiate方法中通过反射无参构造函数创建一个Fragment，并且为Arguments初始化为原来保存的值，而此时如果没有无参构造函数就会抛出异常，造成程序崩溃。





