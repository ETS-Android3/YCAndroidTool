#### 目录介绍
- 01.详细崩溃日志信息
- 02.查看崩溃类信息
- 03.项目中该异常分析
- 04.追溯导航源码链路
- 05.bug解决方案实践
- 06.其他延伸分析说明



### 01.详细崩溃日志信息
- 详细崩溃日志信息
    - 在Activity关闭的时候，是否忽略了解绑广播，导致了崩溃。
    ```
    IntentReceiverLeaked: Activity com.didi.rider.business.main.RiderMainActivity has leaked IntentReceiver com.didi.rider.app.application.MemoryCallBack$MapBroadcastReceiver@cc11473 that was originally registered here. 
    Are you missing a call to unregisterReceiver()?
    ```
- 详细崩溃堆栈日志
    ```
    2021-08-10 16:06:36.441 17410-17410/? E/ActivityThread: Activity com.didi.rider.business.main.RiderMainActivity has leaked IntentReceiver com.didi.rider.app.application.MemoryCallBack$MapBroadcastReceiver@cc11473 that was originally registered here. Are you missing a call to unregisterReceiver()?
    android.app.IntentReceiverLeaked: Activity com.didi.rider.business.main.RiderMainActivity has leaked IntentReceiver com.didi.rider.app.application.MemoryCallBack$MapBroadcastReceiver@cc11473 that was originally registered here. Are you missing a call to unregisterReceiver()?
        at android.app.LoadedApk$ReceiverDispatcher.<init>(LoadedApk.java:1596)
        at android.app.LoadedApk.getReceiverDispatcher(LoadedApk.java:1372)
        at android.app.ContextImpl.registerReceiverInternal(ContextImpl.java:1525)
        at android.app.ContextImpl.registerReceiver(ContextImpl.java:1498)
        at android.app.ContextImpl.registerReceiver(ContextImpl.java:1486)
        at android.content.ContextWrapper.registerReceiver(ContextWrapper.java:637)
        at com.didi.rider.app.application.MemoryCallBack.init(MemoryCallBack.java:69)
        at com.didi.rider.flutter.view.RiderMapView.init(RiderMapView.java:264)
        at com.didi.rider.flutter.view.RiderMapView.<init>(RiderMapView.java:116)
        at com.didi.rider.flutter.view.RiderMapView.<init>(RiderMapView.java:111)
        at com.didi.rider.flutter.view.RiderMapView.<init>(RiderMapView.java:107)
        at com.didi.rider.flutter.map.manager.MapViewManager.createRiderMapView(MapViewManager.kt:41)
        at com.didi.rider.flutter.page.RiderMapPage.onInflateView(RiderMapPage.kt:57)
        at com.didi.app.nova.skeleton.internal.page.ControllerProxy.onCreateView(ControllerProxy.java:41)
        at com.didi.app.nova.skeleton.conductor.Controller.inflate(Controller.java:1027)
        at com.didi.app.nova.skeleton.conductor.ControllerChangeHandler.executeChange(ControllerChangeHandler.java:219)
        at com.didi.app.nova.skeleton.conductor.ControllerChangeHandler.executeChange(ControllerChangeHandler.java:175)
        at com.didi.app.nova.skeleton.conductor.Router.performControllerChange(Router.java:931)
        at com.didi.app.nova.skeleton.conductor.Router.performControllerChange(Router.java:901)
        at com.didi.app.nova.skeleton.conductor.Router.setBackstack(Router.java:555)
        at com.didi.app.nova.skeleton.conductor.Router.setRoot(Router.java:445)
        at com.didi.app.nova.skeleton.internal.page.PageInstrumentImpl.setRootPage(PageInstrumentImpl.java:71)
        at com.didi.rider.business.main.RiderMainActivity.initMapPage_aroundBody54(RiderMainActivity.java:673)
        at com.didi.rider.business.main.RiderMainActivity$AjcClosure55.run(RiderMainActivity.java:1)
        at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:149)
        at com.didi.foundation.sdk.TimeCalculate.methodExecute(TimeCalculate.java:85)
        at com.didi.rider.business.statistics.MethodAspect.methodExecute(MethodAspect.java:41)
        at com.didi.rider.business.main.RiderMainActivity.initMapPage(RiderMainActivity.java:625)
        at com.didi.rider.business.main.RiderMainActivity.onAfterCreate_aroundBody32(RiderMainActivity.java:483)
        at com.didi.rider.business.main.RiderMainActivity$AjcClosure33.run(RiderMainActivity.java:1)
        at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:149)
        at com.didi.foundation.sdk.TimeCalculate.methodExecute(TimeCalculate.java:85)
        at com.didi.rider.business.statistics.MethodAspect.methodExecute(MethodAspect.java:41)
        at com.didi.rider.business.main.RiderMainActivity.onAfterCreate(RiderMainActivity.java:462)
        at com.didi.app.nova.skeleton.SkeletonActivity.onCreate(SkeletonActivity.java:27)
        at android.app.Activity.performCreate(Activity.java:7893)
        at android.app.Activity.performCreate(Activity.java:7880)
        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1307)
        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3283)
        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3457)
        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:83)
        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)
    	at android
    ```



### 02.查看崩溃类信息
- 运行时异常。大概就是在销毁的时候没有解绑广播，可能会导致崩溃……
    ```
    final class IntentReceiverLeaked extends AndroidRuntimeException {
        public IntentReceiverLeaked(String msg) {
            super(msg);
        }
    }
    ```


### 03.项目中该异常分析
- 根据报错日志，找到崩溃的源码，大概如下所示：
    ```
    public void removeContextRegistrations(Context context,
            String who, String what) {
        final boolean reportRegistrationLeaks = StrictMode.vmRegistrationLeaksEnabled();
        synchronized (mReceivers) {
            ArrayMap<BroadcastReceiver, LoadedApk.ReceiverDispatcher> rmap =
                    mReceivers.remove(context);
            if (rmap != null) {
                for (int i = 0; i < rmap.size(); i++) {
                    LoadedApk.ReceiverDispatcher rd = rmap.valueAt(i);
                    IntentReceiverLeaked leak = new IntentReceiverLeaked(
                            what + " " + who + " has leaked IntentReceiver "
                            + rd.getIntentReceiver() + " that was " +
                            "originally registered here. Are you missing a " +
                            "call to unregisterReceiver()?");
                    leak.setStackTrace(rd.getLocation().getStackTrace());
                    Slog.e(ActivityThread.TAG, leak.getMessage(), leak);
                    if (reportRegistrationLeaks) {
                        StrictMode.onIntentReceiverLeaked(leak);
                    }
                    try {
                        ActivityManager.getService().unregisterReceiver(
                                rd.getIIntentReceiver());
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
            }
            mUnregisteredReceivers.remove(context);
        }
    }
    ```
- 分析LoadedApk类中是如何存储和移除广播的
    - 当注册了广播：最终会调用到 getReceiverDispatcher 方法将 Receiver 存储到 map集合中
    - 当解绑了广播：最终会调用到 removeContextRegistrations 放啊放将 Receiver 移除
- 那么看看解绑广播具体做了什么操作呢？
    - Context -----> unregisterReceiver
    - 具体看：ContextImpl -----> unregisterReceiver  
    - 然后看：ActivityManagerService -----> unregisterReceiver
        - 这里头主要是将 receiver 从 mRegisteredReceivers[HashMap]字典中移除



### 04.追溯导航源码链路
- 查看崩溃日志，发现最终调用了 removeContextRegistrations 方法，抛出该异常
    - 在activity销毁的时候，未解绑广播导致的
- 分析一下整体代码的流程，在activity销毁的时候，会调用ActivityThread的handleDestroyActivity方法
    - 可以发现最后又一个清理的操作，那么具体做了什么呢，点击去看看
    ```
    @Override
    public void handleDestroyActivity(IBinder token, boolean finishing, int configChanges,
            boolean getNonConfigInstance, String reason) {
        ActivityClientRecord r = performDestroyActivity(token, finishing,
                configChanges, getNonConfigInstance, reason);
        if (r != null) {
            // Mocked out contexts won't be participating in the normal
            // process lifecycle, but if we're running with a proper
            // ApplicationContext we need to have it tear down things
            // cleanly.
            Context c = r.activity.getBaseContext();
            if (c instanceof ContextImpl) {
                ((ContextImpl) c).scheduleFinalCleanup(
                        r.activity.getClass().getName(), "Activity");
            }
        }
    }
    ```
- 接着看一下 ContextImpl 类的 scheduleFinalCleanup 方法
    ```
    @UnsupportedAppUsage
    final void scheduleFinalCleanup(String who, String what) {
        mMainThread.scheduleContextCleanup(this, who, what);
    }
    ```
- 再往下看。还是在ContextImpl类中，可以看到发送一个handler消息
    ```
    final void scheduleContextCleanup(ContextImpl context, String who,
            String what) {
        ContextCleanupInfo cci = new ContextCleanupInfo();
        cci.context = context;
        cci.who = who;
        cci.what = what;
        sendMessage(H.CLEAN_UP_CONTEXT, cci);
    }
  
    case CLEAN_UP_CONTEXT:
        ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj;
        cci.context.performFinalCleanup(cci.who, cci.what);
        break;
    ```
- 然后看一下performFinalCleanup这个方法做了什么
    ```
    final void performFinalCleanup(String who, String what) {
        //Log.i(TAG, "Cleanup up context: " + this);
        mPackageInfo.removeContextRegistrations(getOuterContext(), who, what);
    }
    ```
- 最后终于定位到，调用mPackageInfo 的 removeContextRegistrations方法
    - 这里面会检查，注册的广播是否有注销。如果没有注销，则会出现刚刚那种崩溃问题。
    ```
    public void removeContextRegistrations(Context context,
            String who, String what) {
        final boolean reportRegistrationLeaks = StrictMode.vmRegistrationLeaksEnabled();
        synchronized (mReceivers) {
            ArrayMap<BroadcastReceiver, LoadedApk.ReceiverDispatcher> rmap =
                    mReceivers.remove(context);
            if (rmap != null) {
                for (int i = 0; i < rmap.size(); i++) {
                    LoadedApk.ReceiverDispatcher rd = rmap.valueAt(i);
                    IntentReceiverLeaked leak = new IntentReceiverLeaked(
                            what + " " + who + " has leaked IntentReceiver "
                            + rd.getIntentReceiver() + " that was " +
                            "originally registered here. Are you missing a " +
                            "call to unregisterReceiver()?");
                    leak.setStackTrace(rd.getLocation().getStackTrace());
                    Slog.e(ActivityThread.TAG, leak.getMessage(), leak);
                    if (reportRegistrationLeaks) {
                        StrictMode.onIntentReceiverLeaked(leak);
                    }
                    try {
                        ActivityManager.getService().unregisterReceiver(
                                rd.getIIntentReceiver());
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
            }
            mUnregisteredReceivers.remove(context);
        }
    }
    ```




### 05.bug解决方案实践
- 解决方案，在销毁的时候，直接解绑广播就可以。
    ```
    //注册动态广播接收者。在初始化地图RiderMapView时调用
    if (!hasRegisterReceiver) {
        IntentFilter filter = new IntentFilter("clear");
        mapBroadcastReceiver = new MapBroadcastReceiver();
        context.registerReceiver(mapBroadcastReceiver, filter);
        hasRegisterReceiver = true;
        mLogger.debug( "MemoryCallBack init register receiver");
    }
    ```
- 解绑操作
    ```
    public void destroy(Context context){
        // 销毁的时候需要移除广播
        if (mapBroadcastReceiver != null) {
            if (hasRegisterReceiver){
                context.unregisterReceiver(mapBroadcastReceiver);
                hasRegisterReceiver = false;
                mLogger.debug( "MemoryCallBack destroy unregister receiver");
            }
        }
    }
    ```



### 06.其他延伸分析说明





