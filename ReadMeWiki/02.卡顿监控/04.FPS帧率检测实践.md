#### 目录总结
- 01.问题思考的介绍
- 02.FPS简单的介绍
- 03.Choreographer
- 04.线上帧率监控实现




### 01.问题思考的介绍
- 由于Fps，内存，Cpu等都是需要频繁采样的，比如Fps，一秒钟刷新60帧，如果全量数据上报，那么后端大佬可能就把我给打死了。



### 02.FPS简单的介绍
#### 2.1 什么是Fps
- 流畅度，是页面在滑动、渲染等过程中的体验。是一个非常重要的指标。
- Android系统要求每一帧都要在 16ms 内绘制完成，平滑的完成一帧意味着任何特殊的帧需要执行所有的渲染代码（包括 framework 发送给 GPU 和 CPU 绘制到缓冲区的命令）都要在 16ms 内完成，保持流畅的体验。
- 如果没有在期间完成渲染秒就会发生掉帧。掉帧是用户体验中一个非常核心的问题。丢弃了当前帧，并且之后不能够延续之前的帧率，这种不连续的间隔会容易会引起用户的注意，也就是我们常说的卡顿、不流畅。


#### 2.2 1秒60帧会卡吗
- 那么是不是1s只要绘制了60帧是不是就是流畅的呢？
    - 也不一定，如果发生抖动的情况，那么肯定会有其中几帧是有问题的。其中肯定会有最大绘制帧，和最小绘制帧的情况，所以平均值，最大值最小值都是我们需要知道的。
  

#### 2.3 人眼识别多少帧
- 了解一些常识
    - 12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。
    - 24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。
    - 但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。



### 03.Choreographer
- 其中关于Choreographer的介绍相关的可以参考这篇文章 https://juejin.im/post/6890407553457963022
- 一般常规的Fps采集可以通过Choreographer既UI线程绘制的编舞者，Choreographer是一个ThreadLocal的单例，接收vsync信号进行界面的渲染，我们只要对其添加一个CallBack，就可以巧妙的计算出这一帧的绘制时长。
- Matrix对于核心Choreographer是对CallbackQueue的hook，通过hook addCallbackLocked分别在不同类型的回调队列的头部添加自定义的FrameCallback。


### 04.线上帧率监控实现
- 想要实现线上用户的帧率监控，我们可以通过 Choreographer.FrameCallback 回调来实现帧率监控。
    ``` java
    public class PerformanceManager {
    
        private final Handler mMainHandler;
        private final String fpsFileName;
        private final SimpleDateFormat simpleDateFormat;
        private int mLastFrameRate;
        private int mLastSkippedFrames;
        private Context mContext;
        private final FrameRateRunnable mRateRunnable;
        private static final String TAG = "PerformanceManager";
    
        public static PerformanceManager getInstance() {
            return PerformanceManager.Holder.INSTANCE;
        }
    
    
        public void init(Context context) {
            if (context==null){
                throw new NullPointerException("context must be not null");
            }
            FloatPageManager.getInstance().init(context);
            mContext = context.getApplicationContext();
        }
    
    
        /**
         * 定时任务
         * 1.使用线程，执行一个异步定时任务，每1000ms执行一次，用于统计1秒内的帧率。
         * 2.使用 Choreographer.getInstance().postFrameCallback(this) 注册 VSYNC 信号回调监听，当 VSYNC 信号返回时，会执行 doFrame 回调函数。
         * 3.在 doFrame 方法中，我们统计每秒内的执行次数，以及记录当前帧的时间，并注册一下次监听。
         */
        private class FrameRateRunnable implements Runnable, Choreographer.FrameCallback {
            
            private int totalFramesPerSecond;
    
            private FrameRateRunnable() {
                
            }
    
            public void run() {
                mLastFrameRate = totalFramesPerSecond;
                if (mLastFrameRate > 60) {
                    mLastFrameRate = 60;
                }
                mLastSkippedFrames = 60 - mLastFrameRate;
                totalFramesPerSecond = 0;
                mMainHandler.postDelayed(this, 1000L);
                Log.i(TAG,"fps runnable run");
            }
    
            public void doFrame(long frameTimeNanos) {
                ++totalFramesPerSecond;
                //注册下一帧回调
                Choreographer.getInstance().postFrameCallback(this);
                writeFpsDataIntoFile();
            }
        }
    
    
        @SuppressLint("SimpleDateFormat")
        private PerformanceManager() {
            fpsFileName = "fps.txt";
            simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            mLastFrameRate = 60;
            mMainHandler = new Handler(Looper.getMainLooper());
            mRateRunnable = new FrameRateRunnable();
        }
    
        /**
         * 开始
         */
        public void startMonitorFrameInfo() {
            mMainHandler.postDelayed(mRateRunnable, 1000L);
            //注册下一帧回调
            Choreographer.getInstance().postFrameCallback(mRateRunnable);
        }
    
        /**
         * 暂停
         */
        public void stopMonitorFrameInfo() {
            //移除下一帧回调
            Choreographer.getInstance().removeFrameCallback(mRateRunnable);
            mMainHandler.removeCallbacks(mRateRunnable);
        }
    
        private void writeFpsDataIntoFile() {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(mLastFrameRate);
            stringBuilder.append(" ");
            stringBuilder.append(simpleDateFormat.format(
                    new Date(System.currentTimeMillis())));
            String string = stringBuilder.toString();
            String filePath = getFilePath(mContext);
            Log.i(TAG,"fps data is : "+string);
            //Samsung SM-A5160 Android 11, API 30
            Log.i(TAG,"fps data file path : "+filePath);
            ///data/user/0/com.com.yc.ycandroidtool/cache/yc/
            FileManager.writeTxtToFile(string, getFilePath(mContext), fpsFileName);
        }
    
        private static class Holder {
            private static final PerformanceManager INSTANCE = new PerformanceManager();
            private Holder() {
            }
        }
    }
    ```



### 参考
- https://blog.csdn.net/u011578734/article/details/109625782