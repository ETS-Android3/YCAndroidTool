#### 目录总结
- 02.UI线程卡顿监控思路
- 03.卡顿监控方案的设想
- 04.UI卡顿检测的实现
- 05.简单代码案例的实践



### 02.UI线程卡顿监控思路
- 想要监控线上用户UI线程的卡顿，也就是要把UI线程中的耗时逻辑找出来，然后进行优化开发。那么我们如何如做呢？
- Android中的应用程序是消息驱动的，也就是UI线程执行的所有操作，通常都会经过消息机制来进行传递（也就是Handler通信机制）。
- Handler的handleMessage负责在UI线程中处理UI相关逻辑，如果我们能在handleMessage执行之前和handleMessage执行之后，分别插入一段我们的日志代码，不就可以实现UI任务执行时间的监控了吗？


### 03.卡顿监控方案的设想
- 不优雅的处理
    - 直接创建一个基类放在我们的项目代码中，所有需要Handler的地方都对此进行继承，然后我们在基类中添加日志监控，这样就可以实现我们的目的了吧？
    - 不好，这样对项目改造的成本太高了，而且我们也监控不到系统中的消息，也监控不到第三方sdk中的消息执行时间！
- 优雅的处理
    - 分析Looper中的loop方法可知，处理消息前后有日志打印，


### 04.UI卡顿检测的实现
- 来看Looper的loop方法
    - loop方法中有一个Printer类型的logging，它会在消息执行之前和消息执行之后，输出一行日志，用于标记消息执行的开始和结束。
    - 只要记录开始日志和结束日志的时间差，就可以计算出该任务在UI线程的执行时间了，如果执行时间很长，则必然产生了卡顿。
    ``` java
    public static void loop() {
        for (;;) {
            ……
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }
            ……
            消息处理相关逻辑
            ……
            msg.target.dispatchMessage(msg);
            ……
    
            if (logging != null) {
                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
            }
        }
    }
    ```
- 如何监控这个Printer类型的日志呢？
    - 发现mLogging这个对象可以通过一个public方法进行设置！这简直太好了！可以通过setMessageLogging方法设置我们自己的Printer对象就可以实现卡顿的监控了！
    ``` java
    private Printer mLogging;
    public void setMessageLogging(@Nullable Printer printer) {
        mLogging = printer;
    }
    ```


### 05.简单代码案例的实践
- 卡顿监控代码的实现
    ```
    public final class HandlerBlockTask {
    
        private final static String TAG = "HandlerBlockTask";
        public final int BLOCK_TIME = 1000;
        private final HandlerThread mBlockThread = new HandlerThread("blockThread");
        private Handler mHandler;
        private static HandlerBlockTask INSTANCE;
    
        public static HandlerBlockTask getInstance() {
            if (INSTANCE == null) {
                synchronized (HandlerBlockTask.class) {
                    if (INSTANCE == null) {
                        INSTANCE = new HandlerBlockTask();
                    }
                }
            }
            return INSTANCE;
        }
    
    
        private final Runnable mBlockRunnable = new Runnable() {
            @Override
            public void run() {
                StringBuilder sb = new StringBuilder();
                Looper mainLooper = Looper.getMainLooper();
                StackTraceElement[] stackTrace = mainLooper.getThread().getStackTrace();
                for (StackTraceElement s : stackTrace) {
                    sb.append(s.toString()).append("\n");
                }
                Log.d(TAG, sb.toString());
            }
        };
    
        public void startWork(){
            mBlockThread.start();
            mHandler = new Handler(mBlockThread.getLooper());
            Looper.getMainLooper().setMessageLogging(new Printer() {
                private static final String START = ">>>>> Dispatching";
                private static final String END = "<<<<< Finished";
    
                @Override
                public void println(String x) {
                    if (x.startsWith(START)) {
                        startMonitor();
                    }
                    if (x.startsWith(END)) {
                        removeMonitor();
                    }
                }
            });
        }
    
        private void startMonitor() {
            mHandler.postDelayed(mBlockRunnable, BLOCK_TIME);
        }
    
        private void removeMonitor() {
            mHandler.removeCallbacks(mBlockRunnable);
        }
    
    }
    ```
- 逻辑解析：
    - 代码中，使用了一个工作线程mBlockThread来监控UI线程的卡顿。每次Looper的loop方法对消息进行处理之前，我们添加一个定时监控器。
    - 如果UI线程中的消息处理时间小于我们设定的阈值BLOCK_TIME，则取消已添加的定时器。
    - 当UI线程执行耗时任务，超过我们设定的阈值时，就会执行mBlockRunnable这个Runnable，在它的run方法中，打印出主线程卡顿时的代码堆栈。
    - 把堆栈日志收集起来，进行归类分析，就可以定位到产生卡顿问题的具体代码行号了。
- 存在的问题有：
    - 

