#### 目录介绍
- 01.整体概述
    - 1.1 项目背景
    - 1.2 卡顿介绍
    - 1.3 卡顿分类
    - 1.4 设计目标
- 02.方案设计
    - 2.1 卡顿分析
        - 2.1.1 卡顿监控
        - 2.1.2 FPS检测
    - 2.2 整体架构
        - 2.2.1 架构设计图
        - 2.2.2 UML设计图
    - 2.3 功能设计
        - 2.3.1 关键流程图
        - 2.3.2 接口设计图
        - 2.3.3 模块间依赖关系
- 03.其他设计
    - 3.1 性能设计
    - 3.2 稳定性设计
    - 3.3 灰度设计
    - 3.4 降级设计
    - 3.5 异常设计




### 01.概述
#### 1.1 项目背景
- App中卡顿让用户使用体验不佳
    - 在复杂的项目环境中，由于历史代码庞大，业务复杂，包含各种第三方库，所以在出现了卡顿的时候，我们很难定位到底是哪里出现了问题，即便知道是哪一个Activity/Fragment，也仍然需要进去里面一行一行看，动辄数千行的类再加上跳来跳去调来调去的，结果就是不了了之随它去了，实在不行了再优化吧。
- 卡顿可能引发未知问题
    - 卡顿还可能会引发一些未知的问题，比如卡顿会造成掉帧，会造成抖动，设置还会造成ANR，对用户来说体验特别不好。简单来说，就是APP用起来有点卡……
- 排查卡顿问题非常费劲
    - 很多情况下卡顿不是必现的，它们可能与机型、环境、操作等有关，存在偶然性，即使发生了，再去查那如山般的logcat，也不一定能找到卡顿的原因，是我们自己的应用导致的还是其他应用抢占资源导致的？是哪些方法导致的？很难去回朔。


#### 1.2 卡顿介绍
- UI线程执行时间
    - 在Android中，UI线程负责执行UI视图的布局、渲染等工作，UI在更新期间，如果UI线程执行时间超过了16ms，则就会产生丢帧的现象，大量的丢帧，就会造成卡顿，影响用户体验。
    - Android中规定，每秒可以执行60次屏幕刷新，当我们的APP能够达到60帧/秒时，这种体验是优秀的，当帧率降低到40帧以下，甚至30帧以下，用户就可以感知到卡顿了。
- 时间计算公式
    - 公式（1秒刷新60次，那么每次刷新耗时16毫秒）：1000毫秒 / 60帧  = 16ms ， 关于帧率怎么查看呢？可以通过fps查看。


### 1.3 卡顿分类
- CPU紧张
    - 系统CPU资源紧张，分配给APP主线程（UI线程）的CPU时间片减少。
    - UI线程中执行了大量的耗时任务，导致了UI线程视图刷新工作的阻塞。
- 频繁GC
    - Android虚拟机频繁执行GC操作导致的卡顿。由于GC会占用大量的系统资源，同时GC过程中会产生UI线程停顿，从而产生卡顿。
- 过渡绘制
    - 过度绘制产生卡顿。过度绘制会导致GPU执行时间变长，从而产生丢帧现象。



#### 1.4 设计目标
- 设计目标要求
    - 对主线程操作进行了完全透明的监控，并能输出有效的信息，帮助开发分析、定位到问题所在，迅速优化应用。
    - 要求接入方便，外部开发者调用简单，非侵入式，简单的两行就打开监控，不需要到处打点，破坏代码优雅性。
    - 精准，输出的信息可以帮助定位到问题所在（精确到行），不需要像Logcat一样，慢慢去找。
- 卡顿优化点分析
      - 如果没能在16ms内完成这个过程，就会使屏幕重复显示上一帧的内容，即造成了卡顿。在这16ms内，需要完成视图树的所有测量、布局、绘制渲染及合成。而我们的优化工作主要就是针对这个过程的。





### 02.方案设计
- 方案设计是技术文档的最核心部分，主要包括了整体架构和功能设计，这里需要体现：
- 设计的初衷：概要描述方案设计的思考，可以是为了扩展性的考虑，可以是提升性能
关键技术点的思考：描述关键技术选型的思考，比如要解耦，业内解耦方案能有router、Target-Action等，讲清楚选择的思考
- 技术上的折中/取舍：在做技术设计的时候，往往要的很多，但时间有限，那么这个需要讲一下折中与取舍，以及接下来的规划、计划



#### 2.1 整体架构
- 整体架构的组成需要有一张完成的架构设计图，描述清楚具体的分层以及层与层之间的关系
- 比如传统的开发会分为三层，展示层、逻辑层、数据层
    - 展示层的设计：视图的构成、视图间的耦合关系、具体的交互逻辑
    - 逻辑层的设计：支撑展示层所需要的数据、从数据层获取数据的加工、业务相关逻辑（比如轮询服务）
    - 数据层的设计：数据的获取方式以及存储方式，文件、数据库、本地、网络


##### 2.1.1 卡顿监控
- 第一种方案：使用LooperPrinter监控
    - 替换主线程Looper的Printer，从而监控dispatchMessage的执行时间。甚至，在Android源码中，主线程Looper也会根据执行dispatchMessage的时间来判断是否有卡顿，有则会打印一些日志。
    - 在Printer中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。
    - 卡顿之后收集相关dump信息，主要包含一些基本信息，耗时信息，CPU信息还有堆栈信息等等。可以直接参考LeakCanary即可。
- 第二种方案：使用WatchDog监控



##### 2.1.2 FPS检测


#### 2.2 功能设计
- 功能设计包含但不限于以下几个部分：逻辑流程图、接口设计图、与外部的模块间依赖关系

##### 2.2.1 关键流程图
- 设计中的最复杂、最关键的逻辑需要画出流程图，实在画不出的流程图需要用语言描述清楚。
- 关键流程需要有逻辑流程图，帮助其他同学理解功能的关键节点逻辑


##### 2.2.2 接口设计图
- 通过UML类图来展示类间关系，描述清楚接口设计的一些思考原则
    - 提供的接口，往往接口设计为了完成相关逻辑



##### 2.2.3 模块间依赖关系
- 描述清楚和哪些模块存在依赖关系以及原因，比如首页依赖于购物车模块，需要解释清楚要强耦合，有没有办法解耦
    - App内部模块间依赖
    - App外部依赖


#### 2.3 UI/动效设计
- 客户端开发有很大一部分精力在UI/动效上，对于复杂的静态UI和复杂动效，需要给出实现方案和选型逻辑
- 静态UI
    - 只有复杂的UI才需要给出设计方案，例如核心页面大重构、复杂的协调布局等
- 复杂动效
    - 复杂的动效是端上容易踩坑的关键点，需要给出实现方案的对比、选型等，为验证动效可行性，可以给出动效Demo



### 03.其他设计（Optional）
- 以下部分是可选项，主要是从异常、兼容性、性能、稳定性、灰度、降级等维护来设计。


#### 3.1 性能设计
- 有些业务项目可能会考虑性能，比如列表页，卡顿、流畅度怎么样？如何评估？
- 有些技术项目可能也会考虑性能，比如数据库设计，检索性能如何？是否有瓶颈，如何评估？


#### 3.2 稳定性设计
- 大的项目需要考虑性能如何保障？
    - 比如方案 Review
    - 比如自测Case Review，加强自测
    - 比如单测


#### 3.3 灰度设计
- 核心关键功能需要有A/B设计
- 比如UIWebview替换为WKWebview，其中存在很多不确定因素，需要做好灰度设计


#### 3.4 降级设计
- 在做一些新技术尝试时，需要考虑降级设计
    - 比如RN、swift、weex引入对原有业务造成影响的，需要有兜底，可降级
    - 参考资料
    - 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。


#### 3.5 异常设计
- 大部分业务需求都会涉及到异常处理，在关心主流程的同时需要关注异常场景怎么保证正确性？
    - 比如用户操作中途退出、网络异常、数据被清理等


#### 3.6 兼容性设计
- 业务逻辑一般不会涉及到兼容性，但UI/动效需求容易遇到兼容性问题，也是提测时需要让QA关注的
    - 比如独立端/嵌入端、高低版本API适配等


### 04.排期与计划
- 排期计划主要针对周期较长项目的时间补充，对于小型项目不需要，例如：
    - 正常的版本业务需求，5pd以下，不需要给出排期计划；5pd或者以上，可以简单描述一下排期和提测时间
    - 跨版本的大型业务需求、重构专项等，需要给出详细的排期计划
    - 研发自驱的技术优化项目，需要给出详细的排期计划


### 05.参考资料
- 需要列出方案设计过程的文档，包括但不局限于PM需求文档，技术参考文档等。
- 微信卡顿监测方案
    - https://mp.weixin.qq.com/s/3dubi2GVW_rVFZZztCpsKg
- 卡顿监控方案
    - https://github.com/markzhai/AndroidPerformanceMonitor
