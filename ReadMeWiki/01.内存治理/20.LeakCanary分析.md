#### 目录介绍
- 01.简单原理概述
- 02.最简单的使用
- 03.主要的知识点
- 04.大概的原理
- 06.install初始化操作





### 01.简单原理概述
- 什么是内存泄漏
    - 内存泄漏是不使用或用完的内存，因为某些原因无法回收，造成的一种内存浪费；内存泄漏的本质是内存浪费。
    - 以个人理解来解释，通俗一点就是：
        - 1.GC回收的对象必须是当前没有任何引用的对象。
        - 2.当对象在使用完成后（对我们而言已经是垃圾对象了），我们没有释放该对象的引用，导致GC不能回收该对象而继续占用内存。
        - 3.垃圾对象依旧占用内存，这块内存空间便浪费。
- 首先思考几个问题
    - 在Application中初始化之后，它是如何检测所有的Activity页面的 ？
    - 内存泄漏的判定条件是什么 ？ 检测内存泄漏的机制原理是什么？
    - 检测出内存泄漏后，它又是如何生成泄漏信息的？ 内存泄漏的输出轨迹是怎么得到的？
- 原理简单介绍
    - 通过监听Activity的onDestory，手动调用GC，然后通过ReferenceQueue+WeakReference，来判断Activity对象是否被回收，然后结合dump Heap的hpof文件，通过Haha开源库分析泄露的位置。



### 02.最简单的使用
- 我们直接在 Application 类中，添加一下代码即可。
    ```java
    public class ExampleApplication extends Application {
        @Override 
        public void onCreate() {
            super.onCreate();
            setupLeakCanary();
        }
    
        protected void setupLeakCanary() {
            // 启用严格模式
            enabledStrictMode();
            // 判断是否是 HeapAnalyzerService 所属进程
            if (LeakCanary.isInAnalyzerProcess(this)) {
                // This process is dedicated to LeakCanary for heap analysis.
                // You should not init your app in this process.
                return;
            }
            // 注册 LeakCanary
            LeakCanary.install(this);
        }
    
        private static void enabledStrictMode() {
            StrictMode.setThreadPolicy(
                    new StrictMode.ThreadPolicy.Builder() //
                    .detectAll() //
                    .penaltyLog() //
                    .penaltyDeath() //
                    .build());
        }
    }
    ```
- 由于 LeakCanary 的核心 hropf文件解析服务HeapAnalyzerService所属进程是与主进程独立的一个进程，所以在 setupLeakCanary中，我们需要排除其他进程，只对 leakcanary 进程注册 LeakCanary 监听处理。
    ``` java
    <service
        android:name=".internal.HeapAnalyzerService"
        android:process=":leakcanary"
        android:enabled="false"
        />
    ```
    - android:enabled="false" 这是什么？ 这里简单说下，AndroidManifest文件中的 enabled 属性，可以看到 HeapAnalyzerService 这个组件默认是不可用的，所以如果在代码中动态启用这个组件，可以使用以下方法：
    ```
    public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
          boolean enabled) {
      ComponentName component = new ComponentName(appContext, componentClass);
      PackageManager packageManager = appContext.getPackageManager();
      int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
      // Blocks on IPC.
      packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
    }
    ```


### 03.主要的知识点
- 注册Activity的生命周期的监听器
    - 通过Application.registerActivityLifecycleCallbacks()方法注册Activity的生命周期的监听器，每一个Actvity的生命周期都会回调到这个ActivityLifecycleCallbacks上，如果一个Activity走到了onDestory，那么就意味着他就不再存在，然后检测这个Activity是否是真的被销毁
    ```java
    // ActivityLifecycleCallbacks 接口
    public interface ActivityLifecycleCallbacks {
        void onActivityCreated(Activity var1, Bundle var2);
    
        void onActivityStarted(Activity var1);
    
        void onActivityResumed(Activity var1);
    
        void onActivityPaused(Activity var1);
    
        void onActivityStopped(Activity var1);
    
        void onActivitySaveInstanceState(Activity var1, Bundle var2);
    
        void onActivityDestroyed(Activity var1);
    }
    ```
- 如何检测Fragment的生命周期的呢？
    - FragmentManager 类提供了 registerFragmentLifecycleCallbacks 和 unregisterFragmentLifecycleCallbacks 方法用户注册和反注册 Fragment 的生命周期监听类，这样我们对每一个 Activity 进行注册，就能获取所有的 Fragment 生命周期回调。
    ```java
    public abstract static class FragmentLifecycleCallbacks {
    
        public void onFragmentCreated(FragmentManager fm, Fragment f, Bundle savedInstanceState) {}
    
        public void onFragmentViewDestroyed(FragmentManager fm, Fragment f) {}
    
        public void onFragmentDestroyed(FragmentManager fm, Fragment f) {}
    
        // 省略其他的生命周期 ...
    }
    ```
- 通过ReferenceQueue+WeakReference，来判断对象是否被回收
    - WeakReference创建时，可以传入一个ReferenceQueue对象，假如WeakReference中引用对象被回收，那么就会把WeakReference对象添加到ReferenceQueue中，可以通过ReferenceQueue中是否为空来判断，被引用对象是否被回收
- MessageQueue中加入一个IdleHandler来得到主线程空闲回调
    - 这个知识点等之后写一篇Handler源码分析的时候在具体分析
- 手动调用GC后还调用了System.runFinalization();，这个是强制调用已失去引用对象的finalize方法
    - 在可达性算法中，不可达对象，也不是非死不可，这时他们处于“缓刑”阶段，要宣告一个对象真正死亡需要至少俩个标记阶段， 如果发现对象没有引用链，则会进行第一次标记，并进行一次筛选，筛选的条件是此对象是否有必要进行finalize（）方法，当对象没有覆盖finalize(),或者finalize（）已经调用过，这俩种都视为“没有必要执行”
- Apolication中可通过processName判断是否是任务执行进程
    - 通过processName，来判断进程
    ``` java
    public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
        PackageManager packageManager = context.getPackageManager();
        PackageInfo packageInfo;
        try {
          packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
        } catch (Exception e) {
          CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
          return false;
        }
        String mainProcess = packageInfo.applicationInfo.processName;
    
        ComponentName component = new ComponentName(context, serviceClass);
        ServiceInfo serviceInfo;
        try {
          serviceInfo = packageManager.getServiceInfo(component, 0);
        } catch (PackageManager.NameNotFoundException ignored) {
          // Service is disabled.
          return false;
        }
    
        if (serviceInfo.processName.equals(mainProcess)) {
          CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
          // Technically we are in the service process, but we're not in the service dedicated process.
          return false;
        }
    
        int myPid = android.os.Process.myPid();
        ActivityManager activityManager =
            (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        ActivityManager.RunningAppProcessInfo myProcess = null;
        List<ActivityManager.RunningAppProcessInfo> runningProcesses =
            activityManager.getRunningAppProcesses();
        if (runningProcesses != null) {
          for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
            if (process.pid == myPid) {
              myProcess = process;
              break;
            }
          }
        }
        if (myProcess == null) {
          CanaryLog.d("Could not find running process for %d", myPid);
          return false;
        }
    
        return myProcess.processName.equals(serviceInfo.processName);
    }
    ```


### 04.大概的原理
#### 4.1 触发检测
- 每次当Activity/Fragment执行完onDestroy生命周期，LeakCanary就会获取到这个Activity/Fragment，然后初始化RefWatcher对它进行分析，查看是否存在内存泄漏。


#### 4.2 判断是否存在内存泄漏
- 首先尝试着从ReferenceQueue队列中获取待分析对象（软引用和弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用或弱引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用或弱引用加入到与之关联的引用队列中），如果不为空，那么说明正在被系统回收。如果直接就返回DONE，说明已经被系统回收了。如果没有被系统回收，可能存在内存泄漏，手动触发系统GC，然后再尝试移除待分析对象。如果还存在，说明存在内存泄漏。


#### 4.3 分析内存泄漏
- 确定有内存泄漏后，调用heapDumper.dumpHeap()生成.hprof文件目录。HAHA 是一个由 square 开源的Android 堆分析库，分析hprof文件生成Snapshot对象。Snapshot用以查询对象的最短引用链。找到最短引用链后，定位问题，排查代码将会事半功倍。
    - ![image](https://img-blog.csdnimg.cn/20200418204619916.png)


#### 4.4 整体流程
- ![image](https://img-blog.csdnimg.cn/20200418204735337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzAwMjc1,size_16,color_FFFFFF,t_70)





### 06.install初始化操作
- LeakCanary.install(this) 干了什么？LeakCanary 的 install 方法实际上构造了一个 RefWatcher,
    ```
    /**
       * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
       * references (on ICS+).
       */
    public static @NonNull RefWatcher install(@NonNull Application application) {
      return refWatcher(application)
          .listenerServiceClass(DisplayLeakService.class)
          .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
          .buildAndInstall();
    }
    ```
- 我们一个个来看这个注册方法。首先是 refWatcher 方法构造了一个 AndroidRefWatcherBuilder, 传入参数是当前Application 的 Context.
    ```
    public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
      return new AndroidRefWatcherBuilder(context);
    }
    ```
- listenerServiceClass 和 excludedRefs 方法是基于建造者模式传入分析Service 和 排除已知的泄漏问题 AndroidExcludedRefs，这里我就不贴代码了。
- 重点看下 buildAndInstall 方法，这个方法很形象的表示将要进行建造者模式的最后一步 build 和 注册一些监听器，下面我们来看具体代码：
    ```
    public @NonNull RefWatcher buildAndInstall() {
      // 只允许 install 一次
      if (LeakCanaryInternals.installedRefWatcher != null) {
        throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
      }
      // 建造者模式的最后一步，构造对象
      RefWatcher refWatcher = build();
      // 判断是否开启了 LeakCanary，没有开启默认会返回 DISABLED 对象
      if (refWatcher != DISABLED) {
        // 手动开启 DisplayLeakActivity 组件，会在桌面上显示一个查看内存泄漏结果的入口
        LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
        // 是否检测 Activity 的 内存泄漏，默认开启
        if (watchActivities) {
          ActivityRefWatcher.install(context, refWatcher);
        }
        // 是否检测 Fragment 的 内存泄漏，默认开启
        if (watchFragments) {
          FragmentRefWatcher.Helper.install(context, refWatcher);
        }
      }
      // 复制给全局静态变量，防止二次调用
      LeakCanaryInternals.installedRefWatcher = refWatcher;
      return refWatcher;
    }
    ```
    - 以上代码作用大部分都在代码中注释了，剩下 ActivityRefWatcher.install 和 FragmentRefWatcher.Helper.install 方法没有注释。下面我们就来具体看看这两个方法究竟干了什么。





