#### 目录介绍
- 01.线程优化的背景
- 02.线程使用的现状
- 03.线程的一些基础
    - 3.1 主线程与子线程
    - 3.2 UI线程的特点
    - 3.3 如何理解多线程
- 04.异步任务的方式
    - 4.1 Thread直接创建
    - 4.2 Thread+Looper+handler
    - 4.3 AsyncTask
    - 4.4 HandlerThread
    - 4.5 IntentService
    - 4.6 线程池Executors
- 05.高效的使用线程
- 06.合理设置线程优先级
    - 6.1 设置线程优先级方式
- 07.线程卡顿是怎么回事



### 03.线程的一些基础
#### 3.1 主线程与子线程
- Android 主线程负责 UI 的显示等工作，所以也成为 UI 线程，UI 线程如果阻塞，会导致界面卡顿、ANR 等问题。
- 我们为了保证 UI 的流畅性，一些耗时的工作就不能在主线程中进行处理了，例如，网络操作、I/O 操作等。绝大多数，耗时操作都应该在子线程中处理。


#### 3.2 UI线程的特点
- Android UI线程（主线程）有几个特点：
    - 只能在 UI 线程操作 UI 视图，不能在子线程中操作。
    - 不能在 UI 线程中进行耗时操作，否则会阻塞 UI 线程，引起 ANR、卡顿等问题。
- 在 Android 开发中，我们通常将一些耗时的操作使用异步任务的方式进行处理。
    - 例如这样一种这种场景，子线程在后台执行一个异步任务，任务过程中，需要 UI 进程展示进度，这时我们就需要一个工具来实现这种需求。
    - Android 系统为开发人员提供了一个异步任务类（AsyncTask）来实现上面所说的功能，即它会在一个子线程中执行计算任务，同时通过主线程的消息循环来获得更新应用程序界面的机会。




### 04.异步任务的方式
#### 4.1 Thread直接创建
- 最直接的方式，就是使用 Java 提供的 Thread 类进行线程创建，从而实现异步。
  

#### 4.2 Thread+Looper+handler
- Android 提供了 Handler 机制来进行线程之间的通信，我们可以使用 Android 最基础的异步方式：Thread + Looper + handler 来进行异步任务。
- 优点：
    - 操作简单，无学习成本。
- 缺点：
    - 代码规范性较差，不易维护。每次操作都会开启一个匿名线程，系统开销较大。


#### 4.3 AsyncTask
- 较为轻量级的异步类，封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于后台与界面持续交互。
- 优点：
    - 结构清晰，使用简单，适合后台任务的交互。
    - 异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。
- 缺点：
    - 结构略复杂，代码较多。每个 AsyncTask 只能被执行一次，多次调用会发生异常。
    - AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。


#### 4.4 HandlerThread
- HandlerThread 是一个自带 Looper 消息循环的线程类。处理异步任务的方式和 Thread + Looper + Handler 方式相同。
- 优点：
    - 简单，内部实现了普通线程的 Looper 消息循环。可以串行执行多个任务。
    - 内部拥有自己的消息队列，不会阻塞 UI 线程。
- 缺点：
    - 没有结果返回接口，需要自行处理。消息过多时，容易造成阻塞。
    - 只有一个线程处理，效率较低。线程优先级默认优先级为 THREAD_PRIORITY_DEFAULT，容易和 UI 线程抢占资源。



#### 4.5 IntentService
- IntentService 继承自 Service 类，用于启动一个异步服务任务，它的内部是通过 HandlerThread 来实现异步处理任务的。
- 优点：
    - 只需要继承 IntentService，就可以在 onHandlerIntent 方法中异步处理 Intent 类型任务了。
    - 任务结束后 IntentService 会自行停止，无需手动调用 stopService。
    - 可以执行处理多个 Intent 请求，顺序执行多任务。
    - IntentService 是继承自 Service，具有后台 Service 的优先级。
- 缺点：
    - 需要启动服务来执行异步任务，不适合简单任务处理。
    - 异步任务是由 HandlerThread 实现的，只能单线程、顺序处理任务。
    - 没有返回 UI 线程的接口。


### 4.6 线程池Executors
- 利用 Executors 的静态方法 newCachedThreadPool()、newFixedThreadPool()、newSingleThreadExecutor() 及重载形式实例化 ExecutorService 接口即得到线程池对象。
- 优点：
    - 线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。
    - 适合执行大量异步任务，提高性能。
    - 灵活性高，可以自由控制线程数量。
    - 扩展性好，可以根据实际需要进行扩展。
- 缺点：
    - 代码略显复杂。
    - 线程池本身对系统资源有一定消耗。
    - 当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。
    - 每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。
    - 线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。



### 05.高效的使用线程
- 思考一些问题
    - 了解了如何创建线程，来执行异步任务，那么如果大量的使用线程，会不会影响 UI 线程呢？会不会产生卡顿呢?答案是肯定的。
    - 因为用户手机的 CPU 资源是有限的，内存也是有限的，如果无节制的同一时刻创建的大量的线程，就会导致线程和 UI 线程同时抢占 CPU 资源，造成 UI 线程执行变慢，产生卡顿等问题；
    - 并且线程创建是有代价的，线程不但占用了大量的 CPU 资源，同时也占用了大量的内存资源，Android 在真正创建线程时，会为每个线程申请 1040KB 的内存资源，大量的线程就有可能导致 OOM 等问题。
    - 另外，线程的创建和销毁也会占用系统资源来执行，所以应该合理的使用线程。
- 如何高效的使用线程
    - 将异步任务分类，根据任务的紧急程度，使用不同优先级的线程来执行。
    - 将紧急任务，交给优先级高的线程来执行，并且要注意，线程不能产生长时间阻塞，否则会影响后续任务的执行。
    - 将不紧急任务，交给低优先级线程来执行，并且控制线程数量，少量线程，慢慢执行即可。例如，可以创建一个类似于 AnsyncTask 的全局的单线程任务队列，使用 1 个线程来执行一些不紧急的任务。
    - 使用线程池来优化线程的创建和管理线程。我们可以使用线程池来全局的管理线程的创建和执行，以此来避免频繁的线程创建和销毁，提高系统的性能。
    - 不要使用默认的线程优先级。通常，新创建的线程的线程优先级，默认情况下继承了父线程的线程优先级的，例如，在 UI 线程中创建了一个子线程，那么子线程的线程优先级就和 UI 线程是相同的。
    - 尽可能的将线程优先级级别设置的低一些，以避免子线程和 UI 线程竞争 CPU 资源。
    - 设置线程优先级时，应注意线程优先级的设置方法。




### 06.合理设置线程优先级
#### 6.1 设置线程优先级方式
- 在 Android 中，有两种常见的设置线程优先级的方式：
    - 第一种，使用 Thread 类实例的 setPriority 方法，来设置线程优先级。
    - 第二种，使用 Process 类的 setThreadPriority 方法，来设置线程优先级。
- 这两种设置线程的优先级，一种是 Java 原生版本，另一种是 Android API 版本。
    - 这两种方式是不同的，Android 更推荐使用第二种方式。
- https://blog.csdn.net/u011578734/article/details/110549238


### 07.线程卡顿是怎么回事




